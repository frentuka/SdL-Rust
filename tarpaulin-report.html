<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej1","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let num: f32 = 13548.0;\r\n    println!(\"El número a operar es {}\", num);\r\n    const FLOAT_ERROR_MSG: \u0026str = \"Error convirtiendo input (\u0026str) en f32\";\r\n\r\n    println!(\"Ingrese un número (f32) para sumar al operador:\");\r\n    let num_suma = leer_float(FLOAT_ERROR_MSG);\r\n\r\n    println!(\"Ingrese un número (f32) para restar al operador:\");\r\n    let num_resta = leer_float(FLOAT_ERROR_MSG);\r\n\r\n    println!(\"Ingrese un número (f32) para multiplicar al operador:\");\r\n    let num_mul = leer_float(FLOAT_ERROR_MSG);\r\n\r\n    println!(\"Ingrese un número (f32) para dividir al operador:\");\r\n    let num_div = leer_float(FLOAT_ERROR_MSG);\r\n\r\n    println!(\"Suma: {num} + {num_suma} = {}\", num + num_suma);\r\n    println!(\"Resta: {num} - {num_resta} = {}\", num - num_resta);\r\n    println!(\"Multiplicación: {num} * {num_mul} = {}\", num * num_mul);\r\n    println!(\"División: {num} / {num_div} = {}\", num / num_div);\r\n}\r\n\r\nfn leer_float(panic_msg: \u0026str) -\u003e f32{\r\n    let mut inp: String = String::new();\r\n    stdin().read_line(\u0026mut inp).expect(\"String input\");\r\n    match inp.trim().parse::\u003cf32\u003e() {\r\n        Ok(num) =\u003e num,\r\n        _ =\u003e panic!(\"{}\", panic_msg)\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej10","main.rs"],"content":"fn main() {\r\n    let arr1 = [1, 2, 3, 4, 5];\r\n    let arr2 = [2, 3, 4, 5, 6];\r\n    let mut arr3: Vec\u003ci32\u003e = Vec::with_capacity(5);\r\n\r\n    for i in 0..5 {\r\n        arr3[i] = arr1[i] + arr2[i];\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej11","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let arr: [\u0026str; 5] = [\"hola\", \"mundo\", \"como\", \"estas\", \"hoy\"];\r\n    let mut cadena = String::new();\r\n\r\n    println!(\"Ingrese una cadena:\");\r\n    stdin().read_line(\u0026mut cadena).unwrap();\r\n\r\n    if arr.contains(\u0026cadena.trim()) {\r\n        println!(\"La cadena se encuentra en el arreglo.\");\r\n    } else {\r\n        println!(\"La cadena no se encuentra en el arreglo.\");\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej12","main.rs"],"content":"fn main() {\r\n    let t: (\u0026str, Vec\u003cu32\u003e) = (\"josejuanjo\", [1, 2, 3, 4, 5].to_vec());\r\n\r\n    let suma: u32 = t.1.iter().sum();\r\n\r\n    println!(\"{} {}\", t.0, suma);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej2","main.rs"],"content":"fn main() {\r\n    let mi_var: u32 = 15*16*16*16; // 61440\r\n    let mi_var_hex = u32_to_hex(mi_var); // F000\r\n\r\n    println!(\"MiVar: {mi_var}, MiVarHex: {mi_var_hex}\");\r\n}\r\n\r\nfn u32_to_hex(num: u32) -\u003e String {\r\n    // convert num into hex string\r\n    format!(\"{:X}\", num)\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej3","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let mi_bool = true;\r\n\r\n    println!(\"{mi_bool} AND?\");\r\n    let bool_and = leer_bool();\r\n\r\n    println!(\"{mi_bool} OR?\");\r\n    let bool_or = leer_bool();\r\n\r\n    println!(\"{mi_bool} AND {bool_and} = {}\", mi_bool \u0026\u0026 bool_and);\r\n    println!(\"{mi_bool} OR {bool_or} = {}\", mi_bool || bool_or);\r\n}\r\n\r\nfn leer_bool() -\u003e bool {\r\n    let mut input = String::new();\r\n    stdin().read_line(\u0026mut input).expect(\"bool input\");\r\n    input.trim().parse::\u003cbool\u003e().unwrap()\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej4","main.rs"],"content":"fn main() {\r\n    let mi_tupla = (\"ohmama\", 13658, false);\r\n    println!(\"Impresión directa: {mi_tupla:?}\");\r\n    println!(\"Impresión individual: {}, {}, {}\", mi_tupla.0, mi_tupla.1, mi_tupla.2);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej5","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let cadena = \"asd \";\r\n    // concatenar:\r\n\r\n    let mut input = String::new();\r\n    stdin().read_line(\u0026mut input).expect(\"String input\");\r\n\r\n    let cadena = cadena.to_string() + \u0026input;\r\n\r\n    println!(\"{}\", cadena.to_uppercase());\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej6","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let num: u32 = 13548;\r\n    println!(\"El número a operar es {}\", num);\r\n\r\n    let mut input = String::new();\r\n\r\n    println!(\"Ingrese un número (u32) para sumar al operador:\");\r\n    stdin().read_line(\u0026mut input).expect(\"u32 input\");\r\n    let num_suma = input.trim().parse::\u003cu32\u003e().unwrap();\r\n\r\n    let suma = num + num_suma;\r\n    let cuadrado = suma.pow(2);\r\n\r\n    println!(\"Suma: {}\", suma);\r\n    println!(\"Cuadrado: {}\", cuadrado);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej7","main.rs"],"content":"fn main() {\r\n    let mut arr = vec![1, 2, 3, 4, 5, 6];\r\n    const _MULTIPLICADOR: u16 = 31;\r\n\r\n    for num in arr.iter_mut() {\r\n        *num *= _MULTIPLICADOR;\r\n    }\r\n\r\n    let arr = arr; // arr is now immutable\r\n\r\n    println!(\"{:?}\", arr);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej8","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let arr = vec![1, 4, 7, 8, 13548, 13548, 13548, 7];\r\n\r\n    let mut inp = String::new();\r\n    println!(\"Ingrese un número a corroborar de la cadena\");\r\n    stdin().read_line(\u0026mut inp).expect(\"i32 input\");\r\n    let inp = inp.trim().parse::\u003ci32\u003e().expect(\"i32 input\");\r\n\r\n    let cont = arr.iter().filter(|\u0026x| *x == inp).count();\r\n    println!(\"En el array {arr:?} hay {cont} elementos iguales a {inp}\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej9","main.rs"],"content":"fn main() {\r\n    let arr: [i32; 5] = [1, 2, 3, 4, 5];\r\n    let suma: i32 = arr.iter().sum();\r\n\r\n    println!(\"Suma de los valores: {}\", suma);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","main.rs"],"content":"fn main() {\r\n    println!(\"Hello, world! prac1\");\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej1","main.rs"],"content":"/*\r\n 1-Definir la función llamada es_par que recibe como parámetro un número entero\r\n    y retorna true si el número es par, false caso contrario.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn es_par(num: i32) -\u003e bool {\r\n    num % 2 == 0\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej10","main.rs"],"content":"/*\r\n    Definir la función llamada cantidad_de_cadenas_mayor_a que recibe como parámetros\r\n    un arreglo de String y un entero llamado límite.\r\n    Esta función retorna la cantidad de Strings del arreglo que son de longitud mayor\r\n    al parámetro límite\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn cantidad_de_cadenas_mayor_a(arr: Vec\u003cString\u003e, limite: u32) -\u003e u32 {\r\n    let mut res: u32 = 0;\r\n\r\n    for str in arr {\r\n        if str.len() \u003e limite as usize { res+= 1 }\r\n    }\r\n\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej11","main.rs"],"content":"/*\r\n    Definir la función llamada multiplicar_valores que recibe como parámetro\r\n    un arreglo de enteros y otro número entero llamado factor.\r\n    Esta función multiplica los valores del arreglo por el parámetro factor modificándolo.\r\n */\r\n\r\nfn main() {\r\n    const HHHH: \u0026str = \"hola\";\r\n}\r\n\r\nfn multiplicar_valores(arr: Vec\u003ci32\u003e, factor: i32) -\u003e Vec\u003ci32\u003e {\r\n    let mut res: Vec\u003ci32\u003e = Vec::with_capacity(arr.len());\r\n\r\n    arr.iter().for_each(|num| res.push(*num*factor));\r\n\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej12","main.rs"],"content":"/*\r\n    Definir una función llamada reemplazar_pares que recibe un arreglo de enteros\r\n    y reemplaza todos los números pares por -1.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn reemplazar_pares(arr: Vec\u003ci32\u003e) -\u003e Vec\u003ci32\u003e {\r\n    let mut res: Vec\u003ci32\u003e = Vec::with_capacity(arr.len());\r\n    arr.iter().for_each(|num| res.push(if num % 2 == 0 { -1 } else { *num }));\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej13","main.rs"],"content":"/*\r\n    Definir una función llamada ordenar_nombres que recibe un arreglo de String\r\n    y los ordena en orden alfabético.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn ordenar_nombres(arr: Vec\u003cString\u003e) -\u003e Vec\u003cString\u003e {\r\n    let mut res = arr.clone();\r\n    res.sort();\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej14","main.rs"],"content":"/*\r\n    Definir una función llamada incrementar que\r\n    recibe como parámetro un número flotante e incrementa en 1 su valor.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn incrementar(arr: Vec\u003cf32\u003e) -\u003e Vec\u003cf32\u003e {\r\n    let mut res: Vec\u003cf32\u003e = Vec::with_capacity(arr.len());\r\n    for num in arr {\r\n        res.push(num+1.0);\r\n    }\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej2","main.rs"],"content":"/*\r\n    2- Definir la función llamada es_primo que recibe un número entero positivo mayor a 1\r\n        y retorna true si es primo, false caso contrario.\r\n */\r\n\r\nfn main() {\r\n    for num in 1..100 {\r\n        println!(\"{num}: {}\", es_primo(num));\r\n    }\r\n\r\n}\r\n\r\nfn es_primo(num: u32) -\u003e bool {\r\n    for i in 2..num  {\r\n        if num % i == 0 {\r\n            return false\r\n        }\r\n    }\r\n\r\n    true\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej3","main.rs"],"content":"/*\r\n    Definir la función llamada suma_pares que recibe como parámetro un arreglo de números enteros\r\n        y retorna la suma de los números pares.\r\n */\r\n\r\nfn main() {\r\n    println!(\"{}\", suma_pares(Vec::from([1, 2, 3, 4, 5])));\r\n}\r\n\r\nfn suma_pares(arr: Vec\u003ci32\u003e) -\u003e i32 {\r\n    let mut suma: i32 = 0;\r\n\r\n    for num in arr {\r\n        if num % 2 == 0 { suma+= num }\r\n    }\r\n\r\n    suma\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej4","main.rs"],"content":"/*\r\n    Definir la función llamada cantidad_impares que recibe como parámetro\r\n        un arreglo de números enteros y retorna la cantidad de números impares.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn cantidad_pares(arr: Vec\u003ci32\u003e) -\u003e u32 {\r\n    let mut cant: u32 = 0;\r\n    for num in arr {\r\n        if num % 2 == 0 { cant+= 1 }\r\n    }\r\n    cant\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::cantidad_pares;\r\n\r\n    #[test]\r\n    fn test() {\r\n        assert_eq!(cantidad_pares(Vec::new()), 0, \"Se esperan 0 números\");\r\n    }\r\n    \r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej5","main.rs"],"content":"/*\r\n    Defina la función llamada duplicar_valores que recibe un arreglo de números flotantes\r\n        y retorna un arreglo nuevo con los valores duplicados del parámetro.\r\n */\r\n\r\nfn main() {\r\n    println!(\"{:?}\", duplicar_valores(Vec::from([1.0, 2.0, 3.0, 4.0])))\r\n}\r\n\r\nfn duplicar_valores(arr: Vec\u003cf32\u003e) -\u003e Vec\u003cf32\u003e {\r\n    let mut new_arr: Vec\u003cf32\u003e = Vec::with_capacity(arr.len());\r\n    arr.iter().for_each(|num| new_arr.push(*num * 2.0));\r\n    new_arr\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej6","main.rs"],"content":"/*\r\n    Definir la función llamada longitud_de_cadenas que recibe un arreglo de String\r\n        y retorna un arreglo con la longitud de las cadenas del parámetro,\r\n            correspondiéndose en posición del arreglo.\r\n */\r\n\r\nfn main() {\r\n    println!(\"{:?}\", longitud_de_cadenas([\"hola!\".to_string(), \"soy\".to_string(), \"pedro\".to_string()].to_vec()))\r\n}\r\n\r\nfn longitud_de_cadenas(arr: Vec\u003cString\u003e) -\u003e Vec\u003cu32\u003e {\r\n    let mut res: Vec\u003cu32\u003e = Vec::with_capacity(arr.len());\r\n    for txt in arr {\r\n        res.push(txt.len() as u32);\r\n    }\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej7","main.rs"],"content":"/*\r\n    Definir la función llamada cantidad_de_mayores que recibe como parámetro\r\n        un arreglo de números enteros y un número entero llamado límite.\r\n            Esta función retorna la cantidad de números mayores al límite que tiene el arreglo.\r\n */\r\n\r\nfn main() {\r\n    \r\n}\r\n\r\nfn cantidad_de_mayores(arr: Vec\u003ci32\u003e, limite: i32) -\u003e u32 {\r\n    let mut res: u32 = 0;\r\n    for num in arr {\r\n        if num \u003e limite { res+= 1 }\r\n    }\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej8","main.rs"],"content":"/*\r\n    Definir la función llamada sumar_arreglos que recibe 2 arreglos del mismo tamaño\r\n        de números flotantes y retorna un nuevo arreglo\r\n        que contiene la suma de los elementos de los arreglos\r\n        pasados por parámetro, correspondiendose el resultado con cada posición\r\n        de los arreglos pasados por parámetro.\r\n */\r\n\r\nfn main() {\r\n    \r\n}\r\n\r\nfn sumar_arreglos(arr1: Vec\u003cf32\u003e, arr2: Vec\u003cf32\u003e) -\u003e Vec\u003cf32\u003e {\r\n    let mut res: Vec\u003cf32\u003e = Vec::with_capacity(arr1.len());\r\n\r\n    for i in 0..arr1.len() {\r\n        res.push(arr1[i] + arr2[i]);\r\n    }\r\n    \r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej9","main.rs"],"content":"/*\r\n    Definir la función llamada cantidad_en_rango que recibe 3 parámetros:\r\n        1 arreglo de enteros\r\n        un número entero llamado inferior\r\n        y otro número entero llamado superior.\r\n        Esta función retorna la cantidad de números del arreglo que están\r\n        entre el rango de los parámetros inferior y superior inclusive.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn cantidad_en_rango(arr: Vec\u003ci32\u003e, inf: i32, sup: i32) -\u003e u32 {\r\n    let mut res: u32 = 0;\r\n\r\n    for num in arr {\r\n       if num \u003c= sup \u0026\u0026 num \u003e= inf { res+= 1 }\r\n    }\r\n\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","main.rs"],"content":"fn main() {\r\n    println!(\"Hello, world!\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej1","main.rs"],"content":"\r\n/*\r\n    1- Escribir un programa que defina una estructura Persona que tenga campos para:\r\n        - nombre\r\n        - edad\r\n        - dirección (que puede ser nulo al momento de la creación de una persona).\r\n        Para dicha estructura implemente los siguientes métodos:\r\n        ➢ new: que pasando los parámetros correspondientes, crea una Persona y la retorna.\r\n        ➢ imprimir: que imprime los datos de la persona sobre el mensaje ejecutado por ej: person.imprimir(),\r\n            donde person es una variable del tipo Persona.\r\n        ➢ obtener_edad: retorna la edad de la persona.\r\n        ➢ actualizar_direccion(nueva_direccion)\r\n */\r\n\r\nstruct Persona {\r\n    nombre:  String,\r\n    edad: u16,\r\n    direccion: Option\u003cString\u003e\r\n}\r\n\r\nimpl Persona {\r\n    fn new(nombre: String, edad: u16) -\u003e Persona {\r\n        Persona {nombre, edad, direccion: None}\r\n    }\r\n\r\n    fn actualizar_direccion(\u0026mut self, direccion: String) {\r\n        self.direccion = Some(direccion);\r\n    }\r\n\r\n    fn obtener_edad(\u0026self) -\u003e u16 {\r\n        self.edad\r\n    }\r\n\r\n    fn imprimir(\u0026self) {\r\n        println!(\"Nombre: {}, Edad: {}\", self.nombre, self.edad);\r\n        if let Some(val) = \u0026self.direccion { println!(\"Dirección: {}\", val) }\r\n    }\r\n}\r\n\r\nfn main() {\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","main.rs"],"content":"mod structs;\r\n\r\n/// # Ej. 10\r\n///\r\n/// ##### Para una biblioteca se desea implementar un sistema de préstamos de libros.\r\n/// De la biblioteca se conoce:\r\n///     el nombre,\r\n///     la dirección,\r\n///     las copias de los libros a disposición para prestar\r\n///     y los préstamos efectuados.\r\n/// \u003cbr\u003e\u003cbr\u003e\r\n/// Los \"libros a disposición\" es un registro donde se indica la cantidad de ejemplares\r\n/// que tiene a disposición para prestar de determinado libro.\r\n/// De cada libro se conoce:\r\n///     el título,\r\n///     autor,\r\n///     número de páginas,\r\n///     género (novela, infantil, técnico, otros).\r\n/// \u003cbr\u003e\u003cbr\u003e\r\n/// Para registrar un préstamo se requiere:\r\n///     el libro,\r\n///     el cliente,\r\n///     la fecha de vencimiento del préstamo,\r\n///     la fecha de devolución\r\n///     y el estado (devuelto o en préstamo)\r\n/// \u003cbr\u003e\u003cbr\u003e\r\n/// Del cliente se conoce:\r\n///     el nombre,\r\n///     teléfono\r\n///     y dirección de correo electrónico.\r\n///\r\n/// #### Implemente los métodos necesarios para realizar las siguientes acciones:\r\n///\r\n/// \u003cp\u003e➔ obtener cantidad de copias:\r\n///     dado un determinado libro retorna el retorna la cantidad de copias a disposición\r\n///     que hay para prestar de dicho libro.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ decrementar cantidad de copias a disposición:\r\n///     dado un libro decrementa en 1 la cantidad de copias de libros a disposición para prestar.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ incrementar cantidad de copias a disposición:\r\n///     dado un libro incremente en 1 la cantidad de copias del libro a disposición para ser prestado.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ contar préstamos de un cliente:\r\n///     devuelve la cantidad de préstamos en estado “en préstamo” de un determinado cliente.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ ver la cantidad disponible de un determinado libro:\r\n///     retorna la cantidad de libros disponibles del registro de “copias a disposición” de un determinado libro.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ realizar un préstamo de un libro para un cliente:\r\n///     crea un préstamo de un libro para un determinado cliente cumpliendo con lo siguiente\r\n///         ◆ el cliente no tenga más de 5 préstamos en el estado “en préstamo”\r\n///         ◆ haya al menos una copia disponible en el registro de copias a disposición.\r\n///             De ser así descuenta 1 en el registro de “copias a disposición” y retorna true,\r\n///                 si no cumple con alguna de las condiciones retorna false.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ ver préstamos a vencer el los próximos días:\r\n///     retorna una lista de préstamos a vencer el los próximos días, el valor de días es pasado por parámetro.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ ver los préstamos vencidos:\r\n///     retorna una lista de préstamos en el estado “en préstamos”\r\n///     donde la fecha de vencimiento es menor a la fecha actual.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ buscar préstamo:\r\n///     dado un libro y un cliente busca un préstamo y lo retorna si existe.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ devolver libro:\r\n///     dado un libro y un cliente se busca el préstamo y se cambia al estado “devuelto”,\r\n///     se registra la fecha de devolución y se incrementa la cantidad de libros en 1\r\n///     del libro devuelto en el registro de copias a disposición.\u003c/p\u003e\r\nfn main() {\r\n\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","biblioteca.rs"],"content":"use std::collections::BTreeMap;\r\nuse crate::structs::cliente::Cliente;\r\nuse crate::structs::fecha::Fecha;\r\nuse crate::structs::prestamo::{EstadoPrestamo, Prestamo};\r\nuse super::libro::Libro;\r\n\r\n/// # Biblioteca\r\n///\r\n/// `nombre: String` - Nombre de la biblioteca\u003cbr\u003e\r\n/// `direccion: String` - Dirección física de la biblioteca\u003cbr\u003e\r\n/// `libros: BTreeMap\u003cu64, Libro\u003e` - Libros de la biblioteca\u003cbr\u003e\r\n/// `prestamos: BTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e` - \u003cb\u003e BTreeMap\u003cID del cliente, (Cliente, Vec\u003cPrestamo\u003e)\u003e\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Biblioteca {\r\n    pub nombre: String,\r\n    pub direccion: String,\r\n    pub libros: BTreeMap\u003cu64, Libro\u003e,\r\n    pub prestamos: BTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e // \u003cID cliente, (Cliente, Vec\u003cPréstamo\u003e)\u003e\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorDecrementarStock {\r\n    StockEsCero, LibroNoExiste\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorIncrementarStock {\r\n    LibroNoExiste, Overflow\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorRealizarPrestamo {\r\n    PrestamosMaximosAlcanzados, StockInsuficiente, LibroNoExiste\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorBuscarPrestamo {\r\n    PrestamoInexistente, ClienteInexistente\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorDevolverLibro {\r\n    PrestamoInexistente, ClienteInexistente, LibroYaDevuelto\r\n}\r\n\r\nimpl Biblioteca {\r\n\r\n    /// ### fn new() -\u003e Biblioteca\r\n    /// Crea una nueva instancia de biblioteca\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `nombre` - Nombre de la biblioteca\u003cbr\u003e\r\n    /// `direccion` - Dirección de la biblioteca\u003cbr\u003e\r\n    /// `libros` - Opcional: Lista de libros de la biblioteca\u003cbr\u003e\r\n    /// `prestamos` - Opcional: Lista de préstamos de la biblioteca\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Biblioteca` - Nueva instancia de Biblioteca\r\n    fn new(nombre: String, direccion: String, libros: Option\u003cBTreeMap\u003cu64, Libro\u003e\u003e, prestamos: Option\u003cBTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e\u003e) -\u003e Biblioteca {\r\n        Biblioteca {\r\n            nombre,\r\n            direccion,\r\n            libros: libros.unwrap_or_default(),\r\n            prestamos: prestamos.unwrap_or_default()\r\n        }\r\n    }\r\n\r\n    /// ### fn cantidad_de_copias_en_stock(isbn) -\u003e Option\u003cu32\u003e\r\n    /// Devuelve la cantidad de copias disponibles de un libro\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(u32)` - Cantidad (u32) de libros en stock\u003cbr\u003e\r\n    /// `None` - No existe el libro consultado\r\n    fn cantidad_de_copias_en_stock(\u0026self, isbn: u64) -\u003e Option\u003cu32\u003e {\r\n        self.libros.get(\u0026isbn).map(|libro| libro.stock)\r\n    }\r\n\r\n    /// ### fn decrementar_stock_libro(isbn) -\u003e Result\u003cu32, ErrorDecrementarStock\u003e\r\n    /// Devuelve la cantidad de libros en stock después de decrementarla en 1\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `u32` - Cantidad de libros después de decrementar\u003cbr\u003e\r\n    /// `ErrorDecrementarStock` - El stock es cero o el libro no existe\r\n    fn decrementar_stock_libro(\u0026mut self, isbn: u64) -\u003e Result\u003cu32, ErrorDecrementarStock\u003e {\r\n        match self.libros.get_mut(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == 0 {\r\n                    Err(ErrorDecrementarStock::StockEsCero)\r\n                } else {\r\n                    libro.stock-= 1;\r\n                    Ok(libro.stock)\r\n                }\r\n            },\r\n            None =\u003e Err(ErrorDecrementarStock::LibroNoExiste)\r\n        }\r\n    }\r\n\r\n\r\n    /// ### fn incrementar_stock_libro(isbn) -\u003e Result\u003cu32, ErrorIncrementarStock\u003e\r\n    /// Devuelve la cantidad de libros en stock después de incrementarla en 1\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `u32` - Cantidad de libros después de decrementar\u003cbr\u003e\r\n    /// `ErrorIncrementarStock` - El stock es `u32::MAX` o el libro no existe\r\n    fn incrementar_stock_libro(\u0026mut self, isbn: u64) -\u003e Result\u003cu32, ErrorIncrementarStock\u003e {\r\n        match self.libros.get_mut(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == u32::MAX {\r\n                    Err(ErrorIncrementarStock::Overflow)\r\n                } else {\r\n                    libro.stock+= 1;\r\n                    Ok(libro.stock)\r\n                }\r\n            },\r\n            None =\u003e Err(ErrorIncrementarStock::LibroNoExiste)\r\n        }\r\n    }\r\n\r\n    /// ### fn cantidad_prestamos_cliente(cliente) -\u003e Option\u003cusize\u003e\r\n    /// Devuelve la cantidad de préstamos efectuados a un cliente\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `cliente` - ID del cliente a consultar\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(usize)` - Cantidad de préstamos efectuados al cliente\u003cbr\u003e\r\n    /// `None` - El cliente no existe\r\n    fn cantidad_prestamos_cliente(\u0026self, cliente: u32) -\u003e Option\u003cusize\u003e {\r\n        // match self.prestamos.get(cliente) {\r\n        //     Some(cliente) =\u003e {\r\n        //         Some(cliente.len())\r\n        //     },\r\n        //     None =\u003e None\r\n        // }\r\n\r\n        self.prestamos.get(\u0026cliente).map(|cliente| cliente.1.len()) // compiler suggestion\r\n    }\r\n\r\n    /// ### fn cantidad_stock_libro(isbn) -\u003e Option\u003cu32\u003e\r\n    /// Devuelve la cantidad de libros en stock del libro consultado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(u32)` - Cantidad de libros en stock\u003cbr\u003e\r\n    /// `None` - El libro no existe\r\n    fn cantidad_stock_libro(\u0026self, isbn: u64) -\u003e Option\u003cu32\u003e {\r\n        self.libros.get(\u0026isbn).map(|libro| libro.stock) // compiler suggestion\r\n    }\r\n\r\n    /// ### fn realizar_prestamo(cliente, isbn, vencimiento) -\u003e Result(usize, ErrorRealizarPrestamo)\r\n    /// Realiza un préstamo del libro en nombre del cliente con el vencimiento especificado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `cliente` - Cliente a efectuar el préstamo\u003cbr\u003e\r\n    /// `isbn` - ID del libro a prestar\u003cbr\u003e\r\n    /// `vencimiento` - Fecha de vencimiento del préstamo\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `usize` - Cantidad de préstamos del cliente, incluyendo el recién realizado\r\n    fn realizar_prestamo(\u0026mut self, cliente: Cliente, isbn: u64, vencimiento: Fecha) -\u003e Result\u003cusize, ErrorRealizarPrestamo\u003e /* \u003cCant. préstamos del cliente, Error\u003e */ {\r\n        match self.libros.get(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == 0 {\r\n                    return Err(ErrorRealizarPrestamo::StockInsuficiente)\r\n                }\r\n            },\r\n            None =\u003e return Err(ErrorRealizarPrestamo::LibroNoExiste)\r\n        }\r\n\r\n        let prestamo = Prestamo::new(isbn, cliente.id, vencimiento, None, EstadoPrestamo::Prestando);\r\n\r\n        match self.prestamos.get_mut(\u0026cliente.id) {\r\n            Some(dato) =\u003e {\r\n                let cant_libros_no_devueltos = dato.1.iter().filter(|p| p.devolucion.is_none() \u0026\u0026 p.estado == EstadoPrestamo::Prestando).count();\r\n                if cant_libros_no_devueltos \u003e= 5 {\r\n                    return Err(ErrorRealizarPrestamo::PrestamosMaximosAlcanzados);\r\n                }\r\n\r\n                // si el préstamo alguna vez se realizó, eliminar el antiguo préstamo\r\n                dato.1.retain(|p| p.isbn != isbn);\r\n\r\n                // quitar stock al libro a prestar\r\n                // no puedo usar self.decrementar_stock_libro() porque tendría 2 borrows mutables en simultáneo\r\n                if let Some(libro) = self.libros.get_mut(\u0026isbn) { libro.stock-= 1 } // compiler suggestion\r\n\r\n                dato.1.push(prestamo);\r\n                Ok(cant_libros_no_devueltos)\r\n            },\r\n            None =\u003e {\r\n                // insertar cliente\r\n                self.prestamos.insert(cliente.id, (cliente, vec![prestamo]));\r\n                self.decrementar_stock_libro(isbn);\r\n                Ok(1)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// ### fn prestamos_a_vencer(feca_hoy, dias) -\u003e Vec\u003c\u0026Prestamo\u003e\r\n    /// Devuelve un Vec\u003c\u0026Prestamo\u003e con los préstamos a vencer en los próximos `dias` días\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `fecha_hoy` - Fecha del día de hoy\u003cbr\u003e\r\n    /// `dias` - Días en los que vencerán los préstamos devueltos\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Vec\u003c\u0026Prestamo\u003e` - Los préstamos que vencerán en los próximos `dias` días\r\n    fn prestamos_por_vencer(\u0026self, fecha_hoy: Fecha, dias: u32) -\u003e Vec\u003c\u0026Prestamo\u003e {\r\n        let mut prestamos_por_vencer: Vec\u003c\u0026Prestamo\u003e = Vec::new();\r\n\r\n        let mut fecha_limte = fecha_hoy;\r\n        fecha_limte.sumar_dias(dias);\r\n        let fecha_limite = fecha_limte; // quitar mutabilidad\r\n\r\n        for prestamos_cliente in self.prestamos.values() {\r\n            for prestamo in \u0026prestamos_cliente.1 {\r\n\r\n                match \u0026prestamo.devolucion {\r\n                    Some(_) =\u003e continue, // ya fue devuelto, no contabilizar\r\n                    None =\u003e {\r\n                        if prestamo.devolucion.is_none() \u0026\u0026 prestamo.estado == EstadoPrestamo::Prestando \u0026\u0026 prestamo.vencimiento \u003c= fecha_limite {\r\n                            prestamos_por_vencer.push(prestamo);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        prestamos_por_vencer\r\n    }\r\n\r\n    /// ### fn prestamos_vencidos(fecha_hoy) -\u003e Vec\u003c\u0026Prestamo\u003e\r\n    /// Devuelve los prestamos que hayan vencido\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `fecha_hoy` - La fecha de hoy\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Vec\u003c\u0026Prestamo\u003e` - Los préstamos que han vencido\r\n    fn prestamos_vencidos(\u0026self, fecha_hoy: Fecha) -\u003e Vec\u003c\u0026Prestamo\u003e {\r\n        let mut prestamos_vencidos: Vec\u003c\u0026Prestamo\u003e = Vec::new();\r\n\r\n        for prestamos_cliente in self.prestamos.values() {\r\n            for prestamo in \u0026prestamos_cliente.1 {\r\n                if prestamo.estado == EstadoPrestamo::Prestando \u0026\u0026 prestamo.vencimiento \u003c fecha_hoy {\r\n                    prestamos_vencidos.push(prestamo);\r\n                }\r\n            }\r\n        }\r\n\r\n        prestamos_vencidos\r\n    }\r\n\r\n    /// ### fn buscar_prestamo(isbn, id_cliente) -\u003e Result\u003c\u0026Prestamo, ErrorBuscarPrestamo\u003e\r\n    /// Devuelve un préstamo en específico\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro prestado\u003cbr\u003e\r\n    /// `id_cliente` - ID del cliente del préstamo\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `\u0026Prestamo` - El préstamo buscado\u003cbr\u003e\r\n    /// `ErrorBuscarPrestamo` - El préstamo o el cliente no existen\r\n    fn buscar_prestamo(\u0026self, isbn: u64, id_cliente: u32) -\u003e Result\u003c\u0026Prestamo, ErrorBuscarPrestamo\u003e {\r\n        match self.prestamos.get(\u0026id_cliente) {\r\n            Some(dato) =\u003e {\r\n                for prestamo in \u0026dato.1 {\r\n                    if prestamo.isbn == isbn { return Ok(prestamo) }\r\n                }\r\n                    Err(ErrorBuscarPrestamo::PrestamoInexistente)\r\n            },\r\n            None =\u003e Err(ErrorBuscarPrestamo::ClienteInexistente)\r\n        }\r\n    }\r\n\r\n    /// ### fn devolver_libro(isbn, id_cliente, fecha_hoy) -\u003e Result\u003c\u0026Prestamo, ErrorDevolverLibro\u003e\r\n    /// Realiza la devolución del libro especificado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a devolver\u003cbr\u003e\r\n    /// `id_cliente` - ID del cliente que devuelve\u003cbr\u003e\r\n    /// `fecha_hoy` - La fecha de hoy\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `\u0026Prestamo` - El préstamo del libro que se ha devuelto\u003cbr\u003e\r\n    /// `ErrorDevolverLibro` - El cliente o el préstamo no existen o ya fue devuelto\r\n    fn devolver_libro(\u0026mut self, isbn: u64, id_cliente: u32, fecha_hoy: Fecha) -\u003e Result\u003c\u0026Prestamo, ErrorDevolverLibro\u003e {\r\n        match self.prestamos.get_mut(\u0026id_cliente) {\r\n            Some(dato) =\u003e {\r\n                for prestamo in dato.1.iter_mut() {\r\n                    if prestamo.isbn == isbn {\r\n                        if prestamo.estado == EstadoPrestamo::Devuelto {\r\n                            return Err(ErrorDevolverLibro::LibroYaDevuelto)\r\n                        }\r\n\r\n                        prestamo.devolucion = Some(fecha_hoy);\r\n                        prestamo.estado = EstadoPrestamo::Devuelto;\r\n\r\n                        // no puedo usar self.incrementar_stock_libro() porque tendría 2 borrows mutables en simultáneo\r\n                        if let Some(libro) = self.libros.get_mut(\u0026isbn) { libro.stock-= 1 }\r\n\r\n                        return Ok(prestamo)\r\n                    }\r\n                }\r\n                Err(ErrorDevolverLibro::PrestamoInexistente)\r\n            },\r\n            None =\u003e Err(ErrorDevolverLibro::ClienteInexistente)\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::collections::BTreeMap;\r\n    use crate::structs::biblioteca::{Biblioteca, ErrorDecrementarStock, ErrorIncrementarStock, ErrorRealizarPrestamo};\r\n    use crate::structs::cliente::Cliente;\r\n    use crate::structs::fecha::Fecha;\r\n    use crate::structs::libro::Libro;\r\n    use crate::structs::prestamo::EstadoPrestamo;\r\n\r\n    fn biblioteca_de_pepe() -\u003e Biblioteca {\r\n        Biblioteca::new(\r\n            \"biblio de pepe\".to_string(),\r\n            \"donde queda\".to_string(),\r\n            Some(BTreeMap::from(\r\n                [(1, libro_economia_1()),\r\n                    (2, libro_xd_2()),\r\n                    (3, libro_harrypotter_3()),\r\n                    (4, libro_asd_4()),\r\n                    (5, libro_estadistica_5()),\r\n                    (u32::MAX as u64, libro_algo_u32max())])),\r\n            None)\r\n    }\r\n    fn cliente_pepe() -\u003e Cliente {\r\n        Cliente::new(\r\n            1,\r\n            \"pepe\".to_string(),\r\n            \"123\".to_string(),\r\n            \"pepe@gmail.com\".to_string()\r\n        )\r\n    }\r\n    fn cliente_manuel() -\u003e Cliente {\r\n        Cliente::new(\r\n            3,\r\n            \"manuel\".to_string(),\r\n            \"123\".to_string(),\r\n            \"manuel@gmail.com\".to_string()\r\n        )\r\n    }\r\n    fn libro_economia_1() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 1;\r\n        libro.titulo = \"Economía en una lección\".to_string();\r\n        libro.stock = 1;\r\n        libro\r\n    }\r\n    fn libro_xd_2() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 2;\r\n        libro.titulo = \"xd\".to_string();\r\n        libro.stock = 2;\r\n        libro\r\n    }\r\n    fn libro_harrypotter_3() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 3;\r\n        libro.titulo = \"Harry Potter y qsy q mas\".to_string();\r\n        libro.stock = 3;\r\n        libro\r\n    }\r\n    fn libro_asd_4() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 4;\r\n        libro.titulo = \"asd\".to_string();\r\n        libro.stock = 4;\r\n        libro\r\n    }\r\n    fn libro_estadistica_5() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 5;\r\n        libro.titulo = \"Estadística\".to_string();\r\n        libro.stock = 5;\r\n        libro\r\n    }\r\n    fn libro_algo_u32max() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = u32::MAX as u64;\r\n        libro.titulo = \"algo\".to_string();\r\n        libro.stock = u32::MAX;\r\n        libro\r\n    }\r\n\r\n    #[test]\r\n    fn test_cant_copias() {\r\n        let mut biblioteca = biblioteca_de_pepe();\r\n\r\n        // test dec\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 5, \"ISBN 5 tiene 5 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 3, \"ISBN 3 tiene 3 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 1, \"ISBN 1 tiene 1 copias\");\r\n\r\n        biblioteca.decrementar_stock_libro(5);\r\n        biblioteca.decrementar_stock_libro(3);\r\n        biblioteca.decrementar_stock_libro(1);\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 4, \"ISBN 5 tiene 4 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 2, \"ISBN 3 tiene 2 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 0, \"ISBN 1 tiene 0 copias\");\r\n\r\n        // test inc\r\n\r\n        biblioteca.incrementar_stock_libro(5);\r\n        biblioteca.incrementar_stock_libro(3);\r\n        biblioteca.incrementar_stock_libro(1);\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 5, \"ISBN 5 tiene 5 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 3, \"ISBN 3 tiene 3 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 1, \"ISBN 1 tiene 1 copias\");\r\n\r\n        // test 0\r\n\r\n        biblioteca.decrementar_stock_libro(1);\r\n\r\n        biblioteca.decrementar_stock_libro(5);\r\n        biblioteca.decrementar_stock_libro(3);\r\n        let dec = biblioteca.decrementar_stock_libro(1);\r\n\r\n        assert_eq!(dec.unwrap_err(), ErrorDecrementarStock::StockEsCero, \"stock debería ser cero\");\r\n\r\n        // test overflow\r\n\r\n        let inc = biblioteca.incrementar_stock_libro(u32::MAX as u64);\r\n        assert_eq!(inc.unwrap_err(), ErrorIncrementarStock::Overflow, \"stock debería ser u32::MAX\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_prestamos() {\r\n        let mut biblioteca = biblioteca_de_pepe();\r\n\r\n        // init realizar prestamos\r\n\r\n        let fecha5 = Fecha{ dia: 1, mes: 1, ano: 1 };\r\n        let fecha3 = Fecha{ dia: 2, mes: 1, ano: 1 };\r\n\r\n        let p5 = biblioteca.realizar_prestamo(cliente_pepe(), 5, fecha5.clone());\r\n        let p3 = biblioteca.realizar_prestamo(cliente_manuel(), 3, fecha3.clone());\r\n\r\n        // check\r\n\r\n        if p5.is_err() { panic!(\"Error inesperado realizando préstamo: {:?}\", p5.unwrap_err()) }\r\n        if p3.is_err() { panic!(\"Error inesperado realizando préstamo: {:?}\", p3.unwrap_err()) }\r\n\r\n        assert_eq!(p5.unwrap(), 1, \"Debería tener 1 préstamo\");\r\n        assert_eq!(p3.unwrap(), 1, \"Debería tener 1 préstamo\");\r\n\r\n        // init cant copias\r\n\r\n        let stock5 = biblioteca.cantidad_de_copias_en_stock(5);\r\n        let stock3 = biblioteca.cantidad_de_copias_en_stock(3);\r\n\r\n        // check\r\n\r\n        if stock5.is_none() { panic!(\"cantidad_de_copias_en_strock(): None\") }\r\n        if stock3.is_none() { panic!(\"cantidad_de_copias_en_strock(): None\") }\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 4, \"Deberían haber 4 copias en stock\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 2, \"Deberían haber 2 copias en stock\");\r\n\r\n        // init prestamos por vencer\r\n\r\n        let prestamos_a_vencer0 = biblioteca.prestamos_por_vencer(Fecha { dia: 1, mes: 1, ano: -1 }, 0);\r\n        let prestamos_a_vencer1 = biblioteca.prestamos_por_vencer(fecha5.clone(), 0);\r\n        let prestamos_a_vencer2 = biblioteca.prestamos_por_vencer(fecha5.clone(), 1);\r\n        let prestamos_a_vencer2_2 = biblioteca.prestamos_por_vencer(Fecha { dia: 22, mes: 08, ano: 2002 }, 0);\r\n\r\n        // check\r\n\r\n        assert_eq!(prestamos_a_vencer0.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer1.len(), 1, \"Debería haber 1 préstamo a vencer\");\r\n        assert_eq!(prestamos_a_vencer2.len(), 2, \"Deberían haber 2 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2_2.len(), 2, \"Deberían haber 0 préstamos a vencer\");\r\n\r\n        // init buscar prestamos\r\n\r\n        let buscar_prestamo5 = biblioteca.buscar_prestamo(5, cliente_pepe().id);\r\n        let buscar_prestamo3 = biblioteca.buscar_prestamo(3, cliente_manuel().id);\r\n\r\n        // check\r\n\r\n        if buscar_prestamo5.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo5.unwrap_err()) }\r\n        if buscar_prestamo3.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo3.unwrap_err()) }\r\n\r\n        assert_eq!(buscar_prestamo5.unwrap().isbn, 5, \"El préstamo encontrado debería ser sobre el libro #5\");\r\n        assert_eq!(buscar_prestamo3.unwrap().isbn, 3, \"El préstamo encontrado debería ser sobre el libro #3\");\r\n\r\n        // init-check devolver prestamos\r\n\r\n        let devolucion_prestamo5 = biblioteca.devolver_libro(5, cliente_pepe().id, fecha5.clone());\r\n        if devolucion_prestamo5.is_err() { panic!(\"\") }\r\n\r\n        let devolucion_prestamo3 = biblioteca.devolver_libro(3, cliente_manuel().id, fecha3.clone());\r\n        if devolucion_prestamo3.is_err() { panic!(\"\") }\r\n\r\n        // init prestamos por vencer post-devolver\r\n\r\n        let prestamos_a_vencer0 = biblioteca.prestamos_por_vencer(Fecha { dia: 1, mes: 1, ano: -1 }, 0);\r\n        let prestamos_a_vencer1 = biblioteca.prestamos_por_vencer(fecha5.clone(), 0);\r\n        let prestamos_a_vencer2 = biblioteca.prestamos_por_vencer(fecha5.clone(), 1);\r\n        let prestamos_a_vencer2_2 = biblioteca.prestamos_por_vencer(Fecha { dia: 22, mes: 08, ano: 2002 }, 0);\r\n\r\n        // check\r\n\r\n        assert_eq!(prestamos_a_vencer0.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer1.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2_2.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n\r\n        // init buscar prestamos post-devolver\r\n\r\n        let buscar_prestamo5 = biblioteca.buscar_prestamo(5, cliente_pepe().id);\r\n        let buscar_prestamo3 = biblioteca.buscar_prestamo(3, cliente_manuel().id);\r\n\r\n        // check\r\n\r\n        if buscar_prestamo5.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo5.unwrap_err()) }\r\n        if buscar_prestamo3.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo3.unwrap_err()) }\r\n\r\n        assert_eq!(buscar_prestamo5.clone().unwrap().isbn, 5, \"El préstamo encontrado debería ser sobre el libro #5\");\r\n        assert_eq!(buscar_prestamo3.clone().unwrap().isbn, 3, \"El préstamo encontrado debería ser sobre el libro #3\");\r\n\r\n        assert_eq!(buscar_prestamo5.clone().unwrap().estado, EstadoPrestamo::Devuelto, \"El préstamo encontrado debería haber sido devuelto\");\r\n        assert_eq!(buscar_prestamo3.clone().unwrap().estado, EstadoPrestamo::Devuelto, \"El préstamo encontrado debería haber sido devuelto\");\r\n\r\n        assert!(buscar_prestamo5.unwrap().devolucion.is_some(), \"El préstamo encontrado debería haber sido devuelto\");\r\n        assert!(buscar_prestamo3.unwrap().devolucion.is_some(), \"El préstamo encontrado debería haber sido devuelto\");\r\n\r\n        // init max prestamos (5)\r\n\r\n        let p1 = biblioteca.realizar_prestamo(cliente_pepe(), 1, fecha5.clone());\r\n        let p2 = biblioteca.realizar_prestamo(cliente_pepe(), 2, fecha5.clone());\r\n        let p3 = biblioteca.realizar_prestamo(cliente_pepe(), 3, fecha5.clone());\r\n        let p4 = biblioteca.realizar_prestamo(cliente_pepe(), 4, fecha5.clone());\r\n        let p5 = biblioteca.realizar_prestamo(cliente_pepe(), 5, fecha5.clone());\r\n\r\n        let p6 = biblioteca.realizar_prestamo(cliente_pepe(), u32::MAX as u64, fecha3.clone());\r\n\r\n        // check\r\n\r\n        assert!(p1.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p2.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p3.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p4.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p5.is_ok(), \"El préstamo debería ser exitoso\");\r\n\r\n        assert!(p6.is_err(), \"El préstamo no debería ser exitoso\");\r\n        assert_eq!(p6.unwrap_err(), ErrorRealizarPrestamo::PrestamosMaximosAlcanzados, \"Debería haberse alcanzado el límite máximo de préstamos\");\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","cliente.rs"],"content":"/// Del cliente se conoce:\r\n///     el nombre,\r\n///     teléfono\r\n///     y dirección de correo electrónico.\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Cliente {\r\n    pub id: u32,\r\n    pub nombre: String,\r\n    pub telefono: String,\r\n    pub email: String,\r\n}\r\n\r\nimpl Cliente {\r\n    pub fn new(id: u32, nombre: String, telefono: String, email: String) -\u003e Cliente {\r\n        Cliente { id, nombre, telefono, email }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","fecha.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct Fecha {\r\n    pub(crate) dia: u8,\r\n    pub(crate) mes: u8,\r\n    pub(crate) ano: i64\r\n}\r\n\r\nimpl Default for Fecha {\r\n    fn default() -\u003e Self {\r\n        Fecha { dia: 1, mes: 1, ano: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Fecha {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.dia == other.dia\r\n            \u0026\u0026 self.mes == other.mes\r\n            \u0026\u0026 self.ano == other.ano\r\n        { return Some(Equal) }\r\n\r\n        if self.ano \u003e other.ano { return Some(Greater) }\r\n        if self.mes \u003e other.mes { return Some(Greater) }\r\n        if self.dia \u003e other.dia { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cFecha\u003e {\r\n        let fecha = Fecha { dia, mes, ano };\r\n        if fecha.es_fecha_valida() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia == 0\r\n            || self.dia \u003e self.dias_mes_actual()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n\r\n    pub fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n\r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","libro.rs"],"content":"/// De cada libro se conoce:\r\n///     el título,\r\n///     autor,\r\n///     número de páginas,\r\n///     género (novela, infantil, técnico, otros).\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub(crate) struct Libro {\r\n    pub isbn: u64,\r\n    pub titulo: String,\r\n    pub autor: String,\r\n    pub paginas: u16,\r\n    pub genero: Genero,\r\n    pub stock: u32\r\n}\r\n\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub enum Genero {\r\n    Novela, Infantil, Tecnico, #[default] Otros\r\n}\r\n\r\nimpl Libro {\r\n    pub fn new(isbn: u64, titulo: String, autor: String, paginas: u16, genero: Genero, stock: u32) -\u003e Libro {\r\n        Libro { isbn, titulo, autor, paginas, genero, stock }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","mod.rs"],"content":"pub mod prestamo;\r\npub mod biblioteca;\r\npub mod cliente;\r\npub mod libro;\r\npub mod fecha;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","prestamo.rs"],"content":"use super::fecha::Fecha;\r\n\r\n/// Para registrar un préstamo se requiere:\r\n///     el libro,\r\n///     el cliente,\r\n///     la fecha de vencimiento del préstamo,\r\n///     la fecha de devolución\r\n///     y el estado (devuelto o en préstamo)\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Prestamo {\r\n    pub isbn: u64, // isbn\r\n    pub cliente: u32, // id\r\n    pub vencimiento: Fecha,\r\n    pub devolucion: Option\u003cFecha\u003e,\r\n    pub estado: EstadoPrestamo\r\n}\r\n\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub enum EstadoPrestamo {\r\n    Devuelto, #[default] Prestando\r\n}\r\n\r\nimpl Prestamo {\r\n    \r\n    pub fn new(isbn: u64, cliente: u32, vencimiento: Fecha, devolucion: Option\u003cFecha\u003e, estado: EstadoPrestamo) -\u003e Prestamo {\r\n        Prestamo { isbn, cliente, vencimiento, devolucion, estado }\r\n    }\r\n    \r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej2","main.rs"],"content":"\r\n/*\r\n    2- Escribir un programa que defina la estructura Rectángulo que tenga campos para la\r\n        longitud y el ancho. Para dicha estructura implemente los siguientes métodos:\r\n        ➢ new: que pasando los parámetros correspondientes, crea un Rectángulo y lo\r\n        retorna.\r\n        ➢ calcular_area: calcular el área y la retorna.\r\n        ➢ calcular_perimetro: calcula el perímetro y lo retorna.\r\n        ➢ es_cuadrado: retorna true si es cuadrado, false caso contrario\r\n */\r\n\r\nstruct Rectangulo {\r\n    longitud: u16,\r\n    ancho: u16\r\n}\r\n\r\nimpl Rectangulo {\r\n    fn new(longitud: u16, ancho: u16) -\u003e Rectangulo {\r\n        if longitud == 0 || ancho == 0 { panic!(\"Una longitud medible no puede ser 0\") }\r\n        Rectangulo { longitud, ancho }\r\n    }\r\n    \r\n    fn calcular_area(\u0026self) -\u003e u32 {\r\n        self.longitud as u32 * self.ancho as u32\r\n    }\r\n    \r\n    fn calcular_perimetro(\u0026self) -\u003e u32 {\r\n        self.longitud as u32*2 + self.ancho as u32*2\r\n    }\r\n    \r\n    fn es_cuadrado(\u0026self) -\u003e bool {\r\n        self.longitud == self.ancho\r\n    }\r\n}\r\n\r\nfn main() { }\r\n\r\n#[cfg(test)]\r\nmod tests_rectangulo {\r\n    use crate::Rectangulo;\r\n\r\n    #[test]\r\n    fn test_limites() {\r\n        let mi_rectangulo = Rectangulo::new(u16::MAX, u16::MAX);\r\n        let mi_rectangulo_neg = Rectangulo::new(u16::MIN, u16::MIN);\r\n        let mi_rectangulo_0 = Rectangulo::new(0, 0);\r\n\r\n        // shouldn't panic\r\n        let area = mi_rectangulo.calcular_area();\r\n        let perimetro = mi_rectangulo.calcular_perimetro();\r\n        let cuadrado = mi_rectangulo.es_cuadrado();\r\n\r\n        let area = mi_rectangulo_neg.calcular_area();\r\n        let perimetro = mi_rectangulo_neg.calcular_perimetro();\r\n        let cuadrado = mi_rectangulo_neg.es_cuadrado();\r\n\r\n        let area = mi_rectangulo_0.calcular_area();\r\n        let perimetro = mi_rectangulo_0.calcular_perimetro();\r\n        let cuadrado = mi_rectangulo_0.es_cuadrado();\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej3","main.rs"],"content":"\r\n/*\r\n    3- Escribir un programa que defina una estructura Fecha que tenga campos para:\r\n        - día\r\n        - mes\r\n        - año\r\n        Para dicha estructura implemente los siguientes métodos:\r\n        ➢ new: que pasando los parámetros correspondientes, crea una Fecha y la retorna.\r\n        ➢ es_fecha_valida: retorna true si es una fecha valida, false caso contrario.//tenga en\r\n        cuenta los años bisiestos también.\r\n        ➢ es_bisiesto: retorna true si el año de la fecha pertenece a un año bisiesto.\r\n        ➢ sumar_dias(dias): suma la cantidad de días a la fecha, modificándose\r\n        ➢ restar_dias(dias): resta la cantidad de días a la fecha, modificándose\r\n        ➢ es_mayor(una_fecha): que retorna true si la fecha que recibe el mensaje es mayor a\r\n        la fecha pasada por parámetro..\r\n */\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n                                  \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n                                  \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Debug, PartialEq)]\r\nstruct Fecha {\r\n    dia: u8,\r\n    mes: u8,\r\n    ano: i64\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    fn new(dia: u8, mes: u8, ano: i64) -\u003e Fecha {\r\n        Fecha { dia, mes, ano }\r\n    }\r\n\r\n    fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia \u003c 1 \r\n        || self.dia \u003e self.dias_mes_actual()\r\n            { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n    \r\n    fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n        \r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n            \r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n                \r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n                \r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n                \r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut fecha = Fecha::new(22, 08, 2002);\r\n    println!(\"{}\", fecha);\r\n    fecha.sumar_dias(5000);\r\n    println!(\"{}\", fecha);\r\n    fecha.restar_dias(5000);\r\n    println!(\"{}\", fecha);\r\n\r\n    println!();\r\n\r\n    let mut fecha2 = Fecha::new(31, 12, 2025);\r\n    fecha2.sumar_dias(1);\r\n    println!(\"{}\", fecha2);\r\n    fecha2.restar_dias(1);\r\n    println!(\"{}\", fecha2);\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::Fecha;\r\n\r\n    #[test]\r\n    fn test_bisiestos() {\r\n        let fecha = Fecha::new(22, 8, 2002);\r\n        assert!(!fecha.es_bisiesto(), \"2002 no es un año bisiesto\");\r\n        \r\n        let fecha_2 = Fecha::new(22, 8, 2020);\r\n        assert!(fecha_2.es_bisiesto(), \"2020 es bisiesto\");\r\n        \r\n        let fecha_3 = Fecha::new(1, 1, 0);\r\n        assert!(fecha_3.es_bisiesto(), \"0 es bisiesto\");\r\n    }\r\n    \r\n    #[test]\r\n    fn test_suma_resta() {\r\n        let mut fecha_1 = Fecha::new(22, 8, 2002);\r\n        let fecha_2 = Fecha::new(22, 8, 2002);\r\n        \r\n        fecha_1.sumar_dias(5000);\r\n        \r\n        assert_eq!(fecha_1, Fecha::new(30, 4, 2016), \"22/08/2002 + 5000 días = 30/04/2016\");\r\n        \r\n        fecha_1.restar_dias(5000);\r\n        \r\n        assert_eq!(fecha_1, fecha_2, \"22/08/2002 + 5000 - 5000 == 22/08/2002\");\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej4","main.rs"],"content":"/*\r\n    4- Escribir un programa que defina la estructura Triángulo que tenga campos para las\r\n    longitudes de sus tres lados. Para dicha estructura implemente los siguientes métodos:\r\n        ➢ new: que pasando los parámetros correspondientes, crea un Triángulo y lo retorna.\r\n        ➢ determinar_tipo: retorna el tipo del triángulo, los tipos pueden ser equilátero, isósceles o escaleno.\r\n        ➢ calcular_area: calcular el área y la retorna.\r\n        ➢ calcular_perimetro: calcula el perímetro y lo retorna.\r\n*/\r\n\r\n#[derive(Debug)]\r\n#[derive(PartialEq)]\r\nenum TrianguloTypes {\r\n    Equilatero, Isosceles, Escaleno\r\n}\r\n\r\nstruct Triangulo {\r\n    a: f32,\r\n    b: f32,\r\n    c: f32\r\n}\r\n\r\nimpl Triangulo {\r\n    fn new(a: f32, b: f32, c: f32) -\u003e Result\u003cTriangulo, String\u003e {\r\n        if a == 0.0\r\n            || b == 0.0\r\n            || c == 0.0\r\n        { return Err(\"Una longitud medible no puede ser 0\".to_string()) }\r\n        \r\n        if (a + b) \u003c c\r\n            || (a + c) \u003c b\r\n            || (b + c) \u003c a\r\n        { return Err(\"La suma de dos catetos debe ser mayor al tercer cateto\".to_string()) }\r\n        \r\n        Ok(Triangulo {a, b, c})\r\n    }\r\n\r\n    fn determinar_tipo(\u0026self) -\u003e TrianguloTypes {\r\n        if self.a == self.b \u0026\u0026 self.b == self.c {\r\n            return TrianguloTypes::Equilatero\r\n        }\r\n\r\n        if self.a == self.b\r\n        || self.a == self.c\r\n        || self.b == self.c { return TrianguloTypes::Isosceles }\r\n        \r\n        TrianguloTypes::Escaleno\r\n    }\r\n\r\n    fn calcular_area(\u0026self) -\u003e f32 {\r\n        let s = (self.a + self.b + self.c) / 2.0;\r\n        // √[s(s - a)(s - b)(s - c)],\r\n        (s * ((s-self.a)*(s-self.b)*(s-self.c))).sqrt()\r\n    }\r\n\r\n    fn calcular_perimetro(\u0026self) -\u003e f32 {\r\n        self.a + self.b + self.c\r\n    }\r\n\r\n}\r\n\r\nfn main() {\r\n    \r\n}\r\n\r\n#[cfg(test)]\r\nmod test_triangulo {\r\n    use crate::{Triangulo, TrianguloTypes};\r\n    \r\n    #[test]\r\n    fn test_triangulo_invalido_1() {\r\n        let triangulo_invalido = Triangulo::new(1.0, 1.0, 1000.0);\r\n        assert!(triangulo_invalido.is_err());\r\n    }\r\n    \r\n    #[test]\r\n    fn test_triangulo_invalido_2() {\r\n        let triangulo_invalido = Triangulo::new(0.0, 1.0, 1.0);\r\n        assert!(triangulo_invalido.is_err());\r\n    }\r\n    \r\n    #[test]\r\n    fn test_triangulo_types() {\r\n        if let Ok(triangulo) = Triangulo::new(1.0, 1.0, 1.0) { assert_eq!(triangulo.determinar_tipo(), TrianguloTypes::Equilatero, \"Debería ser equilátero\"); }\r\n        if let Ok(triangulo) = Triangulo::new(1.0, 1.0, 2.0) { assert_eq!(triangulo.determinar_tipo(), TrianguloTypes::Isosceles, \"Debería ser isósceles\"); };\r\n        if let Ok(triangulo) = Triangulo::new(1.0, 2.0, 3.0) { assert_eq!(triangulo.determinar_tipo(), TrianguloTypes::Escaleno, \"Debería ser escaleno\"); }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej5","main.rs"],"content":"/*\r\n    5- Escribir un programa que defina una estructura Producto que tenga campos para el\r\n        nombre, el precio bruto y un número identificatorio. Para dicha estructura implemente los\r\n        siguientes métodos:\r\n        ➢ new: que pasando los parámetros correspondientes, crea un Producto y lo retorna.\r\n        ➢ calcular_impuestos(porcentaje_de_impuestos): retorna el valor de impuestos sobre\r\n        el precio bruto\r\n        ➢ aplicar_descuento(porcentaje_de_descuento): retorna el valor del porcentaje de\r\n        descuento sobre el precio bruto\r\n        ➢ calcular_precio_total(porcentaje_de_impuestos, porcentaje_descuento): retorna el\r\n        precio total a pagar aplicando impuesto y descuento. Tenga en cuenta que los\r\n        parámetros son opcionales.\r\n*/\r\n\r\nstruct Producto {\r\n    nombre: String,\r\n    precio: f32,\r\n    id: i32\r\n}\r\n\r\nimpl Producto {\r\n    fn new(nombre: String, precio: f32, id: i32) -\u003e Result\u003cProducto, String\u003e {\r\n        if precio \u003c 0.0 { return Err(\"Un precio no puede ser negativo.\".to_string()) }\r\n        Ok(Producto { nombre, precio, id })\r\n    }\r\n\r\n    fn calcular_impuestos(\u0026self, porc: f32) -\u003e f64 {\r\n        self.precio as f64 * porc as f64 / 100.0\r\n    }\r\n\r\n    fn aplicar_descuento(\u0026self, porc: f32) -\u003e f64 {\r\n        self.precio as f64 * (1.0 - porc as f64 / 100.0)\r\n    }\r\n\r\n    fn calcular_precio_total(\u0026self, porc_imp: Option\u003cf32\u003e, porc_desc: Option\u003cf32\u003e) -\u003e f64 {\r\n        let mut precio: f64 = self.precio as f64;\r\n\r\n        if porc_desc.is_some() { precio-= self.aplicar_descuento(porc_desc.unwrap()) }\r\n        if porc_imp.is_some() { precio+= self.calcular_impuestos(porc_imp.unwrap()) }\r\n        \r\n        precio\r\n    }\r\n}\r\n\r\nfn main() {\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::Producto;\r\n\r\n    #[test]\r\n    fn test_limites() {\r\n        let producto = Producto::new(\"asd\".to_string(), f32::MAX, i32::MAX).unwrap();\r\n\r\n        // should not panic\r\n        let precio_total_1 = producto.calcular_precio_total(Some(f32::MAX), Some(f32::MAX));\r\n        let precio_total_2 = producto.calcular_precio_total(Some(f32::MIN), Some(f32::MIN));\r\n    }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej6","Fermin_Franco_v1.rs"],"content":"\r\n/*\r\n    6- Escribir un programa que defina una estructura Estudiante que tenga campos para:\r\n            nombre,\r\n            número de identificación,\r\n            las calificaciones de exámenes.\r\n        De cada Examen se conoce:\r\n            nombre de la materia,\r\n            la nota.\r\n        Para dichas estructuras implemente los siguientes métodos:\r\n            ❖ Examen:\r\n                ➢ new: que pasando los parámetros correspondientes, crea un Examen y lo retorna.\r\n            ❖ Estudiante:\r\n                ➢ new: que pasando los parámetros correspondientes, crea un Estudiante y lo retorna.\r\n                ➢ obtener_promedio: retorna el promedio de las notas.\r\n                ➢ obtener_calificacion_mas_alta: retorna la nota más alta.\r\n                ➢ obtener_calificacion_mas_baja: retorna la nota más baja.\r\n        Nota: Tenga en cuenta que el Estudiante puede tener entre 0 y n notas de examen.\r\n */\r\nuse std::cmp::min;\r\n\r\n#[derive(Debug, Default, PartialEq, Clone, PartialOrd)]\r\nstruct Examen {\r\n    materia: String,\r\n    nota: f32\r\n}\r\n\r\n#[derive(Debug, Default, PartialEq, Clone, PartialOrd)]\r\nstruct Estudiante {\r\n    nombre: String,\r\n    id: u32,\r\n    notas: Vec\u003cExamen\u003e\r\n}\r\n\r\nimpl Examen {\r\n    fn new(materia: String, nota: f32) -\u003e Option\u003cExamen\u003e {\r\n        if nota \u003e= 0.0 { return Some(Examen { materia, nota }) }\r\n        None\r\n    }\r\n\r\n}\r\n\r\n/*\r\n        Este informe debe incluir:\r\n        Nombre e identificación del estudiante.,\r\n        Cantidad total de exámenes rendidos.,\r\n        Promedio general de notas.,\r\n        Nota más alta y la materia correspondiente.,\r\n        Nota más baja y la materia correspondiente.\r\n */\r\nstruct InformeAcademico {\r\n    nombre: String,\r\n    examenes_rendidos: u16,\r\n    promedio_notas: Option\u003cf32\u003e,\r\n    max_nota: Option\u003cExamen\u003e,\r\n    min_nota: Option\u003cExamen\u003e\r\n}\r\n\r\nimpl InformeAcademico {\r\n    fn new(nombre: String, examenes_rendidos: u16, promedio_notas: Option\u003cf32\u003e, max_nota: Option\u003cExamen\u003e, min_nota: Option\u003cExamen\u003e) -\u003e Option\u003cInformeAcademico\u003e {\r\n        if examenes_rendidos != 0 \u0026\u0026 ( // si hay un examen rendido, todos los campos deben estar rellenos\r\n            promedio_notas.is_none()\r\n            || max_nota.is_none()\r\n            || min_nota.is_none()) {\r\n            return None;\r\n        }\r\n\r\n        Some(InformeAcademico { nombre, examenes_rendidos, promedio_notas, max_nota, min_nota })\r\n    }\r\n}\r\n\r\n\r\nimpl Estudiante {\r\n    fn new(nombre: String, id: u32, notas: Vec\u003cExamen\u003e) -\u003e Estudiante {\r\n        Estudiante { nombre, id, notas }\r\n    }\r\n\r\n    // ➢ obtener_promedio: retorna el promedio de las notas.\r\n    fn obtener_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        let cant_notas = self.notas.len();\r\n        let mut suma_notas: u16 = 0;\r\n\r\n        for examen in \u0026self.notas {\r\n            suma_notas+= examen.nota as u16;\r\n        }\r\n\r\n        if cant_notas != 0 { return Some(suma_notas as f32 / cant_notas as f32) }\r\n        None\r\n    }\r\n\r\n    // ➢ obtener_calificacion_mas_alta: retorna la nota más alta.\r\n    fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| a.nota.total_cmp(\u0026b.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    // ➢ obtener_calificacion_mas_baja: retorna la nota más baja.\r\n    fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| b.nota.total_cmp(\u0026a.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    /*\r\n        Deberán agregar una funcionalidad al ejercicio que permita retornar un informe detallado del rendimiento académico de un estudiante.\r\n\r\n        Este informe debe incluir:\r\n        Nombre e identificación del estudiante.,\r\n        Cantidad total de exámenes rendidos.,\r\n        Promedio general de notas.,\r\n        Nota más alta y la materia correspondiente.,\r\n        Nota más baja y la materia correspondiente.\r\n     */\r\n\r\n    /*\r\n        struct InformeAcademico {\r\n            nombre: String,\r\n            examenes_rendidos: u16,\r\n            promedio_notas: Option\u003cf32\u003e,\r\n            max_nota: Option\u003cExamen\u003e,\r\n            min_nota: Option\u003cExamen\u003e\r\n        }\r\n     */\r\n    fn generar_informe(\u0026self) -\u003e Option\u003cInformeAcademico\u003e {\r\n        let mut suma_total_notas: f32 = 0.0;\r\n        let mut min_nota: Option\u003c\u0026Examen\u003e = None;\r\n        let mut max_nota: Option\u003c\u0026Examen\u003e = None;\r\n\r\n        for examen in \u0026self.notas {\r\n            if min_nota.is_none() { min_nota = Some(examen) }\r\n            if max_nota.is_none() { max_nota = Some(examen) }\r\n\r\n            if examen.nota \u003c min_nota.unwrap().nota { min_nota = Some(examen); }\r\n            if examen.nota \u003c max_nota.unwrap().nota { max_nota = Some(examen); }\r\n\r\n            suma_total_notas+= examen.nota;\r\n        }\r\n\r\n        let promedio_notas: Option\u003cf32\u003e = match self.notas.len() {\r\n            0 =\u003e None,\r\n            cant_notas =\u003e Some(suma_total_notas / (cant_notas as f32))\r\n        };\r\n\r\n        InformeAcademico::new(\r\n            self.nombre.clone(),\r\n            self.notas.len() as u16,\r\n            promedio_notas,\r\n            max_nota.cloned(),\r\n            min_nota.cloned()\r\n        )\r\n    }\r\n\r\n}\r\n\r\nfn main() {\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{Estudiante, Examen};\r\n\r\n    #[test]\r\n    fn test() {\r\n        let examen1 = Examen::new(\"OC\".to_string(), 4.0);\r\n        let examen2 = Examen::new(\"Matematica 2\".to_string(), 7.0);\r\n\r\n        assert!(examen1.is_some(), \"Examen1 debería ser algo\");\r\n        assert!(examen2.is_some(), \"Examen2 debería ser algo\");\r\n\r\n        let nuevo_estudiante = Estudiante::new(\"jorgito\".to_string(), 29, vec![examen1.unwrap(), examen2.unwrap()]);\r\n\r\n        assert_eq!(nuevo_estudiante.nombre, \"jorgito\");\r\n        assert_eq!(nuevo_estudiante.id, 29);\r\n        assert_eq!(nuevo_estudiante.obtener_calificacion_mas_alta(), Some(7.0));\r\n        assert_eq!(nuevo_estudiante.obtener_calificacion_mas_baja(), Some(4.0));\r\n        assert_eq!(nuevo_estudiante.obtener_promedio(), Some(5.5));\r\n    }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej6","Fermin_Franco_v2.rs"],"content":"const CALIFICACION_MAXIMA: f32 = 10.0;\r\n\r\n/// ### Examen\r\n/// `materia: String` - Nombre de la materia del examen\u003cbr\u003e\r\n/// `nota: f32` - Calificación de un Estudiante en dicho examen\r\n#[derive(Debug, Default, PartialEq, Clone, PartialOrd)]\r\nstruct Examen {\r\n    materia: String,\r\n    nota: f32\r\n}\r\n\r\n/// ### Estudiante\r\n/// `nombre: String` - Nombre del estudiante\u003cbr\u003e\r\n/// `id: u32` - ID del estudiante\u003cbr\u003e\r\n/// `notas: Vec\u003cExamen\u003e` - Vector de exámenes que rindió el estudiante\r\n#[derive(Debug, Default, PartialEq, Clone, PartialOrd)]\r\nstruct Estudiante {\r\n    nombre: String,\r\n    id: u32,\r\n    notas: Vec\u003cExamen\u003e\r\n}\r\n\r\n/// ### InformeAcademico\u003cbr\u003e\r\n/// `nombre: String` - Nombre e identificación del estudiante\u003cbr\u003e\r\n/// `examenes_rendidos: u16` - Cantidad total de exámenes rendidos\u003cbr\u003e\r\n/// `promedio_notas: Option\u003cf32\u003e` - Promedio general de notas\u003cbr\u003e\r\n/// `max_nota: Option\u003c\u0026Examen\u003e` - Nota mas alta y la materia correspondiente\u003cbr\u003e\r\n/// `min_nota: Option\u003c\u0026Examen\u003e` - Nota más baja y la materia correspondiente\r\nstruct InformeAcademico\u003c'a\u003e {\r\n    nombre: String,\r\n    id: u32,\r\n    examenes_rendidos: u16,\r\n    promedio_notas: Option\u003cf32\u003e,\r\n    max_nota: Option\u003c\u0026'a Examen\u003e,\r\n    min_nota: Option\u003c\u0026'a Examen\u003e\r\n}\r\n\r\nimpl Examen {\r\n    /// ### new(materia, nota) -\u003e Option\\\u003cExamen\\\u003e\r\n    /// Crea y devuelve una nueva instancia de Examen si los datos proporcionados son válidos\r\n    /// \r\n    /// #### Recibe:\r\n    /// `materia: String` - Nombre de la materia del examen\u003cbr\u003e\r\n    /// `nota: f32` - Nota del estudiante en dicho examen\r\n    /// \r\n    /// #### Devuelve:\r\n    /// `Some(Examen)` - Examen que contiene toda la información recibida\u003cbr\u003e\r\n    /// `None` - Los datos recibidos no son válidos\r\n    /// \r\n    /// #### Excepciones inválidas:\r\n    /// `nota \u003c 0.0` - La nota debe ser un número positivo\u003cbr\u003e\r\n    /// `nota \u003e CALIFICACION_MAXIMA` - La nota debe ser menor o igual a la calificación máxima permitida\r\n    fn new(materia: String, nota: f32) -\u003e Option\u003cExamen\u003e {\r\n        if (0.0..=CALIFICACION_MAXIMA).contains(\u0026nota) { return Some(Examen { materia, nota }) }\r\n        None\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e InformeAcademico\u003c'a\u003e {\r\n    \r\n    /// ### fn new(nombre, examenes_rendidos, promedio_notas, max_nota, min_nota) -\u003e Option\\\u003cInformeAcademico\\\u003e\r\n    /// Crea y devuelve una nuvea instancia de InformeAcademico si los datos proporcionados son válidos\r\n    /// \r\n    /// #### Recibe:\r\n    /// `nombre` - Nombre del estudiante\u003cbr\u003e\r\n    /// `examenes_rendidos` - Cantidad de exámenes rendidos por el estudiante\u003cbr\u003e\r\n    /// `promedio_notas` - Promedio de exámenes rendidos\u003cbr\u003e\r\n    /// `max_nota` - Examen con mayor nota del estudiante\u003cbr\u003e\r\n    /// `min_nota` - Examen con menor nota del estudiante\r\n    /// \r\n    /// #### Devuelve:\r\n    /// `Some(InformeAcademico)` - Informe académico que contiene toda la información recibida\u003cbr\u003e\r\n    /// `None` - Hubo una incongruencia en los datos recibidos\r\n    /// \r\n    /// #### Incongruencias\r\n    /// `examenes_rendidos == 0` - Pero alguno de los datos (promedio, max_nota, min_nota) presenta información\u003cbr\u003e\r\n    /// `examenes_rendidos != 0` - Pero alguno de los datos (promedio, max_not, min_nota) no presenta información\r\n    fn new(nombre: String,\r\n           id: u32,\r\n           examenes_rendidos: u16,\r\n           promedio_notas: Option\u003cf32\u003e,\r\n           max_nota: Option\u003c\u0026'a Examen\u003e,\r\n           min_nota: Option\u003c\u0026'a Examen\u003e\r\n    ) -\u003e Option\u003cInformeAcademico\u003c'a\u003e\u003e {\r\n        \r\n        // Si hay al menos un examen rendido todos los campos deben ser Some()\r\n        if examenes_rendidos != 0 \u0026\u0026 (\r\n            promedio_notas.is_none()\r\n            || max_nota.is_none()\r\n            || min_nota.is_none()) {\r\n            return None;\r\n        }\r\n\r\n        // Caso opuesto. Si no hay exámenes rendidos todos los campos deben ser None\r\n        if examenes_rendidos == 0 \u0026\u0026 (\r\n            promedio_notas.is_some()\r\n            || max_nota.is_some()\r\n            || min_nota.is_some()) {\r\n            return None;\r\n        }\r\n\r\n        Some(InformeAcademico { nombre, id, examenes_rendidos, promedio_notas, max_nota, min_nota })\r\n    }\r\n}\r\n\r\nimpl Estudiante {\r\n    /// ### new(nombre, id, notas) -\u003e Estudiante\r\n    /// Crea una nueva instancia de Estudiante\r\n    fn new(nombre: String, id: u32, notas: Vec\u003cExamen\u003e) -\u003e Estudiante {\r\n        Estudiante { nombre, id, notas }\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_promedio() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la mayor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La calificación promedio del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        let cant_notas = self.notas.len();\r\n        let mut suma_notas: u16 = 0;\r\n\r\n        for examen in \u0026self.notas {\r\n            suma_notas+= examen.nota as u16;\r\n        }\r\n\r\n        if cant_notas != 0 { return Some(suma_notas as f32 / cant_notas as f32) }\r\n        None\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_mas_alta() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la mayor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La mayor calificación del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| a.nota.total_cmp(\u0026b.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_mas_baja() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la menor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La menor calificación del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| b.nota.total_cmp(\u0026a.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    /// ### fn generar_informe() -\u003e Option\u003cInformeAcademico\u003e\r\n    /// Procesa los datos del estudiante y devuelve un informe acorde.\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(InformeAcademico)` - Informe académico del alumno\u003cbr\u003e\r\n    /// `None` - Incongruencias no permitieron fabricar el informe académico\r\n    fn generar_informe(\u0026self) -\u003e Option\u003cInformeAcademico\u003e {\r\n        let mut suma_total_notas: f32 = 0.0;\r\n        let mut min_nota: Option\u003c\u0026Examen\u003e = None;\r\n        let mut max_nota: Option\u003c\u0026Examen\u003e = None;\r\n\r\n        /*\r\n            Sería posible utilizar las funciones ya existentes de la struct Estudiante:\r\n                fn obtener_calificacion_promedio() -\u003e Option\u003cf32\u003e\r\n                fn obtener_calificacion_mas_alta() -\u003e Option\u003cf32\u003e\r\n                fn obtener_calificacion_mas_baja() -\u003e Option\u003cf32\u003e\r\n            Pero en cada una se realiza una consulta individual al vector de exámenes del estudiante,\r\n            por lo que estaría recorrieno la misma información 3 veces, lo cual es absolutamente innecesario\r\n            entonces me resulta una mucho mejor idea prescindir de todas estas funciones.\r\n         */\r\n\r\n        for examen in \u0026self.notas {\r\n            match min_nota {\r\n                Some(val) =\u003e if examen.nota \u003c val.nota { min_nota = Some(examen) }\r\n                None =\u003e min_nota = Some(examen)\r\n            }\r\n\r\n            match max_nota {\r\n                Some(val) =\u003e if examen.nota \u003e val.nota { max_nota = Some(examen) }\r\n                None =\u003e max_nota = Some(examen)\r\n            }\r\n\r\n            suma_total_notas+= examen.nota;\r\n        }\r\n\r\n        let promedio_notas: Option\u003cf32\u003e = match self.notas.len() {\r\n            0 =\u003e None,\r\n            cant_notas =\u003e Some(suma_total_notas / (cant_notas as f32))\r\n        };\r\n\r\n        // Sólo puede \"fallar\" (devolver None) si:\r\n        //      self.notas != 0 \u0026\u0026 (promedio_notas != Some(f32) || max_nota != Some(Examen) || min_nota != Some(Examen))\r\n        //   || self.notas == 0 \u0026\u0026 (promedio_notas == Some(f32) || max_nota == Some(Examen) || min_nota == Some(Examen))\r\n        // lo cual, creo, es imposible.\r\n        InformeAcademico::new(\r\n            self.nombre.clone(),\r\n            self.id,\r\n            self.notas.len() as u16,\r\n            promedio_notas,\r\n            max_nota,\r\n            min_nota\r\n        )\r\n    }\r\n}\r\n\r\nfn main() { }\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{Estudiante, Examen};\r\n\r\n    fn estudiante() -\u003e Estudiante {\r\n        let examen1 = Examen::new(\"SdL Rust\".to_string(), 4.0);\r\n        let examen2 = Examen::new(\"AyED\".to_string(), 5.0);\r\n        let examen3 = Examen::new(\"FOD\".to_string(), 6.0);\r\n        let examen4 = Examen::new(\"Matematica 3\".to_string(), 7.0);\r\n\r\n        assert!(examen1.is_some(), \"Examen1 debería brindar Some(Examen)\");\r\n        assert!(examen2.is_some(), \"Examen2 debería brindar Some(Examen)\");\r\n        assert!(examen3.is_some(), \"Examen3 debería brindar Some(Examen)\");\r\n        assert!(examen4.is_some(), \"Examen4 debería brindar Some(Examen)\");\r\n\r\n        Estudiante::new(\"jorgito\".to_string(), 13548, vec![\r\n            examen1.unwrap(),\r\n            examen2.unwrap(),\r\n            examen3.unwrap(),\r\n            examen4.unwrap()])\r\n    }\r\n\r\n    #[test]\r\n    fn test_max_min_prom() {\r\n        let estudiante = estudiante();\r\n\r\n        assert_eq!(estudiante.obtener_calificacion_mas_alta(), Some(7.0));\r\n        assert_eq!(estudiante.obtener_calificacion_mas_baja(), Some(4.0));\r\n        assert_eq!(estudiante.obtener_calificacion_promedio(), Some(5.5));\r\n    }\r\n\r\n    #[test]\r\n    fn test_informe_academico_some() {\r\n        let estudiante = estudiante();\r\n        let informe = estudiante.generar_informe();\r\n\r\n        assert!(informe.is_some(), \"Informe debería brindar Some(InformeAcademico)\");\r\n\r\n        let informe = informe.unwrap();\r\n\r\n        let nombre_estudiante = informe.nombre;\r\n        let id_estudiante = informe.id;\r\n        let examenes_rendidos = informe.examenes_rendidos;\r\n\r\n        let min_nota = informe.min_nota;\r\n        let max_nota = informe.max_nota;\r\n        let promedio = informe.promedio_notas;\r\n\r\n        assert_eq!(nombre_estudiante, \"jorgito\".to_string(), \"El nombre se debe preservar\");\r\n        assert_eq!(id_estudiante, 13548, \"El nombre se debe preservar\");\r\n        assert_eq!(examenes_rendidos, 4, \"Se rindieron 4 exámenes\");\r\n\r\n        assert!(min_nota.is_some(), \"Debería existir nota mínima\");\r\n        assert!(max_nota.is_some(), \"Debería existir nota máxima\");\r\n        assert!(promedio.is_some(), \"Debería existir promedio\");\r\n\r\n        assert_eq!(min_nota.unwrap().nota, 4.0, \"La nota mínima debería ser 4.0\");\r\n        assert_eq!(max_nota.unwrap().nota, 7.0, \"La nota máxima debería ser 7.0\");\r\n        assert_eq!(promedio.unwrap(), 5.5, \"La nota promedio debería ser 5.5\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_informe_academico_none() {\r\n        let estudiante = Estudiante::new(\"jorgito\".to_string(), 29, Vec::new());\r\n        let informe = estudiante.generar_informe();\r\n\r\n        assert!(informe.is_some(), \"Informe debería brindar Some(InformeAcademico)\");\r\n\r\n        let informe = informe.unwrap();\r\n\r\n        assert_eq!(informe.examenes_rendidos, 0, \"No deberían existir exámenes rendidos\");\r\n        assert_eq!(informe.max_nota, None, \"No debería existir nota mínima\");\r\n        assert_eq!(informe.min_nota, None, \"No debería existir nota máxima\");\r\n        assert_eq!(informe.promedio_notas, None, \"No debería existir nota promedio\");\r\n    }\r\n}","traces":[{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej6","main.rs"],"content":"const CALIFICACION_MAXIMA: f32 = 10.0;\r\n\r\n/// ### Examen\r\n/// `materia: String` - Nombre de la materia del examen\u003cbr\u003e\r\n/// `nota: f32` - Calificación de un Estudiante en dicho examen\r\n#[derive(Debug, PartialEq)]\r\nstruct Examen\u003c'e\u003e {\r\n    materia: \u0026'e str,\r\n    nota: f32\r\n}\r\n\r\n/// ### Estudiante\r\n/// `nombre: String` - Nombre del estudiante\u003cbr\u003e\r\n/// `id: u32` - ID del estudiante\u003cbr\u003e\r\n/// `notas: Vec\u003cExamen\u003e` - Vector de exámenes que rindió el estudiante\r\nstruct Estudiante\u003c'a, 'e\u003e {\r\n    nombre: \u0026'a str,\r\n    id: u32,\r\n    notas: Vec\u003cExamen\u003c'e\u003e\u003e\r\n}\r\n\r\n/// ### InformeAcademico\u003cbr\u003e\r\n/// `nombre: String` - Nombre e identificación del estudiante\u003cbr\u003e\r\n/// `examenes_rendidos: u16` - Cantidad total de exámenes rendidos\u003cbr\u003e\r\n/// `promedio_notas: Option\u003cf32\u003e` - Promedio general de notas\u003cbr\u003e\r\n/// `max_nota: Option\u003c\u0026Examen\u003e` - Nota mas alta y la materia correspondiente\u003cbr\u003e\r\n/// `min_nota: Option\u003c\u0026Examen\u003e` - Nota más baja y la materia correspondiente\r\nstruct InformeAcademico\u003c'a, 'e\u003e {\r\n    nombre: \u0026'a str,\r\n    id: u32,\r\n    examenes_rendidos: u16,\r\n    promedio_notas: Option\u003cf32\u003e,\r\n    max_nota: Option\u003c\u0026'a Examen\u003c'e\u003e\u003e,\r\n    min_nota: Option\u003c\u0026'a Examen\u003c'e\u003e\u003e\r\n}\r\n\r\nimpl\u003c'e\u003e Examen\u003c'e\u003e {\r\n    /// ### new(materia, nota) -\u003e Option\\\u003cExamen\\\u003e\r\n    /// Crea y devuelve una nueva instancia de Examen si los datos proporcionados son válidos\r\n    /// \r\n    /// #### Recibe:\r\n    /// `materia: String` - Nombre de la materia del examen\u003cbr\u003e\r\n    /// `nota: f32` - Nota del estudiante en dicho examen\r\n    /// \r\n    /// #### Devuelve:\r\n    /// `Some(Examen)` - Examen que contiene toda la información recibida\u003cbr\u003e\r\n    /// `None` - Los datos recibidos no son válidos\r\n    /// \r\n    /// #### Excepciones inválidas:\r\n    /// `nota \u003c 0.0` - La nota debe ser un número positivo\u003cbr\u003e\r\n    /// `nota \u003e CALIFICACION_MAXIMA` - La nota debe ser menor o igual a la calificación máxima permitida\r\n    fn new(materia: \u0026str, nota: f32) -\u003e Option\u003cExamen\u003e {\r\n        if (0.0..=CALIFICACION_MAXIMA).contains(\u0026nota) { return Some(Examen { materia, nota }) }\r\n        None\r\n    }\r\n}\r\n\r\nimpl\u003c'a, 'e\u003e InformeAcademico\u003c'a, 'e\u003e {\r\n    \r\n    /// ### fn new(nombre, examenes_rendidos, promedio_notas, max_nota, min_nota) -\u003e Option\\\u003cInformeAcademico\\\u003e\r\n    /// Crea y devuelve una nuvea instancia de InformeAcademico si los datos proporcionados son válidos\r\n    /// \r\n    /// #### Recibe:\r\n    /// `nombre` - Nombre del estudiante\u003cbr\u003e\r\n    /// `examenes_rendidos` - Cantidad de exámenes rendidos por el estudiante\u003cbr\u003e\r\n    /// `promedio_notas` - Promedio de exámenes rendidos\u003cbr\u003e\r\n    /// `max_nota` - Examen con mayor nota del estudiante\u003cbr\u003e\r\n    /// `min_nota` - Examen con menor nota del estudiante\r\n    /// \r\n    /// #### Devuelve:\r\n    /// `Some(InformeAcademico)` - Informe académico que contiene toda la información recibida\u003cbr\u003e\r\n    /// `None` - Hubo una incongruencia en los datos recibidos\r\n    /// \r\n    /// #### Incongruencias\r\n    /// `examenes_rendidos == 0` - Pero alguno de los datos (promedio, max_nota, min_nota) presenta información\u003cbr\u003e\r\n    /// `examenes_rendidos != 0` - Pero alguno de los datos (promedio, max_not, min_nota) no presenta información\r\n    fn new(nombre: \u0026'a str,\r\n           id: u32,\r\n           examenes_rendidos: u16,\r\n           promedio_notas: Option\u003cf32\u003e,\r\n           max_nota: Option\u003c\u0026'e Examen\u003e,\r\n           min_nota: Option\u003c\u0026'e Examen\u003e\r\n    ) -\u003e Option\u003cInformeAcademico\u003c'a, 'e\u003e\u003e {\r\n        \r\n        // Si hay al menos un examen rendido todos los campos deben ser Some()\r\n        if examenes_rendidos != 0 \u0026\u0026 (\r\n            promedio_notas.is_none()\r\n            || max_nota.is_none()\r\n            || min_nota.is_none()) {\r\n            return None;\r\n        }\r\n\r\n        // Caso opuesto. Si no hay exámenes rendidos todos los campos deben ser None\r\n        if examenes_rendidos == 0 \u0026\u0026 (\r\n            promedio_notas.is_some()\r\n            || max_nota.is_some()\r\n            || min_nota.is_some()) {\r\n            return None;\r\n        }\r\n\r\n        Some(InformeAcademico { nombre, id, examenes_rendidos, promedio_notas, max_nota, min_nota })\r\n    }\r\n}\r\n\r\nimpl\u003c'a, 'e\u003e Estudiante\u003c'a, 'e\u003e {\r\n    /// ### new(nombre, id, notas) -\u003e Estudiante\r\n    /// Crea una nueva instancia de Estudiante\r\n    fn new(nombre: \u0026'a str, id: u32, notas: Vec\u003cExamen\u003c'e\u003e\u003e) -\u003e Estudiante\u003c'a, 'e\u003e {\r\n        Estudiante { nombre, id, notas }\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_promedio() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la mayor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La calificación promedio del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        let cant_notas = self.notas.len();\r\n        let mut suma_notas: u16 = 0;\r\n\r\n        for examen in \u0026self.notas {\r\n            suma_notas+= examen.nota as u16;\r\n        }\r\n\r\n        if cant_notas != 0 { return Some(suma_notas as f32 / cant_notas as f32) }\r\n        None\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_mas_alta() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la mayor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La mayor calificación del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| a.nota.total_cmp(\u0026b.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_mas_baja() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la menor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La menor calificación del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| b.nota.total_cmp(\u0026a.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    /// ### fn generar_informe() -\u003e Option\u003cInformeAcademico\u003e\r\n    /// Procesa los datos del estudiante y devuelve un informe acorde.\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(InformeAcademico)` - Informe académico del alumno\u003cbr\u003e\r\n    /// `None` - Incongruencias no permitieron fabricar el informe académico\r\n    fn generar_informe(\u0026self) -\u003e Option\u003cInformeAcademico\u003e {\r\n        let mut suma_total_notas: f32 = 0.0;\r\n        let mut min_nota: Option\u003c\u0026Examen\u003e = None;\r\n        let mut max_nota: Option\u003c\u0026Examen\u003e = None;\r\n\r\n        /*\r\n            Sería posible utilizar las funciones ya existentes de la struct Estudiante:\r\n                fn obtener_calificacion_promedio() -\u003e Option\u003cf32\u003e\r\n                fn obtener_calificacion_mas_alta() -\u003e Option\u003cf32\u003e\r\n                fn obtener_calificacion_mas_baja() -\u003e Option\u003cf32\u003e\r\n            Pero en cada una se realiza una consulta individual al vector de exámenes del estudiante,\r\n            por lo que estaría recorrieno la misma información 3 veces, lo cual es absolutamente innecesario\r\n            entonces me resulta una mucho mejor idea prescindir de todas estas funciones.\r\n         */\r\n\r\n        for examen in \u0026self.notas {\r\n            match min_nota {\r\n                Some(val) =\u003e if examen.nota \u003c val.nota { min_nota = Some(examen) }\r\n                None =\u003e min_nota = Some(examen)\r\n            }\r\n\r\n            match max_nota {\r\n                Some(val) =\u003e if examen.nota \u003e val.nota { max_nota = Some(examen) }\r\n                None =\u003e max_nota = Some(examen)\r\n            }\r\n\r\n            suma_total_notas+= examen.nota;\r\n        }\r\n\r\n        let promedio_notas: Option\u003cf32\u003e = match self.notas.len() {\r\n            0 =\u003e None,\r\n            cant_notas =\u003e Some(suma_total_notas / (cant_notas as f32))\r\n        };\r\n\r\n        // Sólo puede \"fallar\" (devolver None) si:\r\n        //      self.notas != 0 \u0026\u0026 (promedio_notas != Some(f32) || max_nota != Some(Examen) || min_nota != Some(Examen))\r\n        //   || self.notas == 0 \u0026\u0026 (promedio_notas == Some(f32) || max_nota == Some(Examen) || min_nota == Some(Examen))\r\n        // lo cual, creo, es imposible.\r\n        InformeAcademico::new(\r\n            self.nombre,\r\n            self.id,\r\n            self.notas.len() as u16,\r\n            promedio_notas,\r\n            max_nota,\r\n            min_nota\r\n        )\r\n    }\r\n}\r\n\r\nfn main() { }\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{Estudiante, Examen};\r\n\r\n    fn estudiante\u003c'a, 'e\u003e() -\u003e Estudiante\u003c'a, 'e\u003e {\r\n        let examen1 = Examen::new(\"SdL Rust\", 4.0);\r\n        let examen2 = Examen::new(\"AyED\", 5.0);\r\n        let examen3 = Examen::new(\"FOD\", 6.0);\r\n        let examen4 = Examen::new(\"Matematica 3\", 7.0);\r\n\r\n        assert!(examen1.is_some(), \"Examen1 debería brindar Some(Examen)\");\r\n        assert!(examen2.is_some(), \"Examen2 debería brindar Some(Examen)\");\r\n        assert!(examen3.is_some(), \"Examen3 debería brindar Some(Examen)\");\r\n        assert!(examen4.is_some(), \"Examen4 debería brindar Some(Examen)\");\r\n\r\n        Estudiante::new(\"jorgito\", 13548, vec![\r\n            examen1.unwrap(),\r\n            examen2.unwrap(),\r\n            examen3.unwrap(),\r\n            examen4.unwrap()])\r\n    }\r\n\r\n    #[test]\r\n    fn test_max_min_prom() {\r\n        let estudiante = estudiante();\r\n\r\n        assert_eq!(estudiante.obtener_calificacion_mas_alta(), Some(7.0));\r\n        assert_eq!(estudiante.obtener_calificacion_mas_baja(), Some(4.0));\r\n        assert_eq!(estudiante.obtener_calificacion_promedio(), Some(5.5));\r\n    }\r\n\r\n    #[test]\r\n    fn test_informe_academico_some() {\r\n        let estudiante = estudiante();\r\n        let informe = estudiante.generar_informe();\r\n\r\n        assert!(informe.is_some(), \"Informe debería brindar Some(InformeAcademico)\");\r\n\r\n        let informe = informe.unwrap();\r\n\r\n        let nombre_estudiante = informe.nombre;\r\n        let id_estudiante = informe.id;\r\n        let examenes_rendidos = informe.examenes_rendidos;\r\n\r\n        let min_nota = informe.min_nota;\r\n        let max_nota = informe.max_nota;\r\n        let promedio = informe.promedio_notas;\r\n\r\n        assert_eq!(nombre_estudiante, \"jorgito\".to_string(), \"El nombre se debe preservar\");\r\n        assert_eq!(id_estudiante, 13548, \"El nombre se debe preservar\");\r\n        assert_eq!(examenes_rendidos, 4, \"Se rindieron 4 exámenes\");\r\n\r\n        assert!(min_nota.is_some(), \"Debería existir nota mínima\");\r\n        assert!(max_nota.is_some(), \"Debería existir nota máxima\");\r\n        assert!(promedio.is_some(), \"Debería existir promedio\");\r\n\r\n        assert_eq!(min_nota.unwrap().nota, 4.0, \"La nota mínima debería ser 4.0\");\r\n        assert_eq!(max_nota.unwrap().nota, 7.0, \"La nota máxima debería ser 7.0\");\r\n        assert_eq!(promedio.unwrap(), 5.5, \"La nota promedio debería ser 5.5\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_informe_academico_none() {\r\n        let estudiante = Estudiante::new(\"jorgito\", 29, Vec::new());\r\n        let informe = estudiante.generar_informe();\r\n\r\n        assert!(informe.is_some(), \"Informe debería brindar Some(InformeAcademico)\");\r\n\r\n        let informe = informe.unwrap();\r\n\r\n        assert_eq!(informe.examenes_rendidos, 0, \"No deberían existir exámenes rendidos\");\r\n        assert_eq!(informe.max_nota, None, \"No debería existir nota mínima\");\r\n        assert_eq!(informe.min_nota, None, \"No debería existir nota máxima\");\r\n        assert_eq!(informe.promedio_notas, None, \"No debería existir nota promedio\");\r\n    }\r\n}","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej7","main.rs"],"content":"\r\n/*\r\n    7- Defina una estructura llamada ConcesionarioAuto donde se conoce\r\n            nombre,\r\n            dirección\r\n            y tiene una capacidad máxima para albergar X cantidad de autos.\r\n        De los autos se conocen los campos de\r\n            marca,\r\n            modelo,\r\n            año,\r\n            precio bruto\r\n            y color que pueden ser:\r\n                rojo,\r\n                verde,\r\n                azul,\r\n                amarillo,\r\n                blanco,\r\n                negro.\r\n        Para dichas estructuras implemente los siguientes métodos:\r\n        ❖ ConcesionarioAuto:\r\n            ➢ new: que pasando los parámetros correspondientes, crea un ConcesionarioAuto y lo retorna.\r\n            ➢ agregar_auto(auto): agrega un auto a la lista de autos que tiene\r\n                sin superar la máxima cantidad para albergarlos\r\n                y retorna true, en caso de que lo supere no lo agrega y retorna false.\r\n            ➢ eliminar_auto(auto): elimina un auto de la lista de autos.\r\n            ➢ buscar_auto(auto): busca un auto y si lo encuentra lo retorna.\r\n        ❖ Auto:\r\n            ➢ new: que pasando los parámetros correspondientes, crea un Auto y lo retorna.\r\n            ➢ calcular_precio: retorna el precio del auto aplicando los siguientes criterios:\r\n                ■ si es de color primario le aplica un recargo del 25%, sino le aplica un descuento del 10%.\r\n                ■ si la marca es BMW le aplica un recargo del 15%-\r\n                ■ si el año es menor a 2000 le aplica un descuento del 5%.\r\n */\r\n\r\nstruct ConcesionarioAuto {\r\n    nombre: String,\r\n    direccion: String,\r\n    autos: Vec\u003cAuto\u003e\r\n}\r\n\r\n#[derive(PartialEq)]\r\nstruct Auto {\r\n    marca: String,\r\n    modelo: String,\r\n    ano: u16,\r\n    precio: f32,\r\n    color: Color\r\n}\r\n\r\n#[derive(PartialEq)]\r\nenum Color {\r\n    Rojo, Verde, Azul, Amarillo, Blanco, Negro\r\n}\r\n\r\nimpl ConcesionarioAuto {\r\n    // ➢ new: que pasando los parámetros correspondientes, crea un ConcesionarioAuto y lo retorna.\r\n    fn new(nombre: String, direccion: String, autos: Vec\u003cAuto\u003e) -\u003e ConcesionarioAuto {\r\n        ConcesionarioAuto { nombre, direccion, autos }\r\n    }\r\n\r\n    // ➢ agregar_auto(auto): agrega un auto a la lista de autos que tiene\r\n    //     sin superar la máxima cantidad para albergarlos\r\n    //     y retorna true, en caso de que lo supere no lo agrega y retorna false.\r\n    fn agregar_auto(\u0026mut self, auto: Auto) -\u003e bool {\r\n        if self.autos.len() == self.autos.capacity() { return false }\r\n        self.autos.push(auto);\r\n        true\r\n    }\r\n\r\n    // ➢ eliminar_auto(auto): elimina un auto de la lista de autos.\r\n    fn eliminar_auto(\u0026mut self, auto: Auto) {\r\n        self.autos.retain(|a| *a != auto);\r\n    }\r\n\r\n    // ➢ buscar_auto(auto): busca un auto y si lo encuentra lo retorna.\r\n    fn buscar_auto(\u0026self, auto: Auto) -\u003e Option\u003cAuto\u003e {\r\n        if self.autos.contains(\u0026auto) {\r\n            return Some(auto)\r\n        }\r\n        None\r\n    }\r\n}\r\n\r\nimpl Auto {\r\n    // ➢ new: que pasando los parámetros correspondientes, crea un Auto y lo retorna.\r\n    fn new(marca: String, modelo: String, ano: u16, precio: f32, color: Color) -\u003e Auto {\r\n        Auto { marca, modelo, ano, precio, color }\r\n    }\r\n\r\n    // ➢ calcular_precio: retorna el precio del auto aplicando los siguientes criterios:\r\n    fn calcular_precio(\u0026self) -\u003e f32 {\r\n        let mut precio = self.precio;\r\n\r\n        // ■ si es de color primario le aplica un recargo del 25%, sino le aplica un descuento del 10%.\r\n        match self.color {\r\n            Color::Rojo | Color::Azul | Color::Amarillo =\u003e precio*= 1.25,\r\n            _ =\u003e precio/= 0.9\r\n        }\r\n\r\n        // ■ si la marca es BMW le aplica un recargo del 15%\r\n        if self.marca == \"BMW\" { precio*= 1.15 }\r\n\r\n        // ■ si el año es menor a 2000 le aplica un descuento del 5%.\r\n        if self.ano \u003c 2000 { precio*= 0.95 }\r\n\r\n        precio\r\n    }\r\n}\r\n\r\n\r\n\r\nfn main() {\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej8","main.rs"],"content":"\r\n/*\r\n    8- Defina la estructura Cancion con campos para\r\n        - título\r\n        - artista\r\n        - el género.\r\n    El género puede ser:\r\n        - rock\r\n        - pop\r\n        - rap\r\n        - jazz\r\n        - otros.\r\n    Luego modele una playlist.\r\n    La playlist está compuesta por una lista de canciones y un nombre\r\n    y se permiten hacer las siguientes acciones sobre ella:\r\n        ➔ agregar canción.\r\n        ➔ eliminar canción.\r\n        ➔ mover canción // mueve la canción a una determinada posición de la playlist.\r\n        ➔ buscar canción por nombre.\r\n        ➔ obtener las canciones de un determinado género.\r\n        ➔ obtener las canciones de un determinado artista.\r\n        ➔ modificar título de la playlist.\r\n        ➔ eliminar todas las canciones.\r\n */\r\nuse std::cmp::PartialEq;\r\n\r\n#[derive(PartialEq, Clone, Debug)]\r\nenum Genero {\r\n    Rock, Pop, Rap, Jazz, Otros\r\n}\r\n\r\n#[derive(PartialEq, Clone, Debug)]\r\nstruct Cancion {\r\n    titulo: String,\r\n    artista: String,\r\n    genero: Genero,\r\n}\r\n\r\nstruct Playlist {\r\n    nombre: String,\r\n    canciones: Vec\u003cCancion\u003e\r\n}\r\n\r\nimpl Cancion {\r\n    fn new(titulo: String, artista: String, genero: Genero) -\u003e Cancion {\r\n        Cancion { titulo, artista, genero }\r\n    }\r\n}\r\n\r\nimpl Playlist {\r\n\r\n    fn new(nombre: String) -\u003e Playlist {\r\n        Playlist { nombre, canciones: Vec::new() }\r\n    }\r\n\r\n    // ➔ agregar canción.\r\n    fn agregar_cancion(\u0026mut self, cancion: Cancion) {\r\n        self.canciones.push(cancion);\r\n    }\r\n\r\n    // ➔ eliminar canción.\r\n    fn eliminar_cancion(\u0026mut self, cancion: \u0026Cancion) {\r\n        self.canciones.retain_mut(|c| *c != *cancion);\r\n    }\r\n\r\n    // ➔ mover canción: mueve la canción a una determinada posición de la playlist.\r\n    fn mover_cancion(\u0026mut self, cancion: Cancion, posicion: usize) {\r\n        if posicion \u003e self.canciones.len()  { return; }\r\n        self.eliminar_cancion(\u0026cancion);\r\n        self.canciones.insert(posicion - 1,  cancion);\r\n    }\r\n\r\n    // ➔ buscar canción por nombre.\r\n    fn buscar_cancion(\u0026self, nombre_cancion: \u0026str) -\u003e Option\u003c\u0026Cancion\u003e {\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.titulo == nombre_cancion {\r\n                return Some(cancion)\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    // ➔ obtener las canciones de un determinado género.\r\n    fn listar_canciones_genero(\u0026self, genero: \u0026Genero) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n        let mut vec: Vec\u003c\u0026Cancion\u003e = Vec::new();\r\n\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.genero == *genero {\r\n                vec.push(cancion);\r\n            }\r\n        }\r\n\r\n        vec\r\n    }\r\n\r\n    // ➔ obtener las canciones de un determinado artista.\r\n    fn listar_canciones_artista(\u0026self, artista: \u0026str) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n        let mut vec: Vec\u003c\u0026Cancion\u003e = Vec::new();\r\n\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.artista == artista {\r\n                vec.push(cancion);\r\n            }\r\n        }\r\n\r\n        vec\r\n    }\r\n\r\n    // ➔ modificar título de la playlist.\r\n    fn modificar_titulo(\u0026mut self, titulo: String) {\r\n        self.nombre = titulo;\r\n    }\r\n\r\n    // ➔ eliminar todas las canciones.\r\n    fn clear(\u0026mut self) {\r\n        self.canciones.clear();\r\n    }\r\n\r\n}\r\n\r\nfn main() {\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::cmp::PartialEq;\r\n    use crate::{Cancion, Genero, Playlist};\r\n\r\n    impl PartialEq\u003cCancion\u003e for \u0026Cancion {\r\n        fn eq(\u0026self, cancion: \u0026Cancion) -\u003e bool {\r\n            cancion.titulo == self.titulo\r\n            \u0026\u0026 cancion.artista == self.artista\r\n            \u0026\u0026 cancion.genero == self.genero\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test() {\r\n        let mut mi_playlist = Playlist::new(\"platuka\".to_string());\r\n\r\n        let mi_cancion_1 = Cancion::new(\"Un siglo sin tí\".to_string(), \"Chayanne\".to_string(), Genero::Pop);\r\n        let mi_cancion_2 = Cancion::new(\"Mi abuela\".to_string(), \"Molotov\".to_string(), Genero::Rap);\r\n        let mi_cancion_3 = Cancion::new(\"Te odio y te quiero\".to_string(), \"Julio Jaramillo\".to_string(), Genero::Otros);\r\n        let mi_cancion_4 = Cancion::new(\"Fatalidad\".to_string(), \"Julio Jaramillo\".to_string(), Genero::Otros);\r\n\r\n        mi_playlist.agregar_cancion(mi_cancion_1.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_2.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_3.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_4.clone());\r\n\r\n        // test agregado\r\n        assert_eq!(mi_playlist.listar_canciones_genero(\u0026Genero::Otros).len(), 2, \"Deberían haber 2 canciones de género \\\"otros\\\"\");\r\n\r\n        // test mover\r\n        mi_playlist.mover_cancion(mi_cancion_1.clone(), 4);\r\n        assert_eq!(mi_playlist.canciones.get(3).unwrap(), mi_cancion_1, \"La canción no parece haberse movido...\");\r\n\r\n        // test buscar genero\r\n        assert_eq!(mi_playlist.listar_canciones_genero(\u0026Genero::Otros).len(), 2, \"Deberían haber 2 canciones en género Otros\");\r\n\r\n        // test clear\r\n        mi_playlist.clear();\r\n        assert_eq!(mi_playlist.canciones.len(), 0, \"La playlist debería estar vacía\");\r\n    }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej9","impls.rs"],"content":"/*\r\nDado todo lo mencionado anteriormente implemente los métodos para realizar las siguientes acciones:\r\n    ➔ crear una veterinaria.\r\n    ➔ agregar una nueva mascota a la cola de atención de la veterinaria.\r\n    ➔ agregar una nueva mascota a la cola de atención pero que sea la siguiente en atender porque tiene la máxima prioridad.\r\n    ➔ atender la próxima mascota de la cola.\r\n    ➔ eliminar una mascota específica de la cola de atención dado que se retira.\r\n    ➔ registrar una atención.\r\n    ➔ buscar una atención dado el nombre de la mascota, el nombre del dueño y el teléfono.\r\n    ➔ modificar el diagnóstico de una determinada atención.\r\n    ➔ modificar la fecha de la próxima visita de una determinada atención.\r\n    ➔ eliminar una determinada atención.\r\n */\r\nuse std::collections::VecDeque;\r\npub(crate) use crate::structs::{Atencion, Fecha, Mascota, Veterinaria};\r\n\r\nimpl Veterinaria {\r\n\r\n    // ➔ crear una veterinaria.\r\n    pub fn new(nombre: String, direccion: String, id: i32, cola: Option\u003cVecDeque\u003cMascota\u003e\u003e, atenciones: Option\u003cVec\u003cAtencion\u003e\u003e) -\u003e Veterinaria {\r\n        Veterinaria { nombre, direccion, id, cola: cola.unwrap_or_default(), atenciones: atenciones.unwrap_or_default() }\r\n    }\r\n\r\n    // ➔ agregar una nueva mascota a la cola de atención de la veterinaria.\r\n    pub fn agregar_mascota(\u0026mut self, mascota: Mascota) {\r\n        self.cola.push_back(mascota);\r\n    }\r\n\r\n    // ➔ agregar una nueva mascota a la cola de atención pero que sea la siguiente en atender porque tiene la máxima prioridad.\r\n    pub fn agregar_mascota_prioridad(\u0026mut self, mascota: Mascota) {\r\n        self.cola.push_front(mascota);\r\n    }\r\n\r\n    // ➔ atender la próxima mascota de la cola.\r\n    pub fn atender_proxima_mascota(\u0026mut self) -\u003e Option\u003cMascota\u003e {\r\n        self.cola.pop_front()\r\n    }\r\n\r\n    // ➔ eliminar una mascota específica de la cola de atención dado que se retira.\r\n    pub fn eliminar_mascota(\u0026mut self, mascota: Mascota) {\r\n        self.cola.retain(|m| *m != mascota);\r\n    }\r\n    \r\n    // ➔ registrar una atención.\r\n    pub fn registrar_atencion(\u0026mut self, atencion: Atencion) {\r\n        self.atenciones.push(atencion);\r\n    }\r\n\r\n    /// Searches for an Atencion by Mascota's name and Dueno's details.\r\n    ///\r\n    /// # Arguments\r\n    /// * `mascota_nombre` - The name of the Mascota.\r\n    /// * `dueno_nombre` - The name of the Dueno.\r\n    /// * `telefono` - The Dueno's phone number.\r\n    ///\r\n    /// # Returns\r\n    /// * `Some(\u0026Atencion)` - If an Atencion is found.\r\n    /// * `None` - If no match is found.\r\n    pub fn buscar_atencion(\r\n        \u0026self,\r\n        mascota_nombre: String,\r\n        dueno_nombre: String,\r\n        telefono: u64,\r\n    ) -\u003e Option\u003c\u0026Atencion\u003e {\r\n        self.atenciones.iter().find(|atencion| {\r\n            atencion.mascota.nombre == mascota_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.nombre == dueno_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.telefono == telefono\r\n        })\r\n    }\r\n\r\n    /// Searches for an Atencion by Mascota's name and Dueno's details.\r\n    ///\r\n    /// # Arguments\r\n    /// * `mascota_nombre` - The name of the Mascota.\r\n    /// * `dueno_nombre` - The name of the Dueno.\r\n    /// * `telefono` - The Dueno's phone number.\r\n    ///\r\n    /// # Returns\r\n    /// * `Some(\u0026mut Atencion)` - If an Atencion is found.\r\n    /// * `None` - If no match is found.\r\n    pub fn buscar_atencion_mut(\r\n        \u0026mut self,\r\n        mascota_nombre: String,\r\n        dueno_nombre: String,\r\n        telefono: u64,\r\n    ) -\u003e Option\u003c\u0026mut Atencion\u003e {\r\n        self.atenciones.iter_mut().find(|atencion| {\r\n            atencion.mascota.nombre == mascota_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.nombre == dueno_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.telefono == telefono\r\n        })\r\n    }\r\n    \r\n    /// Deletes an Atencion record from the Veterinaria records\r\n    ///\r\n    /// # Arguments\r\n    /// * `atencion` - A reference to the Atencion to delete\r\n    ///\r\n    /// # Returns\r\n    /// `Some(Atencion)` - The deleted Atencion\r\n    /// `None` - If no match is found\r\n    ///\r\n    /// # Notes\r\n    /// Requires `PartialEq` on Atencion for comparison\r\n    pub fn eliminar_atencion(\r\n        \u0026mut self,\r\n        atencion: \u0026Atencion\r\n    ) -\u003e Option\u003cAtencion\u003e {\r\n        if let Some(index) = self.atenciones.iter().position(|a| a == atencion) {\r\n            return Some(self.atenciones.remove(index));\r\n        }\r\n        None\r\n    }\r\n}\r\n\r\nimpl Atencion {\r\n\r\n    // ➔ modificar el diagnóstico de una determinada atención.\r\n    pub fn modificar_diagnostico_atencion(\u0026mut self, nuevo_diagnostico: String) {\r\n        self.diagnostico = nuevo_diagnostico;\r\n    }\r\n\r\n    // ➔ modificar la fecha de la próxima visita de una determinada atención.\r\n    pub fn modificar_fecha_atencion(\u0026mut self, nueva_fecha: Fecha) {\r\n        self.proxima_visita = nueva_fecha;\r\n    }\r\n    \r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::collections::VecDeque;\r\n    use crate::structs::{Animal, Atencion, Dueno, Fecha, Mascota, Veterinaria};\r\n\r\n    fn veterinaria_de_pepe() -\u003e Veterinaria {\r\n        // Crear dueños\r\n        let dueno1 = Dueno {\r\n            nombre: String::from(\"Juan Pérez\"),\r\n            direccion: String::from(\"Calle 123\"),\r\n            telefono: 1234567890,\r\n        };\r\n        let dueno2 = Dueno {\r\n            nombre: String::from(\"María Gómez\"),\r\n            direccion: String::from(\"Avenida 456\"),\r\n            telefono: 9876543210,\r\n        };\r\n        let dueno3 = Dueno {\r\n            nombre: String::from(\"Carlos López\"),\r\n            direccion: String::from(\"Carrera 789\"),\r\n            telefono: 5555555555,\r\n        };\r\n\r\n        // Crear mascotas para la cola\r\n        let mascota1 = Mascota {\r\n            nombre: String::from(\"Max\"),\r\n            edad: 3,\r\n            animal: Animal::Perro,\r\n            dueno: dueno1,\r\n        };\r\n        let mascota2 = Mascota {\r\n            nombre: String::from(\"Luna\"),\r\n            edad: 2,\r\n            animal: Animal::Gato,\r\n            dueno: dueno2,\r\n        };\r\n        let mascota3 = Mascota {\r\n            nombre: String::from(\"Tormenta\"),\r\n            edad: 5,\r\n            animal: Animal::Caballo,\r\n            dueno: dueno3,\r\n        };\r\n\r\n        // Crear fechas para atenciones\r\n        let fecha1 = Fecha { dia: 15, mes: 10, ano: 2023 };\r\n        let fecha2 = Fecha { dia: 20, mes: 10, ano: 2023 };\r\n        let fecha3 = Fecha { dia: 25, mes: 10, ano: 2023 };\r\n\r\n        // Crear atenciones\r\n        let atencion1 = Atencion {\r\n            mascota: mascota1.clone(),\r\n            diagnostico: String::from(\"Resfriado leve\"),\r\n            tratamiento: String::from(\"Antibióticos\"),\r\n            proxima_visita: fecha1,\r\n        };\r\n        let atencion2 = Atencion {\r\n            mascota: mascota2.clone(),\r\n            diagnostico: String::from(\"Infección ocular\"),\r\n            tratamiento: String::from(\"Gotas\"),\r\n            proxima_visita: fecha2,\r\n        };\r\n        let atencion3 = Atencion {\r\n            mascota: mascota3.clone(),\r\n            diagnostico: String::from(\"Cojeo\"),\r\n            tratamiento: String::from(\"Reposo\"),\r\n            proxima_visita: fecha3,\r\n        };\r\n\r\n        // Crear la veterinaria con cola y atenciones\r\n        Veterinaria {\r\n            nombre: String::from(\"Pepe's Pet Shop\"),\r\n            direccion: String::from(\"Calle Principal 100\"),\r\n            id: 1,\r\n            cola: VecDeque::from([mascota1, mascota2, mascota3]),\r\n            atenciones: vec![atencion1, atencion2, atencion3],\r\n        }\r\n    }\r\n\r\n    /*\r\n        let dueno1 = Dueno {\r\n            nombre: String::from(\"Juan Pérez\"),\r\n            direccion: String::from(\"Calle 123\"),\r\n            telefono: 1234567890,\r\n        };\r\n\r\n        let mascota1 = Mascota {\r\n            nombre: String::from(\"Max\"),\r\n            edad: 3,\r\n            animal: Animal::Perro,\r\n            dueno: dueno1,\r\n        };\r\n\r\n        let fecha1 = Fecha { dia: 15, mes: 10, ano: 2023 };\r\n\r\n        let atencion1 = Atencion {\r\n            mascota: mascota1.clone(),\r\n            diagnostico: String::from(\"Resfriado leve\"),\r\n            tratamiento: String::from(\"Antibióticos\"),\r\n            proxima_visita: fecha1,\r\n        };\r\n\r\n        Veterinaria {\r\n            nombre: String::from(\"Pepe's Pet Shop\"),\r\n            direccion: String::from(\"Calle Principal 100\"),\r\n            id: 1,\r\n            cola: VecDeque::from([mascota1, mascota2, mascota3]),\r\n            atenciones: vec![atencion1, atencion2, atencion3],\r\n        }\r\n     */\r\n\r\n    #[test]\r\n    fn test_atencion() {\r\n        let mut veterinaria = veterinaria_de_pepe();\r\n\r\n        // Verificar contenido\r\n        println!(\"Veterinaria: {}\", veterinaria.nombre);\r\n        println!(\"Cola: {:?}\", veterinaria.cola);\r\n        println!(\"Atenciones: {:?}\", veterinaria.atenciones);\r\n\r\n        // Buscar\r\n\r\n        let atencion = veterinaria.buscar_atencion_mut(\"Max\".to_string(), \"Juan Pérez\".to_string(), 1234567890);\r\n        assert!(atencion.is_some(), \"La atención no puede no existir\");\r\n        let atencion = atencion.unwrap();\r\n\r\n        atencion.modificar_diagnostico_atencion(\"jijodebu en los jijolines jijox\".to_string());\r\n\r\n        println!(\"Atenciones: {:?}\", veterinaria.atenciones);\r\n    }\r\n\r\n    #[test]\r\n    fn test_agregar_eliminar() {\r\n        let mut veterinaria = veterinaria_de_pepe();\r\n\r\n        let dueno1 = Dueno {\r\n            nombre: String::from(\"Enrique Ibañez\"),\r\n            direccion: String::from(\"Calle 437\"),\r\n            telefono: 1234567890,\r\n        };\r\n\r\n        let mascota1 = Mascota {\r\n            nombre: String::from(\"Rodolfo\"),\r\n            edad: 7,\r\n            animal: Animal::Caballo,\r\n            dueno: dueno1,\r\n        };\r\n\r\n        veterinaria.agregar_mascota(mascota1.clone());\r\n\r\n        println!(\"{:?}\", veterinaria.cola);\r\n        assert_eq!(veterinaria.cola.len(), 4, \"Deberían haber 4 mascotas en total.\");\r\n\r\n        veterinaria.agregar_mascota_prioridad(mascota1.clone());\r\n        let prox_mascota = veterinaria.atender_proxima_mascota();\r\n        assert!(prox_mascota.is_some(), \"Debe existir una próxima mascota\");\r\n        assert_eq!(prox_mascota.unwrap(), mascota1, \"La primer mascota en la fila debería ser la misma mascota que se agregó con prioridad\");\r\n\r\n        println!(\"{:?}\", veterinaria.eliminar_mascota(mascota1));\r\n\r\n        assert_eq!(veterinaria.cola.len(), 3, \"La lista de mascotas debería haber vuelto a su estado original (3 items).\");\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej9","main.rs"],"content":"/*\r\n    9.-Dada una cadena de veterinarias se desea implementar un sistema de atención de pacientes para cada veterinaria.\r\n        De la veterinaria se conoce \r\n            - nombre\r\n            - la dirección\r\n            - un id.\r\n        Para la atención de mascotas se requiere administrar una cola de atención.\r\n        De la mascota se conoce\r\n            - nombre\r\n            - edad\r\n            - tipo de animal (perro, gato, caballo, otros)\r\n            - su dueño.\r\n        Del dueño se conoce\r\n            - nombre\r\n            - direccion\r\n            - teléfono de contacto.\r\n        Luego de la atención se desea tener un registro de las atenciones realizadas guardando:\r\n            - datos de la mascota\r\n            - el diagnóstico final\r\n            - tratamiento\r\n            - fecha de la próxima visita si es que se requiere.\r\n        Dado todo lo mencionado anteriormente implemente los métodos para realizar las siguientes acciones:\r\n            ➔ crear una veterinaria.\r\n            ➔ agregar una nueva mascota a la cola de atención de la veterinaria.\r\n            ➔ agregar una nueva mascota a la cola de atención pero que sea la siguiente en atender porque tiene la máxima prioridad.\r\n            ➔ atender la próxima mascota de la cola.\r\n            ➔ eliminar una mascota específica de la cola de atención dado que se retira.\r\n            ➔ registrar una atención.\r\n            ➔ buscar una atención dado el nombre de la mascota, el nombre del dueño y el teléfono.\r\n            ➔ modificar el diagnóstico de una determinada atención.\r\n            ➔ modificar la fecha de la próxima visita de una determinada atención.\r\n            ➔ eliminar una determinada atención.\r\n        Nota: para la fecha utilice lo implementado en el punto 3.\r\n */\r\n\r\nmod structs;\r\nmod impls;\r\n\r\nfn main() {\r\n    \r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej9","structs.rs"],"content":"/*\r\n    9.-Dada una cadena de veterinarias se desea implementar un sistema de atención de pacientes para cada veterinaria.\r\n        De la veterinaria se conoce\r\n            - nombre\r\n            - la dirección\r\n            - un id.\r\n        Para la atención de mascotas se requiere administrar una cola de atención.\r\n        De la mascota se conoce\r\n            - nombre\r\n            - edad\r\n            - tipo de animal (perro, gato, caballo, otros)\r\n            - su dueño.\r\n        Del dueño se conoce\r\n            - nombre\r\n            - direccion\r\n            - teléfono de contacto.\r\n        Luego de la atención se desea tener un registro de las atenciones realizadas guardando:\r\n            - datos de la mascota\r\n            - el diagnóstico final\r\n            - tratamiento\r\n            - fecha de la próxima visita si es que se requiere.\r\n        Dado todo lo mencionado anteriormente implemente los métodos para realizar las siguientes acciones:\r\n            ➔ crear una veterinaria.\r\n            ➔ agregar una nueva mascota a la cola de atención de la veterinaria.\r\n            ➔ agregar una nueva mascota a la cola de atención pero que sea la siguiente en atender porque tiene la máxima prioridad.\r\n            ➔ atender la próxima mascota de la cola.\r\n            ➔ eliminar una mascota específica de la cola de atención dado que se retira.\r\n            ➔ registrar una atención.\r\n            ➔ buscar una atención dado el nombre de la mascota, el nombre del dueño y el teléfono.\r\n            ➔ modificar el diagnóstico de una determinada atención.\r\n            ➔ modificar la fecha de la próxima visita de una determinada atención.\r\n            ➔ eliminar una determinada atención.\r\n        Nota: para la fecha utilice lo implementado en el punto 3.\r\n */\r\nuse std::collections::VecDeque;\r\n\r\n// De la veterinaria se conoce\r\n// - nombre\r\n// - la dirección\r\n// - un id.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Veterinaria {\r\n    pub nombre: String,\r\n    pub direccion: String,\r\n    pub id: i32,\r\n    pub cola: VecDeque\u003cMascota\u003e,\r\n    pub atenciones: Vec\u003cAtencion\u003e\r\n}\r\n\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub enum Animal {\r\n    Perro, Gato, Caballo,\r\n    #[default] Otros\r\n}\r\n\r\n// De la mascota se conoce\r\n// - nombre\r\n// - edad\r\n// - tipo de animal (perro, gato, caballo, otros)\r\n// - su dueño.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Mascota {\r\n    pub nombre: String,\r\n    pub edad: u16,\r\n    pub animal: Animal,\r\n    pub dueno: Dueno,\r\n}\r\n\r\n// Del dueño se conoce\r\n// - nombre\r\n// - direccion\r\n// - teléfono de contacto.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Dueno {\r\n    pub nombre: String,\r\n    pub direccion: String,\r\n    pub telefono: u64,\r\n}\r\n\r\n// Luego de la atención se desea tener un registro de las atenciones realizadas guardando:\r\n// - datos de la mascota\r\n// - el diagnóstico final\r\n// - tratamiento\r\n// - fecha de la próxima visita si es que se requiere.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Atencion {\r\n    pub mascota: Mascota,\r\n    pub diagnostico: String,\r\n    pub tratamiento: String,\r\n    pub proxima_visita: Fecha,\r\n}\r\n\r\n// Nota: para la fecha utilice lo implementado en el punto 3.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Fecha {\r\n    pub dia: u8,\r\n    pub mes: u8,\r\n    pub ano: i64\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","main.rs"],"content":"\r\nfn main() {\r\n    println!(\"Hello, world!\");\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    \r\n    \r\n    \r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej1","main.rs"],"content":"/*\r\n    1- Escriba una función que reciba un vector de números enteros y retorna la cantidad de números primos.\r\n        Cree un trait para la determinación del número primo e impleméntelo según corresponda.\r\n        Utilice la función iter sobre el vector y aplique un closure para resolverlo.\r\n */\r\n\r\npub trait VerificadorPrimos {\r\n    fn contar_primos(\u0026self) -\u003e usize;\r\n}\r\n\r\npub trait VerificarPrimo {\r\n    fn es_primo(\u0026self) -\u003e bool;\r\n}\r\n\r\nimpl\u003cT\u003e VerificadorPrimos for Vec\u003cT\u003e where T: Copy + Into\u003ci128\u003e\r\n{\r\n    fn contar_primos(\u0026self) -\u003e usize {\r\n        self.iter().filter(\r\n            |\u0026\u0026n| { // closure\r\n                let n_i64: i128 = n.into();\r\n                n_i64.es_primo()\r\n            }\r\n        ).count()\r\n    }\r\n}\r\n\r\nimpl\u003cT\u003e VerificarPrimo for T where T: Copy + Into\u003ci128\u003e {\r\n    fn es_primo(\u0026self) -\u003e bool {\r\n        let num: i128 = (*self).into();\r\n        if num % 2 == 0 { return false }\r\n        \r\n        // no me interesa si es divisible por 1\r\n        // sé que no es divisible por 2\r\n        // por eso el primer número es 3\r\n        for n in 3..num.abs() {\r\n            if num % n == 0 { return false }\r\n        }\r\n\r\n        true\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let numero = 503213131.es_primo();\r\n    let vec_numero: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5];\r\n    \r\n    println!(\"{}\", numero.es_primo());\r\n    println!(\"{:?}\", vec_numero.contar_primos());\r\n    \r\n    let mut string_comun = String::from(\"asdasdas\");\r\n    let mi_str = \"esto es un \u0026str\";\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::VerificadorPrimos;\r\n\r\n    #[test]\r\n    fn test() {\r\n        let i_vec: Vec\u003ci32\u003e = vec![-5, -10, 5, 10];\r\n        let u_vec: Vec\u003cu32\u003e = vec![5, 10, 5, 10];\r\n        let p_vec: Vec\u003cu32\u003e = vec![0, 2, 4, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30];\r\n\r\n        assert_eq!(i_vec.contar_primos(), 2, \"Deberían haber 2 primos en el vector\");\r\n        assert_eq!(u_vec.contar_primos(), 2, \"Deberian haber 2 primos en el vector\");\r\n        assert_eq!(p_vec.contar_primos(), 0, \"No deberían haber primos en el vector\");\r\n    }\r\n\r\n}","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej2","main.rs"],"content":"\r\n/*\r\n\r\n2- Dado el siguiente struct:\r\n    struct Persona\u003c'a\u003e {\r\n        nombre:\u0026'a str,\r\n        apellido:\u0026'a str,\r\n        direccion:\u0026'a str,\r\n        ciudad:\u0026'a str,\r\n        salario:f64,\r\n        edad:u8,\r\n    }\r\na- Escriba una función que reciba un vector de personas y otro parámetro que indica un salario y retorna un listado de personas donde el salario es mayor al parámetro recibido.\r\nb- Escriba una función que reciba un vector de personas, edad y el nombre de una ciudad, y retorna las personas mayores al parámetro edad y que viven en el valor del parámetro ciudad.\r\nc- Escriba una función que reciba un vector de personas y un nombre de una ciudad y retorna true si todas las personas viven en la ciudad pasada por parámetro, false caso contrario.\r\nd- Escriba una función que reciba un vector de personas y un nombre de una ciudad y retorna true si al menos vive una persona en la ciudad pasada por parámetro,, false caso contrario.\r\ne- Escriba una función que reciba un arreglo de personas y una persona y retorna true si la persona existe en el arreglo, false caso contrarioUNLP. Facultad de Informática.\r\nSeminario de Lenguajes opción Rust Cursada 2023\r\nf -Escriba una función que reciba un arreglo de personas y retorna un arreglo con las edades de las personas.\r\ng - Escriba una función que reciba un arreglo de personas y retorna la persona con el menor salario y la persona con el mayor salario, en caso de que haya más de una persona en cada categoría desempatar por la edad más grande.\r\n\r\nNota: Implemente todos los métodos y traits que considere para resolver los ejercicios.\r\n    Todos los ejercicios deben resolverse con iterator y closure.\r\n\r\n */\r\n\r\n#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]\r\nstruct Persona\u003c'a\u003e {\r\n    nombre:\u0026'a str,\r\n    apellido:\u0026'a str,\r\n    direccion:\u0026'a str,\r\n    ciudad:\u0026'a str,\r\n    salario:f64,\r\n    edad:u8,\r\n}\r\n\r\ntrait VecPersona\u003c'a\u003e {\r\n    fn a_personas_salario_mayor(\u0026'a self, num: f64) -\u003e Option\u003cVec\u003c\u0026'a Persona\u003c'a\u003e\u003e\u003e;\r\n    fn b_personas_mayores_edad_en_ciudad(\u0026'a self, ciudad: \u0026'a str, edad: u8) -\u003e Vec\u003c\u0026'a Persona\u003c'a\u003e\u003e;\r\n    fn c_todos_viven_en_ciudad(\u0026'a self, ciudad: \u0026'a str) -\u003e bool;\r\n    fn d_alguien_vive_en_ciudad(\u0026'a self, ciudad: \u0026'a str) -\u003e bool;\r\n    fn e_persona_existe(\u0026'a self, persona: \u0026Persona) -\u003e bool;\r\n    fn f_listar_edades(\u0026'a self) -\u003e Vec\u003cu8\u003e;\r\n    fn g_mayor_menor_salario(\u0026'a self) -\u003e Option\u003c(\u0026'a Persona\u003c'a\u003e, \u0026'a Persona\u003c'a\u003e)\u003e;\r\n}\r\n\r\nimpl\u003c'a\u003e VecPersona\u003c'a\u003e for Vec\u003cPersona\u003c'a\u003e\u003e {\r\n    fn a_personas_salario_mayor(\u0026'a self, num: f64) -\u003e Option\u003cVec\u003c\u0026'a Persona\u003c'a\u003e\u003e\u003e {\r\n        if num \u003c 0.0 { return None } // num debe ser un número positivo\r\n\r\n        Some(\r\n            self.iter().filter(\r\n                |p|\r\n                    p.salario \u003e num\r\n            ).collect()\r\n        )\r\n    }\r\n\r\n    fn b_personas_mayores_edad_en_ciudad(\u0026'a self, ciudad: \u0026'a str, edad: u8) -\u003e Vec\u003c\u0026'a Persona\u003c'a\u003e\u003e {\r\n        self.iter().filter(|p|\r\n            p.ciudad == ciudad \u0026\u0026 p.edad \u003e edad\r\n        ).collect()\r\n    }\r\n\r\n    fn c_todos_viven_en_ciudad(\u0026'a self, ciudad: \u0026'a str) -\u003e bool {\r\n        self.iter().all(|p| p.ciudad == ciudad)\r\n    }\r\n\r\n    fn d_alguien_vive_en_ciudad(\u0026'a self, ciudad: \u0026'a str) -\u003e bool {\r\n        self.iter().any(|p| p.ciudad == ciudad)\r\n    }\r\n\r\n    fn e_persona_existe(\u0026'a self, persona: \u0026Persona) -\u003e bool {\r\n        self.iter().any(|p| p == persona)\r\n    }\r\n\r\n    fn f_listar_edades(\u0026'a self) -\u003e Vec\u003cu8\u003e {\r\n        self.iter().map(|p| {\r\n            p.edad\r\n        }).collect()\r\n    }\r\n\r\n    fn g_mayor_menor_salario(\u0026'a self) -\u003e Option\u003c(\u0026'a Persona\u003c'a\u003e, \u0026'a Persona\u003c'a\u003e)\u003e {\r\n        if self.len() \u003c 2 { return None } // no min/max can be calculated with 1 or 0 elements\r\n\r\n        let first_person = self.first();\r\n        let first_person = first_person?;\r\n\r\n        let mut res_index: (usize, usize) = (0, 0);\r\n        let mut res: (\u0026Persona, \u0026Persona) = (first_person, first_person);\r\n\r\n        self.iter().enumerate().for_each(\r\n            | (i, p) | {\r\n                if p.salario \u003c res.0.salario {\r\n                    res_index.0 = i;\r\n                    res.0 = p;\r\n                } else if p.salario \u003e res.1.salario {\r\n                    res_index.1 = i;\r\n                    res.1 = p;\r\n                } else if p.salario == res.0.salario \u0026\u0026 p.edad \u003e res.0.edad {\r\n                    res_index.0 = i;\r\n                    res.0 = p;\r\n                } else if p.salario == res.1.salario \u0026\u0026 p.edad \u003e res.1.edad {\r\n                    res_index.1 = i;\r\n                    res.0 = p;\r\n                }\r\n            }\r\n        );\r\n\r\n        Some(res)\r\n    }\r\n}\r\n\r\nfn main() { }","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","main.rs"],"content":"/*\r\n\r\n3 -La plataforma de streaming \"StreamingRust\" ofrece distintos tipos de suscripciones (Basic, Clasic, Super) a sus usuarios.\r\n    Cada suscripción tiene un costo mensual, una duración en meses y una fecha de inicio.\r\n    Además, los usuarios pueden pagar por sus suscripciones con distintos medios de pago\r\n        que son Efectivo, MercadoPago, Tarjeta de Crédito, Transferencia Bancaria, o Cripto.\r\n    Cada medio de pago tiene sus datos correspondientes a excepción de Efectivo.\r\n    Los usuarios solo pueden tener una suscripción activa a la vez.\r\n    Implemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear un usuario con una determinada suscripción y medio de pago.\r\n➢ Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic pasa a Clasic y si está en Clasic pasa a Super.\r\n➢ Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la suscripción es del tipo Basic al hacerlo se cancelará la suscripción.\r\n➢ Dado un usuario cancelar la suscripción.\r\n➢ Saber el medio de pago que es más utilizado por los usuarios sobre las suscripciones activas\r\n➢ Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones activas.\r\n➢ Saber cuál fue el medio de pago más utilizado.\r\n➢ Saber cuál fue la suscripción más contratada.\r\n\r\n*/\r\nmod structs;\r\n\r\nfn main() {}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","errores.rs"],"content":"use std::error::Error;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug)]\r\npub enum ErrorNewSuscripcion {\r\n    FechaInvalida, MedioDePagoInvalido\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ErrorMejorarSuscripcion {\r\n    SuscripcionMaxima, MedioDePagoInvalido, FechaInvalida\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ErrorDegradarSuscripcion {\r\n    SuscripcionMinima, MedioDePagoInvalido, FechaInvalida,\r\n}\r\n\r\nimpl fmt::Display for ErrorNewSuscripcion {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        match self {\r\n            ErrorNewSuscripcion::FechaInvalida =\u003e write!(f, \"La fecha ingresada es inválida\"),\r\n            ErrorNewSuscripcion::MedioDePagoInvalido =\u003e write!(f, \"El medio de pago ingresado es inválido\")\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for ErrorMejorarSuscripcion {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        match self {\r\n            ErrorMejorarSuscripcion::SuscripcionMaxima =\u003e write!(f, \"La suscripción no puede mejorarse porque ya es la más alta posible\"),\r\n            ErrorMejorarSuscripcion::MedioDePagoInvalido =\u003e write!(f, \"El medio de pago ingresado es inválido\"),\r\n            ErrorMejorarSuscripcion::FechaInvalida =\u003e write!(f, \"La fecha ingresada es inválida\")\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for ErrorDegradarSuscripcion {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        match self {\r\n            ErrorDegradarSuscripcion::SuscripcionMinima =\u003e write!(f, \"La suscripción no puede mejorarse porque ya es la más alta posible\"),\r\n            ErrorDegradarSuscripcion::MedioDePagoInvalido =\u003e write!(f, \"El medio de pago ingresado es inválido\"),\r\n            ErrorDegradarSuscripcion::FechaInvalida =\u003e write!(f, \"La fecha ingresada es inválida\")\r\n        }\r\n    }\r\n}\r\n\r\nimpl Error for ErrorNewSuscripcion { }\r\nimpl Error for ErrorMejorarSuscripcion { }\r\nimpl Error for ErrorDegradarSuscripcion { }","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","fecha.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct Fecha {\r\n    pub(crate) dia: u8,\r\n    pub(crate) mes: u8,\r\n    pub(crate) ano: i64\r\n}\r\n\r\nimpl Default for Fecha {\r\n    fn default() -\u003e Self {\r\n        Fecha { dia: 1, mes: 1, ano: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Fecha {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.dia == other.dia\r\n            \u0026\u0026 self.mes == other.mes\r\n            \u0026\u0026 self.ano == other.ano\r\n        { return Some(Equal) }\r\n\r\n        if self.ano \u003e other.ano { return Some(Greater) }\r\n        if self.mes \u003e other.mes { return Some(Greater) }\r\n        if self.dia \u003e other.dia { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cFecha\u003e {\r\n        let fecha = Fecha { dia, mes, ano };\r\n        if fecha.es_fecha_valida() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia == 0\r\n            || self.dia \u003e self.dias_mes_actual()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n\r\n    pub fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n\r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","mod.rs"],"content":"mod usuario;\r\nmod suscripcion;\r\nmod fecha;\r\nmod streamingrust;\r\nmod errores;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","streamingrust.rs"],"content":"/*\r\n\r\n3 -La plataforma de streaming \"StreamingRust\" ofrece distintos tipos de suscripciones (Basic, Clasic, Super) a sus usuarios.\r\n    Cada suscripción tiene un costo mensual, una duración en meses y una fecha de inicio.\r\n    Además, los usuarios pueden pagar por sus suscripciones con distintos medios de pago\r\n        que son Efectivo, MercadoPago, Tarjeta de Crédito, Transferencia Bancaria, o Cripto.\r\n    Cada medio de pago tiene sus datos correspondientes a excepción de Efectivo.\r\n    Los usuarios solo pueden tener una suscripción activa a la vez.\r\n    Implemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear un usuario con una determinada suscripción y medio de pago.\r\n➢ Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic pasa a Clasic y si está en Clasic pasa a Super.\r\n➢ Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la suscripción es del tipo Basic al hacerlo se cancelará la suscripción.\r\n➢ Dado un usuario cancelar la suscripción.\r\n➢ Saber el medio de pago que es más utilizado por los usuarios sobre las suscripciones activas\r\n➢ Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones activas.\r\n➢ Saber cuál fue el medio de pago más utilizado.\r\n➢ Saber cuál fue la suscripción más contratada.\r\n\r\n*/\r\nuse std::collections::{BTreeMap, HashMap, HashSet};\r\nuse crate::structs::suscripcion::TipoSuscripcion;\r\nuse crate::structs::usuario::Usuario;\r\n\r\n// contienen la información necesaria para identificar la compra\r\n//         mercadopago: cvu\r\n//         credito: cbu, cuotas\r\n//         debito: cbu\r\n//         transferencia: cbu\r\n//         cripto: public key/wallet address\r\n//         combinación: set de cualquiera de las anteriores\r\n#[derive(Debug, PartialEq, Eq, Hash, Clone)]\r\npub enum MedioDePago {\r\n    Efectivo,\r\n    MercadoPago(u128),\r\n    Credito(u128, u8),\r\n    Debito(u128),\r\n    Transferencia(u128),\r\n    Cripto([u8; 65])\r\n}\r\n\r\nimpl MedioDePago {\r\n    fn id(\u0026self) -\u003e u8 {\r\n        match self {\r\n            MedioDePago::Efectivo =\u003e 0,\r\n            MedioDePago::MercadoPago(_) =\u003e 1,\r\n            MedioDePago::Credito(_, _) =\u003e 2,\r\n            MedioDePago::Debito(_) =\u003e 3,\r\n            MedioDePago::Transferencia(_) =\u003e 4,\r\n            MedioDePago::Cripto(_) =\u003e 5,\r\n        }\r\n    }\r\n\r\n    fn from_id(id: u8) -\u003e MedioDePago {\r\n        match id {\r\n            0 | 6..=u8::MAX =\u003e MedioDePago::Efectivo,\r\n            1 =\u003e MedioDePago::MercadoPago(0),\r\n            2 =\u003e MedioDePago::Credito(0, 0),\r\n            3 =\u003e MedioDePago::Debito(0),\r\n            4 =\u003e MedioDePago::Transferencia(0),\r\n            5 =\u003e MedioDePago::Cripto([0; 65])\r\n        }\r\n    }\r\n}\r\n\r\nstruct StreamingRust\u003c'a\u003e {\r\n    usuarios: BTreeMap\u003cu64, Usuario\u003c'a\u003e\u003e\r\n}\r\n\r\nimpl\u003c'a\u003e StreamingRust\u003c'a\u003e {\r\n    \r\n    fn new(usuarios: Option\u003cBTreeMap\u003cu64, Usuario\u003e\u003e) -\u003e StreamingRust {\r\n        StreamingRust { usuarios: usuarios.unwrap_or_default() }\r\n    }\r\n\r\n    fn contabilizar_medios_de_pago(\u0026self, contabilizar_inactivos: bool) -\u003e HashMap\u003cMedioDePago, u32\u003e {\r\n        let mut contabilizador_mdp: HashMap\u003cMedioDePago, u32\u003e = HashMap::new();\r\n\r\n        self.usuarios.iter().for_each(|(_, usuario)| {\r\n            if contabilizar_inactivos || usuario.suscripcion.activo {\r\n                if let Some(medio) = \u0026usuario.suscripcion.medio_de_pago {\r\n                    *contabilizador_mdp.entry(medio.clone()).or_insert(0)+= 1;\r\n                }\r\n            }\r\n        });\r\n\r\n        contabilizador_mdp\r\n    }\r\n\r\n    fn contabilizar_tipos_de_suscripcion(\u0026self, contabilizar_inactivos: bool) -\u003e HashMap\u003cTipoSuscripcion, u32\u003e {\r\n        let mut contabilizador_ts: HashMap\u003cTipoSuscripcion, u32\u003e = HashMap::new();\r\n\r\n        self.usuarios.iter().for_each(|(_, usuario)| {\r\n            if contabilizar_inactivos || usuario.suscripcion.activo {\r\n                *contabilizador_ts.entry(usuario.suscripcion.tipo_suscripcion.clone()).or_insert(0)+= 1;\r\n            }\r\n        });\r\n\r\n        contabilizador_ts\r\n    }\r\n\r\n    // ➢ Saber el medio de pago que es más utilizado por los usuarios sobre las suscripciones activas\r\n    fn medio_de_pago_mas_utilizado_activos(\u0026self) -\u003e Option\u003cMedioDePago\u003e {\r\n        if self.usuarios.is_empty() { return None }\r\n\r\n        let contabilizador_mdp = self.contabilizar_medios_de_pago(false);\r\n\r\n        contabilizador_mdp.iter()\r\n            .max_by_key(|(_, c)| *c)\r\n            .map(|(mdp, _)| mdp.clone())\r\n    }\r\n\r\n    // ➢ Saber cuál fue el medio de pago más utilizado.\r\n    fn medio_de_pago_mas_utilizado_general(\u0026self) -\u003e Option\u003cMedioDePago\u003e {\r\n        if self.usuarios.is_empty() { return None }\r\n\r\n        let contabilizador_mdp = self.contabilizar_medios_de_pago(true);\r\n\r\n        contabilizador_mdp.iter()\r\n            .max_by_key(|(_, c)| *c)\r\n            .map(|(mdp, _)| mdp.clone())\r\n    }\r\n\r\n    // ➢ Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones activas.\r\n    fn suscripcion_activa_mas_contratada(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\r\n        if self.usuarios.is_empty() { return None }\r\n\r\n        let contabilizador_ts = self.contabilizar_tipos_de_suscripcion(false);\r\n\r\n        contabilizador_ts.iter()\r\n            .max_by_key(|(_, c)| *c)\r\n            .map(|(ts, _)| ts.clone())\r\n    }\r\n\r\n    // ➢ Saber cuál fue la suscripción más contratada.\r\n    fn suscripcion_mas_contratada_general(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\r\n        if self.usuarios.is_empty() { return None }\r\n\r\n        let contabilizador_ts = self.contabilizar_tipos_de_suscripcion(true);\r\n\r\n        contabilizador_ts.iter()\r\n            .max_by_key(|(_, c)| *c)\r\n            .map(|(ts, _)| ts.clone())\r\n    }\r\n}","traces":[{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","suscripcion.rs"],"content":"/*\r\n\r\n3 -La plataforma de streaming \"StreamingRust\" ofrece distintos tipos de suscripciones (Basic, Clasic, Super) a sus usuarios.\r\n    Cada suscripción tiene un costo mensual, una duración en meses y una fecha de inicio.\r\n    Además, los usuarios pueden pagar por sus suscripciones con distintos medios de pago\r\n        que son Efectivo, MercadoPago, Tarjeta de Crédito, Transferencia Bancaria, o Cripto.\r\n    Cada medio de pago tiene sus datos correspondientes a excepción de Efectivo.\r\n    Los usuarios solo pueden tener una suscripción activa a la vez.\r\n    Implemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear un usuario con una determinada suscripción y medio de pago.\r\n➢ Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic pasa a Clasic y si está en Clasic pasa a Super.\r\n➢ Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la suscripción es del tipo Basic al hacerlo se cancelará la suscripción.\r\n➢ Dado un usuario cancelar la suscripción.\r\n➢ Saber el medio de pago que es más utilizado por los usuarios sobre las suscripciones activas\r\n➢ Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones activas.\r\n➢ Saber cuál fue el medio de pago más utilizado.\r\n➢ Saber cuál fue la suscripción más contratada.\r\n\r\n*/\r\nuse std::cmp::PartialEq;\r\nuse crate::structs::errores::{ErrorDegradarSuscripcion, ErrorMejorarSuscripcion, ErrorNewSuscripcion};\r\nuse crate::structs::fecha::Fecha;\r\nuse crate::structs::streamingrust::MedioDePago;\r\n\r\n#[derive(Debug, PartialEq, Eq, Hash, Clone)]\r\npub enum TipoSuscripcion {\r\n    Basic, Classic, Super\r\n}\r\n\r\npub struct Suscripcion {\r\n    pub activo: bool,\r\n    pub tipo_suscripcion: TipoSuscripcion,\r\n    pub medio_de_pago: Option\u003cMedioDePago\u003e,\r\n    pub costo_mensual: f64,\r\n    pub fecha_inicio: Option\u003cFecha\u003e\r\n}\r\n\r\nimpl From\u003cErrorNewSuscripcion\u003e for ErrorMejorarSuscripcion {\r\n    fn from(value: ErrorNewSuscripcion) -\u003e Self {\r\n        match value {\r\n            ErrorNewSuscripcion::FechaInvalida =\u003e ErrorMejorarSuscripcion::FechaInvalida,\r\n            ErrorNewSuscripcion::MedioDePagoInvalido =\u003e ErrorMejorarSuscripcion::MedioDePagoInvalido\r\n        }\r\n    }\r\n}\r\n\r\nimpl From\u003cErrorNewSuscripcion\u003e for ErrorDegradarSuscripcion {\r\n    fn from(value: ErrorNewSuscripcion) -\u003e Self {\r\n        match value {\r\n            ErrorNewSuscripcion::FechaInvalida =\u003e ErrorDegradarSuscripcion::FechaInvalida,\r\n            ErrorNewSuscripcion::MedioDePagoInvalido =\u003e ErrorDegradarSuscripcion::MedioDePagoInvalido\r\n        }\r\n    }\r\n}\r\n\r\nimpl TipoSuscripcion {\r\n    fn costo_mensual(\u0026self) -\u003e f64 {\r\n        match self {\r\n            TipoSuscripcion::Basic =\u003e 1200.0,\r\n            TipoSuscripcion::Classic =\u003e 2200.0,\r\n            TipoSuscripcion::Super =\u003e 5800.0\r\n        }\r\n    }\r\n}\r\n\r\nimpl Suscripcion {\r\n\r\n    pub(crate) fn new(tipo_suscripcion: TipoSuscripcion, activo: bool, medio_de_pago: Option\u003cMedioDePago\u003e, fecha_inicio: Option\u003cFecha\u003e) -\u003e Result\u003cSelf, ErrorNewSuscripcion\u003e {\r\n        if activo {\r\n            if let None = medio_de_pago { return Err(ErrorNewSuscripcion::MedioDePagoInvalido) }\r\n            if let None = fecha_inicio { return Err(ErrorNewSuscripcion::FechaInvalida) }\r\n            if let Some(fecha) = \u0026fecha_inicio { if !fecha.es_fecha_valida() { return Err(ErrorNewSuscripcion::FechaInvalida) } }\r\n        }\r\n\r\n        // el costo mensual no debería darse como argumento de la función\r\n        // sino tener un costo predefinido para cada tipo de suscripción\r\n        let costo_mensual = tipo_suscripcion.costo_mensual();\r\n\r\n        Ok(Suscripcion { tipo_suscripcion, activo, medio_de_pago, costo_mensual, fecha_inicio })\r\n    }\r\n\r\n    pub fn mejorar(\u0026mut self) -\u003e Result\u003c\u0026TipoSuscripcion, ErrorMejorarSuscripcion\u003e {\r\n        let sig_suscripcion = match \u0026self.tipo_suscripcion {\r\n            TipoSuscripcion::Basic =\u003e TipoSuscripcion::Classic,\r\n            TipoSuscripcion::Classic =\u003e TipoSuscripcion::Super,\r\n            TipoSuscripcion::Super =\u003e return Err(ErrorMejorarSuscripcion::SuscripcionMaxima)\r\n        };\r\n\r\n        self.costo_mensual = sig_suscripcion.costo_mensual();\r\n        self.tipo_suscripcion = sig_suscripcion;\r\n\r\n        Ok(\u0026self.tipo_suscripcion)\r\n    }\r\n\r\n    // reduce el rango de la suscripcion\r\n    // opcionalmente puede cambiar el medio de pago y la fecha actual\r\n    pub fn degradar(\u0026mut self) -\u003e Result\u003c\u0026TipoSuscripcion, ErrorDegradarSuscripcion\u003e {\r\n        let prev_suscripcion = match \u0026self.tipo_suscripcion {\r\n            TipoSuscripcion::Basic =\u003e return Err(ErrorDegradarSuscripcion::SuscripcionMinima),\r\n            TipoSuscripcion::Classic =\u003e TipoSuscripcion::Basic,\r\n            TipoSuscripcion::Super =\u003e TipoSuscripcion::Classic\r\n        };\r\n\r\n        self.costo_mensual = prev_suscripcion.costo_mensual();\r\n        self.tipo_suscripcion = prev_suscripcion;\r\n\r\n        Ok(\u0026self.tipo_suscripcion)\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","usuario.rs"],"content":"/*\r\n\r\n3 -La plataforma de streaming \"StreamingRust\" ofrece distintos tipos de suscripciones (Basic, Clasic, Super) a sus usuarios.\r\n    Cada suscripción tiene un costo mensual, una duración en meses y una fecha de inicio.\r\n    Además, los usuarios pueden pagar por sus suscripciones con distintos medios de pago\r\n        que son Efectivo, MercadoPago, Tarjeta de Crédito, Transferencia Bancaria, o Cripto.\r\n    Cada medio de pago tiene sus datos correspondientes a excepción de Efectivo.\r\n    Los usuarios solo pueden tener una suscripción activa a la vez.\r\n    Implemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear un usuario con una determinada suscripción y medio de pago.\r\n➢ Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic pasa a Clasic y si está en Clasic pasa a Super.\r\n➢ Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la suscripción es del tipo Basic al hacerlo se cancelará la suscripción.\r\n➢ Dado un usuario cancelar la suscripción.\r\n➢ Saber el medio de pago que es más utilizado por los usuarios sobre las suscripciones activas\r\n➢ Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones activas.\r\n➢ Saber cuál fue el medio de pago más utilizado.\r\n➢ Saber cuál fue la suscripción más contratada.\r\n\r\n*/\r\nuse crate::structs::errores::{ErrorDegradarSuscripcion, ErrorMejorarSuscripcion};\r\nuse crate::structs::suscripcion::{Suscripcion, TipoSuscripcion};\r\n\r\npub struct Usuario\u003c'a\u003e {\r\n    pub id: u64,\r\n    pub email: \u0026'a str,\r\n    pub suscripcion: Suscripcion,\r\n}\r\n\r\nimpl\u003c'a\u003e Usuario\u003c'a\u003e {\r\n    // ➢ Crear un usuario con una determinada suscripción y medio de pago.\r\n    fn new(id: u64, email: \u0026'a str, suscripcion: Suscripcion) -\u003e Self {\r\n        Usuario { id, email, suscripcion }\r\n    }\r\n\r\n    // ➢ Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic pasa a Clasic y si está en Clasic pasa a Super.\r\n    fn mejorar_suscripcion(\u0026mut self) -\u003e Result\u003c\u0026TipoSuscripcion, ErrorMejorarSuscripcion\u003e {\r\n        self.suscripcion.mejorar()\r\n    }\r\n\r\n    // ➢ Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la suscripción es del tipo Basic al hacerlo se cancelará la suscripción.\r\n    fn degradar_suscripcion(\u0026mut self) -\u003e Result\u003c\u0026TipoSuscripcion, ErrorDegradarSuscripcion\u003e {\r\n        self.suscripcion.degradar()\r\n    }\r\n\r\n    // ➢ Dado un usuario cancelar la suscripción.\r\n    fn cancelar_suscripcion(\u0026mut self) -\u003e bool {\r\n        let estaba_activa = self.suscripcion.activo;\r\n        self.suscripcion.activo = false;\r\n        estaba_activa\r\n    }\r\n\r\n}","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","main.rs"],"content":"/*\r\n\r\n4 - Se requiere implementar un sistema de ventas de productos.\r\n    De cada producto se conoce\r\n        el nombre,\r\n        una categoría\r\n        y un precio base,\r\n        y algunos productos pueden tener descuentos aplicables dependiendo de la categoría.\r\n    Además, se debe registrar al vendedor que realizó la venta y al cliente.\r\n    De ellos se conoce\r\n        nombre,\r\n        apellido,\r\n        dirección,\r\n        dni\r\n    y del vendedor\r\n        nro de legajo,\r\n        antigüedad\r\n        y salario.\r\n    Los clientes pueden tener un beneficio de descuento si tienen suscripción al newsletter,\r\n    de ser así se tiene el correo electrónico del mismo.\r\n\r\nEl sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\nLos medios de pago aceptados son:\r\n    tarjeta de crédito,\r\n    tarjeta de débito,\r\n    transferencia bancaria\r\n    y efectivo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n\r\n➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n        donde debería aplicarse un descuento.\r\n    Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n➢ Para llevar un control de ventas realizadas se debe implementar un reporte que permita visualizar las ventas totales\r\n    por categoría de producto y otro por vendedor.\r\n\r\n */\r\nmod structs;\r\n\r\nfn main() {\r\n    let asd = u32::MAX;\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","comercio.rs"],"content":"/*\r\n\r\n4 - Se requiere implementar un sistema de ventas de productos.\r\n    De cada producto se conoce\r\n        el nombre,\r\n        una categoría\r\n        y un precio base,\r\n        y algunos productos pueden tener descuentos aplicables dependiendo de la categoría.\r\n    Además, se debe registrar al vendedor que realizó la venta y al cliente.\r\n    De ellos se conoce\r\n        nombre,\r\n        apellido,\r\n        dirección,\r\n        dni\r\n    y del vendedor\r\n        nro de legajo,\r\n        antigüedad\r\n        y salario.\r\n    Los clientes pueden tener un beneficio de descuento si tienen suscripción al newsletter,\r\n    de ser así se tiene el correo electrónico del mismo.\r\n\r\nEl sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\nLos medios de pago aceptados son:\r\n    tarjeta de crédito,\r\n    tarjeta de débito,\r\n    transferencia bancaria\r\n    y efectivo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n\r\n➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n        donde debería aplicarse un descuento.\r\n    Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n➢ Para llevar un control de ventas realizadas se debe implementar un reporte que permita visualizar las ventas totales\r\n    por categoría de producto y otro por vendedor.\r\n\r\n */\r\n\r\nuse std::collections::HashMap;\r\nuse crate::structs::producto::CategoriaProducto;\r\nuse crate::structs::vendedor_cliente::Vendedor;\r\nuse crate::structs::venta::Venta;\r\n\r\nstruct Comercio\u003c'a\u003e {\r\n    vendedores: HashMap\u003cu16, Vendedor\u003e,\r\n    descuentos: HashMap\u003cCategoriaProducto, f32\u003e,\r\n    ventas: Vec\u003cVenta\u003c'a\u003e\u003e\r\n}\r\n\r\nstruct ReporteTotal {\r\n    reporte_categorias: HashMap\u003cCategoriaProducto, u16\u003e,\r\n    reporte_vendedores: HashMap\u003cu16, u16\u003e // \u003clegajo, ventas\u003e\r\n}\r\n\r\nimpl\u003c'a\u003e Comercio\u003c'a\u003e {\r\n\r\n    // ➢ Para llevar un control de ventas realizadas se debe implementar\r\n    //      un reporte que permita visualizar las ventas totales por categoría de producto y otro por vendedor.\r\n    \r\n    fn generar_reporte_total(\u0026self) -\u003e ReporteTotal {\r\n        let mut reporte_categorias: HashMap\u003cCategoriaProducto, u16\u003e = Default::default();\r\n        let mut reporte_vendedores: HashMap\u003cu16, u16\u003e = Default::default();\r\n        \r\n        for venta in \u0026self.ventas {\r\n            for (producto, cant) in \u0026venta.productos {\r\n                *reporte_categorias.entry(producto.categoria).or_insert(0)+= cant;\r\n                *reporte_vendedores.entry(venta.vendedor.legajo).or_insert(0)+= cant;\r\n            }\r\n        }\r\n        \r\n        ReporteTotal {\r\n            reporte_categorias,\r\n            reporte_vendedores\r\n        }\r\n    }\r\n    \r\n}","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","fecha.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct Fecha {\r\n    pub(crate) dia: u8,\r\n    pub(crate) mes: u8,\r\n    pub(crate) ano: i64\r\n}\r\n\r\nimpl Default for Fecha {\r\n    fn default() -\u003e Self {\r\n        Fecha { dia: 1, mes: 1, ano: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Fecha {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.dia == other.dia\r\n            \u0026\u0026 self.mes == other.mes\r\n            \u0026\u0026 self.ano == other.ano\r\n        { return Some(Equal) }\r\n\r\n        if self.ano \u003e other.ano { return Some(Greater) }\r\n        if self.mes \u003e other.mes { return Some(Greater) }\r\n        if self.dia \u003e other.dia { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cFecha\u003e {\r\n        let fecha = Fecha { dia, mes, ano };\r\n        if fecha.es_fecha_valida() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia == 0\r\n            || self.dia \u003e self.dias_mes_actual()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n\r\n    pub fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n\r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","mod.rs"],"content":"mod fecha;\r\nmod producto;\r\nmod vendedor_cliente;\r\nmod venta;\r\nmod comercio;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","producto.rs"],"content":"/*\r\n\r\n4 - Se requiere implementar un sistema de ventas de productos.\r\n    De cada producto se conoce\r\n        el nombre,\r\n        una categoría\r\n        y un precio base,\r\n        y algunos productos pueden tener descuentos aplicables dependiendo de la categoría.\r\n    Además, se debe registrar al vendedor que realizó la venta y al cliente.\r\n    De ellos se conoce\r\n        nombre,\r\n        apellido,\r\n        dirección,\r\n        dni\r\n    y del vendedor\r\n        nro de legajo,\r\n        antigüedad\r\n        y salario.\r\n    Los clientes pueden tener un beneficio de descuento si tienen suscripción al newsletter,\r\n    de ser así se tiene el correo electrónico del mismo.\r\n\r\nEl sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\nLos medios de pago aceptados son:\r\n    tarjeta de crédito,\r\n    tarjeta de débito,\r\n    transferencia bancaria\r\n    y efectivo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n\r\n➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n        donde debería aplicarse un descuento.\r\n    Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n➢ Para llevar un control de ventas realizadas se debe implementar un reporte que permita visualizar las ventas totales\r\n    por categoría de producto y otro por vendedor.\r\n    \r\n */\r\n\r\n#[derive(Hash, Copy, Clone, PartialEq, Eq)]\r\npub enum CategoriaProducto {\r\n    Cosmetico, Tecnologia, HomeDeco, Almacen, Ferreteria, Drogueria, Textil\r\n}\r\n\r\npub struct Producto\u003c'a\u003e {\r\n    pub nombre: \u0026'a str,\r\n    pub apellido: \u0026'a str,\r\n    pub categoria: CategoriaProducto,\r\n    pub precio: f32,\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","vendedor_cliente.rs"],"content":"/*\r\n\r\n4 - Se requiere implementar un sistema de ventas de productos.\r\n    De cada producto se conoce\r\n        el nombre,\r\n        una categoría\r\n        y un precio base,\r\n        y algunos productos pueden tener descuentos aplicables dependiendo de la categoría.\r\n    Además, se debe registrar al vendedor que realizó la venta y al cliente.\r\n    De ellos se conoce\r\n        nombre,\r\n        apellido,\r\n        dirección,\r\n        dni\r\n    y del vendedor\r\n        nro de legajo,\r\n        antigüedad\r\n        y salario.\r\n    Los clientes pueden tener un beneficio de descuento si tienen suscripción al newsletter,\r\n    de ser así se tiene el correo electrónico del mismo.\r\n\r\nEl sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\nLos medios de pago aceptados son:\r\n    tarjeta de crédito,\r\n    tarjeta de débito,\r\n    transferencia bancaria\r\n    y efectivo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n\r\n➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n        donde debería aplicarse un descuento.\r\n    Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n➢ Para llevar un control de ventas realizadas se debe implementar un reporte que permita visualizar las ventas totales\r\n    por categoría de producto y otro por vendedor.\r\n\r\n */\r\n\r\n//     y del vendedor\r\n//         nro de legajo,\r\n//         antigüedad\r\n//         y salario.\r\npub struct Vendedor {\r\n    pub legajo: u16,\r\n    pub antiguedad_anos: u8,\r\n    pub salario: f64,\r\n}\r\n\r\n//     De ellos se conoce\r\n//         nombre,\r\n//         apellido,\r\n//         dirección,\r\n//         dni\r\npub struct Cliente\u003c'a\u003e {\r\n    pub nombre: \u0026'a str,\r\n    pub apellido: \u0026'a str,\r\n    pub direccion: \u0026'a str,\r\n    pub dni: u32 // u32::MAX = 4.xxx.xxx.xxx\r\n}\r\n\r\nimpl Vendedor {\r\n    fn new(legajo: u16, antiguedad_anos: u8, salario: f64) -\u003e Option\u003cVendedor\u003e {\r\n        if salario \u003c 0.0 { return None }\r\n        \r\n        Some(Vendedor {\r\n            legajo, antiguedad_anos, salario\r\n        })\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e Cliente\u003c'a\u003e {\r\n    fn new(nombre: \u0026'a str, apellido: \u0026'a str, direccion: \u0026'a str, dni: u32) -\u003e Cliente\u003c'a\u003e {\r\n        Cliente {\r\n            nombre, apellido, direccion, dni\r\n        }\r\n    }\r\n}","traces":[{"line":78,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","venta.rs"],"content":"/*\r\n\r\n4 - Se requiere implementar un sistema de ventas de productos.\r\n    De cada producto se conoce\r\n        el nombre,\r\n        una categoría\r\n        y un precio base,\r\n        y algunos productos pueden tener descuentos aplicables dependiendo de la categoría.\r\n    Además, se debe registrar al vendedor que realizó la venta y al cliente.\r\n    De ellos se conoce\r\n        nombre,\r\n        apellido,\r\n        dirección,\r\n        dni\r\n    y del vendedor\r\n        nro de legajo,\r\n        antigüedad\r\n        y salario.\r\n    Los clientes pueden tener un beneficio de descuento si tienen suscripción al newsletter,\r\n    de ser así se tiene el correo electrónico del mismo.\r\n\r\nEl sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\nLos medios de pago aceptados son:\r\n    tarjeta de crédito,\r\n    tarjeta de débito,\r\n    transferencia bancaria\r\n    y efectivo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n\r\n➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n        donde debería aplicarse un descuento.\r\n    Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n➢ Para llevar un control de ventas realizadas se debe implementar un reporte que permita visualizar las ventas totales\r\n    por categoría de producto y otro por vendedor.\r\n\r\n */\r\n\r\nuse std::collections::HashMap;\r\nuse crate::structs::fecha::Fecha;\r\nuse crate::structs::producto::{CategoriaProducto, Producto};\r\nuse crate::structs::vendedor_cliente::{Cliente, Vendedor};\r\n\r\nconst DESCUENTO_SUSCRIPCION_NEWSLETTER: f32 = 5.0;\r\n\r\npub enum MedioDePago {\r\n    Credito, Debito, Transferencia, Efectivo\r\n}\r\n\r\n// El sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\n// Los medios de pago aceptados son:\r\n//     tarjeta de crédito,\r\n//     tarjeta de débito,\r\n//     transferencia bancaria\r\n//     y efectivo.\r\n\r\npub struct Venta\u003c'a\u003e {\r\n    pub fecha: Fecha,\r\n    pub cliente: \u0026'a Cliente\u003c'a\u003e,\r\n    pub vendedor: \u0026'a Vendedor,\r\n    pub medio_de_pago: MedioDePago,\r\n    pub productos: HashMap\u003cProducto\u003c'a\u003e, u16\u003e,\r\n}\r\n\r\nimpl\u003c'a\u003e Venta\u003c'a\u003e {\r\n\r\n    // ➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n    fn new(fecha: Fecha, cliente: \u0026'a Cliente, vendedor: \u0026'a Vendedor, medio_de_pago: MedioDePago, productos: HashMap\u003cProducto\u003c'a\u003e, u16\u003e) -\u003e Option\u003cVenta\u003c'a\u003e\u003e {\r\n        if !fecha.es_fecha_valida() { return None }\r\n\r\n        Some(Venta {\r\n            fecha, cliente, vendedor, medio_de_pago, productos\r\n        })\r\n    }\r\n\r\n    // ➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    //     Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n    //         donde debería aplicarse un descuento.\r\n    //     Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    //     Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    //     Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n    fn precio_final(\u0026self, descuentos_porc: \u0026HashMap\u003cCategoriaProducto, f32\u003e, suscrito_newsletter: bool) -\u003e Option\u003cf32\u003e {\r\n        for val in descuentos_porc.values() {\r\n            if *val \u003c 0.0 || *val \u003e 100.0 { return None }\r\n        }\r\n\r\n        let mut precio_final = 0.0;\r\n        // calcular precios y sumarlos\r\n        for (producto, cant) in \u0026self.productos {\r\n            if let Some(descuento) = descuentos_porc.get(\u0026producto.categoria) {\r\n                precio_final+= producto.precio * (1.0 - *descuento/100.0) * (*cant as f32)\r\n            } else {\r\n                precio_final+= producto.precio * (*cant as f32)\r\n            }\r\n        }\r\n\r\n        if suscrito_newsletter { precio_final*= 1.0 - DESCUENTO_SUSCRIPCION_NEWSLETTER/100.0 }\r\n\r\n        Some(precio_final)\r\n    }\r\n}","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","main.rs"],"content":"/*\r\n\r\n5- La empresa XYZ es una plataforma de intercambio de criptoactivos\r\n    que permite a los usuarios comprar y vender distintas criptomonedas.\r\n\r\n    La plataforma permite el registro de usuarios y la gestión de sus balances\r\n        en distintas criptomonedas y en dinero fíat.\r\n    De los usuarios se conoce:\r\n        nombre, apellido, email, dni, y si está validada su identidad o no.\r\n\r\n    Cada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\n    De las criptomonedas se conoce:\r\n        nombre, prefijo y un listado de blockchains donde se pueden enviar o recibir.\r\n    De cada blockchain se conoce el nombre, prefijo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios\r\n    para resolver las siguientes acciones relacionadas al usuario:\r\n\r\n➢ Ingresar dinero: se recibe un monto en fiat de un usuario\r\n    y se acredita al balance de fiat de dicho usuario. Además se crea una transacción del hecho donde los datos que se guardan son:fecha, tipo(ingreso de dinero), monto, usuario.\r\n\r\n➢ Comprar determinada criptomoneda: dado un monto de fiat se compra una cantidad de determinada criptomoneda,\r\n    tenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual de la criptomoneda para acreditar la correspondiente proporción en el balance de la cripto y desacreditar en el balance de fiat. Luego de ello se registra la transacción con los siguientes datos: fecha, usuario, criptomoneda, tipo: compra de cripto, monto de cripto y cotización.\r\n\r\n➢ Vender determinada criptomoneda: dado un monto de cripto se vende por fiat,\r\n    tenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual\r\n    de la criptomoneda para acreditar la correspondiente proporción en el balance de fiat\r\n    y desacreditar en el balance de la criptomoneda.\r\n        Luego de ello se registra la transacción con los siguientes datos:\r\n            fecha, usuario, criptomoneda, tipo: venta de cripto, monto de cripto y cotización.\r\n\r\n➢ Retirar criptomoneda a blockchain: dado un monto de una cripto y una blockchain\r\n    se le descuenta del balance de dicha cripto al usuario el monto,\r\n    la blockchain devuelve un hash que representa una transacción en ella\r\n    (esto hágalo retornando el nombre de la blockchain + un número random).\r\n    Luego se genera una transacción con los siguientes datos:\r\n        fecha, usuario, tipo: retiro cripto, blockchain, hash, cripto, monto, cotización.\r\n\r\n➢ Recibir criptomoneda de blockchain: dado un monto de una cripto y una blockchain se le acredita\r\n    al balancede dicha cripto al usuario el monto. Luego se genera una transacción con los siguientes datos:\r\n        fecha, usuario, tipo: recepción cripto, blockchain, cripto, monto, cotización.\r\n\r\n➢ Retirar fiat por determinado medio: dado un monto de fiat se le descuenta dicho monto del balance\r\n    al usuario y se genera una transacción con la siguiente información:\r\n        fecha, usuario, tipo: retiro fiat, monto y medio (puede ser MercadoPago o Transferencia Bancaria)\r\nN\r\n    ota:: Tanto para comprar. vender, retirar el usuario debe estar validado.\r\n        Se debe validar siempre que haya balance suficiente para realizar la operación\r\n        en los casos de compra, venta, retiro.\r\n\r\n\r\n    Además la empresa desea saber lo siguiente en base a sus operaciones:\r\n\r\n➢ Saber cual es la criptomoneda que más cantidad de ventas tiene\r\n➢ Saber cual es la criptomoneda que más cantidad de compras tiene\r\n➢ Saber cual es la criptomoneda que más volumen de ventas tiene\r\n➢ Saber cual es la criptomoneda que más volumen de compras tiene\r\n\r\n */\r\nextern crate core;\r\n\r\nmod structs;\r\n\r\nfn main() {}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","structs","date.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Clone, PartialEq, Debug, Copy, Hash)]\r\npub struct Date {\r\n    pub(crate) day: u8,\r\n    pub(crate) month: u8,\r\n    pub(crate) year: i64\r\n}\r\n\r\nimpl Default for Date {\r\n    fn default() -\u003e Self {\r\n        Date { day: 1, month: 1, year: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Date {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.day == other.day\r\n            \u0026\u0026 self.month == other.month\r\n            \u0026\u0026 self.year == other.year\r\n        { return Some(Equal) }\r\n\r\n        if self.year \u003e other.year { return Some(Greater) }\r\n        if self.month \u003e other.month { return Some(Greater) }\r\n        if self.day \u003e other.day { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Date {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.is_date_valid() {\r\n            write!(f, \"{} de {} del {}\", self.day, NOMBRE_MESES[self.month as usize - 1], self.year)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.day, self.month, self.year)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Date {\r\n    // El año podría ser negativo, indicando época antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cDate\u003e {\r\n        let fecha = Date { day: dia, month: mes, year: ano };\r\n        if fecha.is_date_valid() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn is_date_valid(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.month) { return false }\r\n\r\n        // check días del mes\r\n        if self.day == 0\r\n            || self.day \u003e self.current_month_days()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn is_leap_year(\u0026self) -\u003e bool {\r\n        self.year % 4 == 0\r\n    }\r\n\r\n    pub fn add_days(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.current_month_days();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.day + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.day = 1;\r\n                self.month += 1;\r\n\r\n                if self.month \u003e 12 {\r\n                    self.month = 1;\r\n                    self.year += 1;\r\n                }\r\n            } else {\r\n                self.day += dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn subtract_days(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.day as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.day as u32;\r\n                self.month -= 1;\r\n\r\n                if self.month \u003c 1 {\r\n                    self.month = 12;\r\n                    self.year -= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.day = self.current_month_days();\r\n            } else {\r\n                self.day -= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn current_month_days(\u0026self) -\u003e u8 {\r\n        match self.month {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.is_leap_year() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","structs","mod.rs"],"content":"pub mod xyz;\r\npub mod user;\r\npub mod date;\r\npub mod monetary_structs;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","structs","monetary_structs.rs"],"content":"//     Cada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\n//     De las criptomonedas se conoce:\r\n//         nombre, prefijo y un listado de blockchains donde se pueden enviar o recibir.\r\n//     De cada blockchain se conoce el nombre, prefijo.\r\n\r\nuse core::fmt;\r\nuse std::fmt::{Formatter};\r\nuse error_proc_macro::Error;\r\nuse crate::structs::date::Date;\r\n\r\npub struct BlockchainTransactionHash(String);\r\nimpl\u003c'a\u003e BlockchainTransactionHash {\r\n    fn new(prefix: \u0026'a str) -\u003e BlockchainTransactionHash {\r\n        BlockchainTransactionHash(format!(\"{}-{}\", prefix, rand::random::\u003cu32\u003e()))\r\n    }\r\n}\r\n\r\npub struct BlockchainTransaction\u003c'a\u003e {\r\n    pub data: CommonTransactionData,\r\n    pub blockchain: \u0026'a str,\r\n    pub hash: BlockchainTransactionHash,\r\n    pub crypto: \u0026'a str,\r\n    pub quote: Quote\r\n}\r\n\r\nimpl\u003c'a\u003e BlockchainTransaction\u003c'a\u003e {\r\n    pub fn new(data: CommonTransactionData, transaction_type: TransactionType, blockchain: \u0026'a str, hash: Option\u003cBlockchainTransactionHash\u003e, crypto: \u0026'a str, quote: Quote) -\u003e Result\u003cSelf, ErrorNewTransaction\u003c'a\u003e\u003e {\r\n        // invalid date\r\n        if !data.date.is_date_valid() { return Err(ErrorNewTransaction::InvalidDate) }\r\n\r\n        // invalid amount\r\n        if data.amount \u003c 0.0 { return Err(ErrorNewTransaction::InvalidInputAmount { amount: data.amount }) }\r\n\r\n        // invalid transaction type\r\n        if transaction_type != TransactionType::BlockchainWithdrawal\r\n        \u0026\u0026 transaction_type != TransactionType::BlockchainDeposit\r\n            { return Err(ErrorNewTransaction::InvalidTransactionType { transaction_type }) }\r\n\r\n        // unwrap or create\r\n        let hash = if let Some(val) = hash { val }\r\n                                         else { BlockchainTransactionHash::new(blockchain) };\r\n\r\n        Ok(Self {\r\n            data,\r\n            blockchain,\r\n            hash,\r\n            crypto,\r\n            quote\r\n        })\r\n    }\r\n}\r\n\r\npub struct Blockchain\u003c'a\u003e {\r\n    pub name: \u0026'a str,\r\n    pub prefix: \u0026'a str,\r\n    pub supported_cryptos: Vec\u003c\u0026'a str\u003e,\r\n}\r\n\r\nimpl\u003c'a\u003e Blockchain\u003c'a\u003e {\r\n    fn new(name: \u0026'a str, prefix: \u0026'a str, supported_cryptos: Vec\u003c\u0026'a str\u003e) -\u003e Self {\r\n        Blockchain { name, prefix, supported_cryptos }\r\n    }\r\n\r\n    // ➢ Retirar criptomoneda a blockchain: dado un monto de una cripto y una blockchain\r\n    // se le descuenta del balance de dicha cripto al usuario el monto,\r\n    // la blockchain devuelve un hash que representa una transacción en ella\r\n    // (esto hágalo retornando el nombre de la blockchain + un número random).\r\n    // Luego se genera una transacción con los siguientes datos:\r\n    // fecha, usuario, tipo: retiro cripto, blockchain, hash, cripto, monto, cotización.\r\n\r\n    fn withdraw(\u0026self, data: CommonTransactionData, transaction_type: TransactionType, crypto: \u0026'a str, quote: Quote) -\u003e Result\u003cBlockchainTransaction, ErrorNewTransaction\u003e {\r\n        if !self.supported_cryptos.contains(\u0026crypto) { return Err(ErrorNewTransaction::CryptoNotSupportedByBlockchain { crypto, blockchain: self.name }) }\r\n        \r\n        // all other checks are made by BlockchainTransaction::new()\r\n        BlockchainTransaction::new(\r\n            data,\r\n            transaction_type,\r\n            self.name,\r\n            None, // hash\r\n            crypto,\r\n            quote\r\n        )\r\n    }\r\n}\r\n\r\n//     Cada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\n//     De las criptomonedas se conoce:\r\n//         nombre, prefijo y un listado de blockchains donde se pueden enviar o recibir.\r\n//     De cada blockchain se conoce el nombre, prefijo.\r\n\r\npub enum ErrorNewCryptocurrency {\r\n    MustHaveABlockchain\r\n}\r\n\r\npub struct Cryptocurrency\u003c'a\u003e {\r\n    pub name: \u0026'a str,\r\n    pub prefix: \u0026'a str,\r\n    pub blockchains: Vec\u003c\u0026'a str\u003e // blockchains prefix\r\n}\r\n\r\nimpl\u003c'a\u003e Cryptocurrency\u003c'a\u003e {\r\n    pub fn new(name: \u0026'a str, prefix: \u0026'a str, blockchains: Vec\u003c\u0026'a str\u003e) -\u003e Result\u003cSelf, ErrorNewCryptocurrency\u003e {\r\n        if blockchains.is_empty() { return Err(ErrorNewCryptocurrency::MustHaveABlockchain) }\r\n        Ok(Cryptocurrency {\r\n            name, prefix, blockchains\r\n        })\r\n    }\r\n}\r\n\r\n// Quote\r\n// I could use a tuple instead of a whole struct,\r\n// but I want to enforce compile-time names for values\r\n// as it's not intuitive that .0 is the BUY value and .1 the SELL value\r\n// quote must be copied,\r\n#[derive(Clone)]\r\npub struct Quote {\r\n    pub buy: f64,\r\n    pub sell: f64\r\n}\r\n\r\n// CommonTransactionData\r\n// It's only purpose is to prevent having too many arguments.\r\n// It's only supposed to have data which all transactions need.\r\n// TransctionType could also be set here, but that would imply that user must set the transaction type\r\n// and I prefer transaction types to be hard-coded.\r\n#[derive(Debug, Clone, Copy, PartialEq)]\r\npub struct CommonTransactionData {\r\n    pub date: Date,\r\n    pub user: u32,\r\n    pub amount: f64,\r\n}\r\n\r\n// ➢ Ingresar dinero: se recibe un monto en fiat de un usuario\r\n//     y se acredita al balance de fiat de dicho usuario. Además se crea una transacción del hecho\r\n//      donde los datos que se guardan son:fecha, tipo(ingreso de dinero), monto, usuario.\r\n\r\n#[derive(Error)]\r\npub enum ErrorNewTransaction\u003c'a\u003e {\r\n    InvalidDate,\r\n    InvalidInputAmount{ amount: f64 },\r\n    InvalidTransactionType { transaction_type: TransactionType },\r\n    BlockchainNotDeclared,\r\n    CryptoNotSupportedByBlockchain { crypto: \u0026'a str, blockchain: \u0026'a str },\r\n    FiatWithdrawalNeedsMean\r\n}\r\n\r\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Copy)]\r\npub enum WithdrawalMean {\r\n    BankTansfer, MercadoPago\r\n}\r\n\r\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Copy)]\r\npub enum TransactionType {\r\n    FiatDeposit,\r\n    FiatWithdrawal { mean: WithdrawalMean },\r\n    BlockchainDeposit,\r\n    BlockchainWithdrawal,\r\n    CryptoBuy,\r\n    CryptoSell\r\n}\r\n\r\nimpl fmt::Display for TransactionType {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        match self {\r\n            TransactionType::FiatDeposit =\u003e write!(f, \"Fiat Deposit\"),\r\n            TransactionType::FiatWithdrawal { mean } =\u003e write!(f, \"Fiat Withdrawal via {:?}\", mean),\r\n            TransactionType::BlockchainDeposit =\u003e write!(f, \"Blockchain Deposit\"),\r\n            TransactionType::BlockchainWithdrawal =\u003e write!(f, \"Blockchain Withdrawal\"),\r\n            TransactionType::CryptoBuy =\u003e write!(f, \"Crypto Buy\"),\r\n            TransactionType::CryptoSell =\u003e write!(f, \"Crypto Sell\"),\r\n        }\r\n    }\r\n}\r\n\r\npub struct FiatTransaction {\r\n    pub data: CommonTransactionData,\r\n    pub transaction_type: TransactionType\r\n}\r\n\r\n// all FIAT transfers will be treated as Argentine Peso transfers\r\n\r\nimpl\u003c'a\u003e FiatTransaction {\r\n    pub fn new(data: CommonTransactionData, transaction_type: TransactionType) -\u003e Result\u003cSelf, ErrorNewTransaction\u003c'a\u003e\u003e {\r\n        match transaction_type {\r\n            TransactionType::FiatDeposit =\u003e (),\r\n            TransactionType::FiatWithdrawal { .. } =\u003e (),\r\n            _ =\u003e return Err(ErrorNewTransaction::InvalidTransactionType { transaction_type })\r\n        }\r\n        \r\n        if !data.date.is_date_valid() { return Err(ErrorNewTransaction::InvalidDate) }\r\n        if data.amount \u003c= 0.0 { return Err(ErrorNewTransaction::InvalidInputAmount{ amount: data.amount }) }\r\n\r\n        // user verifications must be done service-side\r\n\r\n        Ok(FiatTransaction {\r\n            data, transaction_type\r\n        })\r\n    }\r\n}\r\n\r\n//\r\n// Crypto Transaction\r\n//\r\n\r\npub struct CryptoTransaction\u003c'a\u003e {\r\n    pub data: CommonTransactionData,\r\n    pub currency: \u0026'a str,\r\n}\r\n\r\n// all FIAT transfers will all be treated as Argentine Peso transfers\r\n\r\nimpl\u003c'a\u003e CryptoTransaction\u003c'a\u003e {\r\n    pub fn new(data: CommonTransactionData, transaction_type: TransactionType, currency: \u0026'a str) -\u003e Result\u003cSelf, ErrorNewTransaction\u003e {\r\n        if !data.date.is_date_valid() { return Err(ErrorNewTransaction::InvalidDate) }\r\n        if data.amount \u003c 0.0 { return Err(ErrorNewTransaction::InvalidInputAmount{ amount: data.amount }) }\r\n\r\n        match transaction_type {\r\n            TransactionType::CryptoBuy =\u003e (),\r\n            TransactionType::CryptoSell =\u003e (),\r\n            _ =\u003e { return Err(ErrorNewTransaction::InvalidTransactionType { transaction_type }) }\r\n        }\r\n        \r\n        // blockchain, currency, user_from, user_to verifications must be done service-side\r\n\r\n\r\n        Ok(CryptoTransaction {\r\n            data, currency\r\n        })\r\n    }\r\n}","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","structs","user.rs"],"content":"/*\r\n\r\n5- La empresa XYZ es una plataforma de intercambio de criptoactivos\r\n    que permite a los usuarios comprar y vender distintas criptomonedas.\r\n\r\n    La plataforma permite el registro de usuarios y la gestión de sus balances\r\n        en distintas criptomonedas y en dinero fíat.\r\n    De los usuarios se conoce:\r\n        nombre, apellido, email, dni, y si está validada su identidad o no.\r\n\r\n    Cada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\n    De las criptomonedas se conoce:\r\n        nombre, prefijo y un listado de blockchains donde se pueden enviar o recibir.\r\n    De cada blockchain se conoce el nombre, prefijo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios\r\n    para resolver las siguientes acciones relacionadas al usuario:\r\n\r\n➢ Ingresar dinero: se recibe un monto en fiat de un usuario\r\n    y se acredita al balance de fiat de dicho usuario. Además se crea una transacción del hecho donde los datos que se guardan son:fecha, tipo(ingreso de dinero), monto, usuario.\r\n\r\n➢ Comprar determinada criptomoneda: dado un monto de fiat se compra una cantidad de determinada criptomoneda,\r\n    tenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual de la criptomoneda para acreditar la correspondiente proporción en el balance de la cripto y desacreditar en el balance de fiat. Luego de ello se registra la transacción con los siguientes datos: fecha, usuario, criptomoneda, tipo: compra de cripto, monto de cripto y cotización.\r\n\r\n➢ Vender determinada criptomoneda: dado un monto de cripto se vende por fiat,\r\n    tenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual\r\n    de la criptomoneda para acreditar la correspondiente proporción en el balance de fiat\r\n    y desacreditar en el balance de la criptomoneda.\r\n        Luego de ello se registra la transacción con los siguientes datos:\r\n            fecha, usuario, criptomoneda, tipo: venta de cripto, monto de cripto y cotización.\r\n\r\n➢ Retirar criptomoneda a blockchain: dado un monto de una cripto y una blockchain\r\n    se le descuenta del balance de dicha cripto al usuario el monto,\r\n    la blockchain devuelve un hash que representa una transacción en ella\r\n    (esto hágalo retornando el nombre de la blockchain + un número random).\r\n    Luego se genera una transacción con los siguientes datos:\r\n        fecha, usuario, tipo: retiro cripto, blockchain, hash, cripto, monto, cotización.\r\n\r\n➢ Recibir criptomoneda de blockchain: dado un monto de una cripto y una blockchain se le acredita\r\n    al balancede dicha cripto al usuario el monto. Luego se genera una transacción con los siguientes datos:\r\n        fecha, usuario, tipo: recepción cripto, blockchain, cripto, monto, cotización.\r\n\r\n➢ Retirar fiat por determinado medio: dado un monto de fiat se le descuenta dicho monto del balance\r\n    al usuario y se genera una transacción con la siguiente información:\r\n        fecha, usuario, tipo: retiro fiat, monto y medio (puede ser MercadoPago o Transferencia Bancaria)\r\nN\r\n    ota:: Tanto para comprar. vender, retirar el usuario debe estar validado.\r\n        Se debe validar siempre que haya balance suficiente para realizar la operación\r\n        en los casos de compra, venta, retiro.\r\n\r\n\r\n    Además la empresa desea saber lo siguiente en base a sus operaciones:\r\n\r\n➢ Saber cual es la criptomoneda que más cantidad de ventas tiene\r\n➢ Saber cual es la criptomoneda que más cantidad de compras tiene\r\n➢ Saber cual es la criptomoneda que más volumen de ventas tiene\r\n➢ Saber cual es la criptomoneda que más volumen de compras tiene\r\n\r\n */\r\n\r\n//    De los usuarios se conoce:\r\n//         nombre, apellido, email, dni, y si está validada su identidad o no.\r\n//     Cada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\n\r\nuse std::collections::HashMap;\r\nuse std::hash::{Hash, Hasher};\r\nuse std::ops::{AddAssign, SubAssign};\r\n\r\n#[derive(Debug, PartialEq, PartialOrd, Clone, Copy)]\r\npub struct Balance(pub f64);\r\n\r\nimpl Balance {\r\n    pub fn new(balance: f64) -\u003e Self {\r\n        Balance(balance)\r\n    }\r\n    pub fn add_assign_f64(\u0026mut self, val: f64) {\r\n        self.0+= val;\r\n    }\r\n    pub fn sub_assign_f64(\u0026mut self, val: f64) {\r\n        self.0-= val;\r\n    }\r\n    pub fn f64(\u0026self) -\u003e f64 { self.0 }\r\n}\r\nimpl Hash for Balance {\r\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\r\n        self.0.to_bits().hash(state);\r\n    }\r\n}\r\nimpl AddAssign for Balance {\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        self.0 += rhs.0;\r\n    }\r\n}\r\nimpl SubAssign for Balance {\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        self.0 -= rhs.0;\r\n    }\r\n}\r\nimpl From\u003cf64\u003e for Balance {\r\n    fn from(value: f64) -\u003e Self {\r\n        Balance(value)\r\n    }\r\n}\r\n\r\ntrait AsBalance {\r\n    fn as_balance(\u0026self) -\u003e Balance;\r\n}\r\nimpl AsBalance for f64 {\r\n    fn as_balance(\u0026self) -\u003e Balance {\r\n        Balance(self.clone())\r\n    }\r\n}\r\n\r\n// user\r\n\r\n#[derive(Debug)]\r\npub struct User\u003c'a\u003e {\r\n    pub first_name: \u0026'a str,\r\n    pub last_name: \u0026'a str,\r\n    pub email: \u0026'a str,\r\n    pub dni: u32, // primary key\r\n    pub identity_validation: bool,\r\n    pub fiat_balance: Balance,\r\n    pub crypto_balance: HashMap\u003c\u0026'a str, Balance\u003e\r\n}\r\n\r\nimpl\u003c'a\u003e Hash for User\u003c'a\u003e {\r\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\r\n        self.first_name.hash(state);\r\n        self.last_name.hash(state);\r\n        self.email.hash(state);\r\n        self.dni.hash(state);\r\n        self.identity_validation.hash(state);\r\n        self.fiat_balance.hash(state);\r\n    }\r\n}\r\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","structs","xyz.rs"],"content":"/*\r\n5- La empresa XYZ es una plataforma de intercambio de criptoactivos\r\nque permite a los usuarios comprar y vender distintas criptomonedas.\r\n\r\nLa plataforma permite el registro de usuarios y la gestión de sus balances\r\nen distintas criptomonedas y en dinero fíat.\r\nDe los usuarios se conoce:\r\nnombre, apellido, email, dni, y si está validada su identidad o no.\r\n\r\nCada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\nDe las criptomonedas se conoce:\r\nnombre, prefijo y un listado de blockchains donde se pueden enviar o recibir.\r\nDe cada blockchain se conoce el nombre, prefijo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios\r\npara resolver las siguientes acciones relacionadas al usuario:\r\n\r\n➢ Ingresar dinero: se recibe un monto en fiat de un usuario\r\ny se acredita al balance de fiat de dicho usuario. Además se crea una transacción del hecho donde los datos que se guardan son:fecha, tipo(ingreso de dinero), monto, usuario.\r\n\r\n➢ Comprar determinada criptomoneda: dado un monto de fiat se compra una cantidad de determinada criptomoneda,\r\ntenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual de la criptomoneda para acreditar la correspondiente proporción en el balance de la cripto y desacreditar en el balance de fiat. Luego de ello se registra la transacción con los siguientes datos: fecha, usuario, criptomoneda, tipo: compra de cripto, monto de cripto y cotización.\r\n\r\n➢ Vender determinada criptomoneda: dado un monto de cripto se vende por fiat,\r\ntenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual\r\nde la criptomoneda para acreditar la correspondiente proporción en el balance de fiat\r\ny desacreditar en el balance de la criptomoneda.\r\nLuego de ello se registra la transacción con los siguientes datos:\r\nfecha, usuario, criptomoneda, tipo: venta de cripto, monto de cripto y cotización.\r\n\r\n➢ Retirar criptomoneda a blockchain: dado un monto de una cripto y una blockchain\r\nse le descuenta del balance de dicha cripto al usuario el monto,\r\nla blockchain devuelve un hash que representa una transacción en ella\r\n(esto hágalo retornando el nombre de la blockchain + un número random).\r\nLuego se genera una transacción con los siguientes datos:\r\nfecha, usuario, tipo: retiro cripto, blockchain, hash, cripto, monto, cotización.\r\n\r\n➢ Recibir criptomoneda de blockchain: dado un monto de una cripto y una blockchain se le acredita\r\nal balancede dicha cripto al usuario el monto. Luego se genera una transacción con los siguientes datos:\r\nfecha, usuario, tipo: recepción cripto, blockchain, cripto, monto, cotización.\r\n\r\n➢ Retirar fiat por determinado medio: dado un monto de fiat se le descuenta dicho monto del balance\r\nal usuario y se genera una transacción con la siguiente información:\r\nfecha, usuario, tipo: retiro fiat, monto y medio (puede ser MercadoPago o Transferencia Bancaria)\r\n\r\nNota:: Tanto para comprar. vender, retirar el usuario debe estar validado.\r\nSe debe validar siempre que haya balance suficiente para realizar la operación\r\nen los casos de compra, venta, retiro.\r\n\r\n\r\nAdemás la empresa desea saber lo siguiente en base a sus operaciones:\r\n\r\n➢ Saber cual es la criptomoneda que más cantidad de ventas tiene\r\n➢ Saber cual es la criptomoneda que más cantidad de compras tiene\r\n➢ Saber cual es la criptomoneda que más volumen de ventas tiene\r\n➢ Saber cual es la criptomoneda que más volumen de compras tiene\r\n\r\n*/\r\nuse error_proc_macro::Error;\r\nuse std::collections::{BTreeMap, HashMap};\r\nuse crate::structs::user::{Balance, User};\r\nuse crate::structs::monetary_structs::{Blockchain, BlockchainTransaction, CommonTransactionData, CryptoTransaction, ErrorNewTransaction, FiatTransaction, Quote, TransactionType, WithdrawalMean};\r\n\r\npub struct XYZ\u003c'a\u003e {\r\n    pub users: BTreeMap\u003cu32, User\u003c'a\u003e\u003e,\r\n    pub blockchains: BTreeMap\u003c\u0026'a str, Blockchain\u003c'a\u003e\u003e,\r\n    pub quotes: HashMap\u003c\u0026'a str, Quote\u003e // (buy, sell) prices\r\n}\r\n\r\n//\r\n// errors\r\n//\r\n\r\n#[derive(Error)]\r\npub enum ErrorFiatDeposit\u003c'a\u003e {\r\n    FiatTransactionError(ErrorNewTransaction\u003c'a\u003e),\r\n    UserNotFound{ user_dni: u32 }\r\n}\r\n\r\n#[derive(Error)]\r\npub enum ErrorFiatWithdraw\u003c'a\u003e {\r\n    FiatTransactionError(ErrorNewTransaction\u003c'a\u003e),\r\n    UserNotFound{ user_dni: u32 },\r\n    NotEnoughBalance{ balance: f64, balance_needed: f64 },\r\n}\r\n\r\n#[derive(Error)]\r\npub enum ErrorBlockchainDeposit\u003c'a\u003e {\r\n    BlockchainTransactionError(ErrorNewTransaction\u003c'a\u003e),\r\n    BlockchainNotFound{ blockchain: \u0026'a str },\r\n    CryptoNotQuoted{ crypto: \u0026'a str },\r\n    UserNotFound{ user_dni: u32 },\r\n}\r\n\r\n#[derive(Error)]\r\npub enum ErrorBlockchainWithdraw\u003c'a\u003e {\r\n    BlockchainTransactionError(ErrorNewTransaction\u003c'a\u003e),\r\n    BlockchainNotFound{ blockchain: \u0026'a str },\r\n    CryptoNotQuoted{ crypto: \u0026'a str },\r\n    UserNotFound{ user_dni: u32 },\r\n    NotEnoughBalance{ balance: f64, balance_needed: f64 }\r\n}\r\n\r\n#[derive(Error)]\r\npub enum ErrorBuySell\u003c'a\u003e {\r\n    CryptoTransactionError(ErrorNewTransaction\u003c'a\u003e),\r\n    CryptocurrencyNotQuoted { crypto_prefix: \u0026'a str },\r\n    UserNotFound { user_dni: u32 },\r\n    NotEnoughBalance { balance: f64, balance_needed: f64 },\r\n    NegativeAmount,\r\n    Unknown(String)\r\n}\r\n\r\nimpl\u003c'a\u003e XYZ\u003c'a\u003e {\r\n    fn new(users: BTreeMap\u003cu32, User\u003c'a\u003e\u003e, blockchains: BTreeMap\u003c\u0026'a str, Blockchain\u003c'a\u003e\u003e, quotes: HashMap\u003c\u0026'a str, Quote\u003e) -\u003e Self {\r\n        Self { users, blockchains, quotes }\r\n    }\r\n\r\n    // ➢ Ingresar dinero: se recibe un monto en fiat de un usuario\r\n    //  y se acredita al balance de fiat de dicho usuario. Además se crea una transacción del hecho.\r\n    fn fiat_deposit(\u0026mut self, data: CommonTransactionData) -\u003e Result\u003cFiatTransaction, ErrorFiatDeposit\u003e {\r\n        // date errors are handled by FiatTransaction::new()\r\n        match FiatTransaction::new(\r\n            data,\r\n            TransactionType::FiatDeposit\r\n        ) {\r\n            Ok(transaction) =\u003e {\r\n                // deposit\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    user.fiat_balance += Balance::from(data.amount);\r\n                } else {\r\n                    return Err(ErrorFiatDeposit::UserNotFound{ user_dni: data.user });\r\n                }\r\n\r\n                Ok(transaction)\r\n            },\r\n            Err(transaction_error) =\u003e Err(ErrorFiatDeposit::FiatTransactionError(transaction_error))\r\n        }\r\n    }\r\n\r\n    // ➢ Retirar fiat por determinado medio: dado un monto de fiat se le descuenta dicho monto del balance\r\n    // al usuario y se genera una transacción con la siguiente información:\r\n    // fecha, usuario, tipo: retiro fiat, monto y medio (puede ser MercadoPago o Transferencia Bancaria)\r\n    fn fiat_withdraw(\u0026mut self, data: CommonTransactionData, mean: WithdrawalMean) -\u003e Result\u003cFiatTransaction, ErrorFiatWithdraw\u003e {\r\n\r\n        match FiatTransaction::new(\r\n            data,\r\n            TransactionType::FiatWithdrawal{ mean }\r\n        ) {\r\n            Ok(transaction) =\u003e {\r\n                // does user exist/have enough balance?\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    // not enough! abort.\r\n                    if user.fiat_balance \u003c Balance(data.amount) { return Err( ErrorFiatWithdraw::NotEnoughBalance {\r\n                        balance_needed: data.amount, balance: user.fiat_balance.f64()\r\n                    }) }\r\n\r\n                    // enough! substract balance\r\n                    user.fiat_balance-= Balance(data.amount);\r\n                } else {\r\n                    return Err(ErrorFiatWithdraw::UserNotFound { user_dni: data.user })\r\n                };\r\n\r\n                Ok(transaction)\r\n            }\r\n            Err(error) =\u003e { Err(ErrorFiatWithdraw::FiatTransactionError( error )) }\r\n        }\r\n    }\r\n\r\n    // ➢ Comprar determinada criptomoneda: dado un monto de fiat se compra una cantidad de determinada criptomoneda,\r\n    //  tenga en cuenta que al momento de realizar la operación se obtiene del sistema\r\n    //  la cotización actual de la criptomoneda para acreditar la correspondiente proporción en el balance\r\n    //  de la cripto y desacreditar en el balance de fiat.\r\n    // Luego de ello se registra la transacción con los siguientes datos:\r\n    //      fecha, usuario, criptomoneda, tipo: compra de cripto, monto de cripto y cotización.\r\n    fn buy_crypto(\u0026mut self, data: CommonTransactionData, crypto_prefix: \u0026'a str)\r\n                  -\u003e Result\u003cCryptoTransaction\u003c'a\u003e, ErrorBuySell\u003e {\r\n        // date errors are handled by CryptoTransaction::new()\r\n\r\n        // check 1: invalid fiat amount\r\n        if data.amount \u003c 0.0 {\r\n            return Err(ErrorBuySell::NegativeAmount)\r\n        }\r\n\r\n        match CryptoTransaction::new(\r\n            data,\r\n            TransactionType::CryptoBuy,\r\n            crypto_prefix\r\n        ) {\r\n\r\n            Ok(transaction) =\u003e {\r\n                // process buy\r\n\r\n                // check 2: currency must be quoted AND quoted higher than 0.0\r\n                let currency_unitary_value = if let Some(quoting) = self.quotes.get(crypto_prefix) {\r\n                    if quoting.buy \u003c= 0.0 { return Err(ErrorBuySell::Unknown(format!(\"${crypto_prefix} is valued at {} FIAT (which is \u003c= 0)\", quoting.buy))) }\r\n                    quoting.buy\r\n                } else {\r\n                    return Err(ErrorBuySell::CryptocurrencyNotQuoted{ crypto_prefix });\r\n                };\r\n\r\n                let transaction_crypto_amount = data.amount / currency_unitary_value; // .0 -\u003e buy, .1 -\u003e sell\r\n\r\n                // check 3: user must exist\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    // check 4: user must have enough fiat balance\r\n                    if user.fiat_balance \u003c Balance::from(data.amount) {\r\n                        return Err(ErrorBuySell::NotEnoughBalance{ balance: user.fiat_balance.f64(), balance_needed: data.amount })\r\n                    }\r\n\r\n                    // no error. execute operation\r\n                    user.fiat_balance-= Balance::from(data.amount);\r\n                    *user.crypto_balance.entry(crypto_prefix).or_insert(Balance::from(0.0))+= Balance::from(transaction_crypto_amount);\r\n                } else {\r\n                    return Err(ErrorBuySell::UserNotFound{ user_dni: data.user });\r\n                };\r\n\r\n                Ok(transaction)\r\n            },\r\n            Err(error) =\u003e Err(ErrorBuySell::CryptoTransactionError(error))\r\n        }\r\n    }\r\n\r\n    // ➢ Vender determinada criptomoneda: dado un monto de cripto se vende por fiat,\r\n    //  tenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual\r\n    //  de la criptomoneda para acreditar la correspondiente proporción en el balance de fiat\r\n    //  y desacreditar en el balance de la criptomoneda.\r\n    //  Luego de ello se registra la transacción con los siguientes datos:\r\n    //  fecha, usuario, criptomoneda, tipo: venta de cripto, monto de cripto y cotización.\r\n    fn sell_crypto(\u0026mut self, data: CommonTransactionData, crypto_prefix: \u0026'a str) -\u003e\r\n        Result\u003cCryptoTransaction, ErrorBuySell\u003e {\r\n        // date errors are handled by CryptoTransaction::new()\r\n\r\n        // check 1: amounts should be higher than 0\r\n        if data.amount \u003c= 0.0 {\r\n            return Err(ErrorBuySell::NegativeAmount)\r\n        }\r\n\r\n        match CryptoTransaction::new(\r\n            data,\r\n            TransactionType::CryptoSell,\r\n            crypto_prefix,\r\n        ) {\r\n            Ok(transaction) =\u003e {\r\n                // process sell\r\n\r\n                // check 2: currency must be quoted AND quoted higher than 0.0\r\n                let currency_value = if let Some(quoting) = self.quotes.get(crypto_prefix) {\r\n                    if quoting.sell \u003c= 0.0 { return Err(ErrorBuySell::Unknown(format!(\"${crypto_prefix} is valued at {} FIAT (which is \u003c= 0)\", quoting.sell))) }\r\n                    quoting\r\n                } else {\r\n                    return Err(ErrorBuySell::CryptocurrencyNotQuoted{ crypto_prefix });\r\n                };\r\n\r\n                let transaction_fiat_value = currency_value.sell * data.amount;\r\n\r\n                // check 3: user must exist\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    // check 4: user must have enough $crypto_prefix balance\r\n                    if let Some(user_crypto_balance) = user.crypto_balance.get_mut(crypto_prefix) {\r\n                        if *user_crypto_balance \u003c Balance::from(data.amount) {\r\n                            return Err(ErrorBuySell::NotEnoughBalance { balance: user_crypto_balance.f64(), balance_needed: data.amount })\r\n                        }\r\n                        \r\n                        // no error. execute operation\r\n                        *user_crypto_balance-= Balance::from(data.amount);\r\n                        user.fiat_balance+= Balance::from(transaction_fiat_value);\r\n                    } else {\r\n                        return Err(ErrorBuySell::NotEnoughBalance{ balance: 0.0, balance_needed: data.amount })\r\n                    }\r\n                } else {\r\n                    return Err(ErrorBuySell::UserNotFound{ user_dni: data.user });\r\n                };\r\n\r\n                Ok(transaction)\r\n            },\r\n            Err(error) =\u003e Err(ErrorBuySell::CryptoTransactionError(error))\r\n        }\r\n    }\r\n\r\n    // ➢ Retirar criptomoneda a blockchain: dado un monto de una cripto y una blockchain\r\n    // se le descuenta del balance de dicha cripto al usuario el monto,\r\n    // la blockchain devuelve un hash que representa una transacción en ella\r\n    // (esto hágalo retornando el nombre de la blockchain + un número random).\r\n    // Luego se genera una transacción con los siguientes datos:\r\n    // fecha, usuario, tipo: retiro cripto, blockchain, hash, cripto, monto, cotización.\r\n    fn withdraw_to_blockchain(\u0026mut self, data: CommonTransactionData, blockchain: \u0026'a str, crypto: \u0026'a str) -\u003e Result\u003cBlockchainTransaction, ErrorBlockchainWithdraw\u003e {\r\n        // does blockchain exist?\r\n        if !self.blockchains.contains_key(blockchain) {\r\n            return Err(ErrorBlockchainWithdraw::BlockchainNotFound { blockchain })\r\n        };\r\n\r\n        // does crypto have a quote?\r\n        let quote = if let Some(quote) = self.quotes.get(crypto) {\r\n            quote\r\n        } else {\r\n            return Err(ErrorBlockchainWithdraw::CryptoNotQuoted { crypto })\r\n        };\r\n\r\n        match BlockchainTransaction::new(\r\n            data,\r\n            TransactionType::BlockchainWithdrawal,\r\n            blockchain,\r\n            None,\r\n            crypto,\r\n            quote.clone() // quote should be cloned, as it changes over time. can't be copied due to containing f64\r\n        ) {\r\n            Ok(transaction) =\u003e {\r\n                // remove balance\r\n                // does user exist/have enough balance?\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    if let Some(balance) = user.crypto_balance.get_mut(crypto) {\r\n                        *balance-= Balance::from(data.amount);\r\n                    } else {\r\n                        return Err(ErrorBlockchainWithdraw::NotEnoughBalance { balance: 0.0, balance_needed: data.amount } )\r\n                    };\r\n                } else {\r\n                    return Err(ErrorBlockchainWithdraw::UserNotFound { user_dni: data.user })\r\n                };\r\n                Ok(transaction)\r\n            }\r\n            Err(error) =\u003e { Err(ErrorBlockchainWithdraw::BlockchainTransactionError( error )) }\r\n        }\r\n    }\r\n\r\n    // ➢ Recibir criptomoneda de blockchain: dado un monto de una cripto y una blockchain se le acredita\r\n    // al balancede dicha cripto al usuario el monto. Luego se genera una transacción con los siguientes datos:\r\n    // fecha, usuario, tipo: recepción cripto, blockchain, cripto, monto, cotización.\r\n    fn deposit_from_blockchain(\u0026mut self, data: CommonTransactionData, blockchain: \u0026'a str, crypto: \u0026'a str) -\u003e Result\u003cBlockchainTransaction, ErrorBlockchainDeposit\u003e {\r\n        // does blockchain exist?\r\n        if !self.blockchains.contains_key(blockchain) {\r\n            return Err(ErrorBlockchainDeposit::BlockchainNotFound { blockchain })\r\n        };\r\n\r\n        // does crypto have a quote?\r\n        let quote = if let Some(q) = self.quotes.get(crypto) {\r\n            q\r\n        } else {\r\n            return Err(ErrorBlockchainDeposit::CryptoNotQuoted { crypto })\r\n        };\r\n\r\n        match BlockchainTransaction::new(\r\n            data,\r\n            TransactionType::BlockchainDeposit,\r\n            blockchain,\r\n            None,\r\n            crypto,\r\n            quote.clone() // quote should be cloned, as it changes over time. can't be copied due to containing f64\r\n        ) {\r\n            Ok(transaction) =\u003e {\r\n                // add to balance\r\n                // does user exist/have enough balance?\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    // enough! ready to withdraw\r\n                    user.fiat_balance+= Balance::from(data.amount);\r\n                } else {\r\n                    return Err(ErrorBlockchainDeposit::UserNotFound { user_dni: data.user })\r\n                };\r\n\r\n                Ok(transaction)\r\n            }\r\n            Err(error) =\u003e { Err(ErrorBlockchainDeposit::BlockchainTransactionError( error )) }\r\n        }\r\n    }\r\n\r\n    // Nota:: Tanto para comprar. vender, retirar el usuario debe estar validado.\r\n    // Se debe validar siempre que haya balance suficiente para realizar la operación\r\n    // en los casos de compra, venta, retiro.\r\n}","traces":[{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":102},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e1","src","main.rs"],"content":"pub mod structs;\n\n/*\na- Al agregar un auto si supera el límite de la concesionaria debe arrojar un error propio con un mensaje de contexto.\n\nb- Haga todos los tests correspondientes para probar en profundidad los métodos que agregan un auto y eliminan un auto de la concesionaria,\n    obteniendo el mayor porcentaje de coverage sobre el código que realiza las operaciones.\n\nc- Una vez hecho el punto anterior debe hacer que los autos de la concesionaria se almacenen en un archivo en formato JSON.\n    Agregue y modifique lo que considere necesario para que:\n        - Al agregar un nuevo auto se abre el archivo de autos guardados y lo agregue a dicho archivo.\n        - Eliminar un auto: al eliminar un auto se debe eliminar este del archivo.\n\nNo debe modificar los tests hechos en el punto b. Si puede agregar más en caso de que haga nueva funcionalidad..\n */\n\nfn main() {\n    println!(\"Hello, world!\");\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e1","src","structs","auto.rs"],"content":"use error_proc_macro::Error;\r\nuse serde::{Serialize, Serializer};\r\n\r\n#[derive(Serialize, PartialEq, Clone)]\r\npub enum Color {\r\n    Rojo, Verde, Azul, Amarillo, Blanco, Negro\r\n}\r\n\r\n#[derive(Serialize, PartialEq, Clone)]\r\npub struct Auto\u003c'a\u003e {\r\n    pub marca: \u0026'a str,\r\n    pub modelo: \u0026'a str,\r\n    pub ano: u16,\r\n    pub precio: f64,\r\n    pub color: Color\r\n}\r\n\r\n#[derive(Error)]\r\npub enum ErrorNewAuto {\r\n    InvalidYear{ year: u16 },\r\n    InvalidPrice{ price: f64 },\r\n}\r\n\r\nimpl\u003c'a\u003e Auto\u003c'a\u003e {\r\n    // ➢ new: que pasando los parámetros correspondientes, crea un Auto y lo retorna.\r\n    pub fn new(marca: \u0026'a str, modelo: \u0026'a str, ano: u16, precio: f64, color: Color) -\u003e Result\u003cSelf, ErrorNewAuto\u003e {\r\n        if ano \u003c 1886 { return Err(ErrorNewAuto::InvalidYear{ year: ano }) }\r\n        if precio \u003c 0.0 || precio.is_nan() || !precio.is_finite() { return Err(ErrorNewAuto::InvalidPrice{ price: precio }) }\r\n        \r\n        Ok(Self { marca, modelo, ano, precio, color })\r\n    }\r\n\r\n    // ➢ calcular_precio: retorna el precio del auto aplicando los siguientes criterios:\r\n    pub fn calcular_precio(\u0026self) -\u003e f64 {\r\n        // ■ si es de color primario le aplica un recargo del 25%, sino le aplica un descuento del 10%.\r\n        let recargo_color = match self.color {\r\n            Color::Rojo | Color::Azul | Color::Amarillo =\u003e self.precio * 0.25,\r\n            _ =\u003e self.precio * -0.1\r\n        };\r\n\r\n        // ■ si la marca es BMW le aplica un recargo del 15%\r\n        let recargo_bmw = if self.marca == \"BMW\" { self.precio * 0.15 } else { 0.0 };\r\n\r\n        // ■ si el año es menor a 2000 le aplica un descuento del 5%.\r\n        let descuento_ano = if self.ano \u003c 2000 { self.precio * 0.05 } else { 0.0 };\r\n\r\n        self.precio + recargo_color + recargo_bmw - descuento_ano\r\n    }\r\n}","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e1","src","structs","concesionario.rs"],"content":"use std::fs;\r\nuse error_proc_macro::Error;\r\nuse crate::structs::auto::Auto;\r\n\r\npub struct Concesionario\u003c'a\u003e {\r\n    pub nombre: \u0026'a str,\r\n    pub direccion: \u0026'a str,\r\n    pub autos: Vec\u003cAuto\u003c'a\u003e\u003e\r\n}\r\n\r\n#[derive(Error, PartialEq)]\r\npub enum ErrorAgregarAuto {\r\n    ConcesionarioLleno { capacidad: usize },\r\n    ArchivoNoGuardado\r\n}\r\n\r\n#[derive(Error, PartialEq)]\r\npub enum ErrorEliminarAuto {\r\n    ConcesionarioVacio,\r\n    AutoInexistente,\r\n    ArchivoNoGuardado\r\n}\r\n\r\nimpl\u003c'a\u003e Concesionario\u003c'a\u003e {\r\n    // ➢ new: que pasando los parámetros correspondientes, crea un ConcesionarioAuto y lo retorna.\r\n    pub fn new(nombre: \u0026'a str, direccion: \u0026'a str, capacidad: usize) -\u003e Self {\r\n        Self { nombre, direccion, autos: Vec::with_capacity(capacidad) }\r\n    }\r\n\r\n    // c- Una vez hecho el punto anterior debe hacer que los autos de la concesionaria se\r\n    // almacenen en un archivo en formato JSON. Agregue y modifique lo que considere necesario para que:\r\n    //  - Al agregar un nuevo auto se abre el archivo de autos guardados y lo agregue a dicho archivo.\r\n    //  - Eliminar un auto: al eliminar un auto se debe eliminar este del archivo.\r\n\r\n    // ➢ agregar_auto(auto): agrega un auto a la lista de autos que tiene\r\n    //     sin superar la máxima cantidad para albergarlos\r\n    //     y retorna true, en caso de que lo supere no lo agrega y retorna false.\r\n    // returns usize -\u003e Espacio disponible\r\n    pub fn agregar_auto(\u0026mut self, auto: Auto\u003c'a\u003e) -\u003e Result\u003cusize, ErrorAgregarAuto\u003e {\r\n        // a- Al agregar un auto si supera el límite de la concesionaria debe arrojar un error propio con un mensaje de contexto.\r\n        if  self.autos.len() == self.autos.capacity() {\r\n            return Err(ErrorAgregarAuto::ConcesionarioLleno { capacidad: self.autos.capacity() })\r\n        }\r\n\r\n        self.autos.push(auto);\r\n\r\n        if !self.reescribir_json_autos() { return Err(ErrorAgregarAuto::ArchivoNoGuardado) }\r\n\r\n        Ok(\r\n            self.autos.capacity() - self.autos.len()\r\n        )\r\n    }\r\n\r\n    // ➢ eliminar_auto(auto): elimina un auto de la lista de autos.\r\n    pub fn eliminar_auto(\u0026mut self, marca: \u0026'a str, modelo: \u0026'a str, ano: u16) -\u003e Result\u003cAuto, ErrorEliminarAuto\u003e {\r\n        if self.autos.is_empty() { return Err(ErrorEliminarAuto::ConcesionarioVacio) }\r\n\r\n        let mut found_index = 0;\r\n        let mut found = false;\r\n        for (index, auto) in self.autos.iter().enumerate() {\r\n            if auto.marca == marca \u0026\u0026 auto.modelo == modelo \u0026\u0026 auto.ano == ano {\r\n                found_index = index; found = true; break;\r\n            }\r\n        }\r\n\r\n        if !found {\r\n            return Err(ErrorEliminarAuto::AutoInexistente)\r\n        }\r\n\r\n        let auto = self.autos.remove(found_index);\r\n\r\n        if !self.reescribir_json_autos() { Err(ErrorEliminarAuto::ArchivoNoGuardado) }\r\n        else { Ok(auto) }\r\n    }\r\n\r\n    fn reescribir_json_autos(\u0026self) -\u003e bool {\r\n        // c. reescribir el archivo con la información del vector de autos\r\n        match serde_json::to_string_pretty(\u0026self.autos) {\r\n            Ok(res) =\u003e {\r\n                if fs::write(\"autos.json\", res).is_err() {\r\n                    return false\r\n                }\r\n                true\r\n            }\r\n            Err(_) =\u003e { false }\r\n        }\r\n    }\r\n\r\n    // ➢ buscar_auto(auto): busca un auto y si lo encuentra lo retorna.\r\n    pub fn buscar_auto(\u0026self, marca: \u0026'a str, modelo: \u0026'a str, ano: u16) -\u003e Option\u003c\u0026Auto\u003e {\r\n        for auto in \u0026self.autos {\r\n            if auto.marca == marca \u0026\u0026 auto.modelo == modelo \u0026\u0026 auto.ano == ano {\r\n                return Some(auto)\r\n            }\r\n        }\r\n\r\n        None\r\n    }\r\n}\r\n\r\n/*\r\n    b- Haga todos los tests correspondientes para probar en profundidad los métodos que agregan un auto y eliminan un auto de la concesionaria,\r\n        obteniendo el mayor porcentaje de coverage sobre el código que realiza las operaciones.\r\n */\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::structs::auto::Color;\r\n    use super::*;\r\n\r\n    fn concesionario\u003c'a\u003e(capacity: usize) -\u003e Concesionario\u003c'a\u003e {\r\n        Concesionario{\r\n            nombre: \"asd\",\r\n            direccion: \"dire\",\r\n            autos: Vec::with_capacity(capacity)\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_agregar() {\r\n        let mut c = concesionario(1);\r\n\r\n        let auto1 = Auto { marca: \"Nissan\", modelo: \"March 1.6\", ano: 2012, precio: 10.0, color: Color::Negro };\r\n        let auto2 = Auto { marca: \"Nissan2\", modelo: \"March 1.62\", ano: 20122, precio: 10.2, color: Color::Azul };\r\n\r\n        let res_agregar_1 = c.agregar_auto(auto1);\r\n        let res_agregar_2 = c.agregar_auto(auto2);\r\n\r\n        assert!(res_agregar_1.is_ok(), \"No debe causar error: concesionario tiene un auto de capacidad.\");\r\n        assert!(res_agregar_2.is_err(), \"Debe causar error: concesionario tiene sólo un auto de capacidad.\");\r\n\r\n        let res_agregar_1 = res_agregar_1.unwrap();\r\n        let res_agregar_2 = res_agregar_2.unwrap_err();\r\n\r\n        assert_eq!(res_agregar_1, 0, \"No debe quedar espacio para más autos.\");\r\n        assert_eq!(res_agregar_2, ErrorAgregarAuto::ConcesionarioLleno { capacidad: 1 });\r\n    }\r\n\r\n    #[test]\r\n    fn test_eliminar() {\r\n        let mut c = concesionario(1);\r\n\r\n        let auto1 = Auto { marca: \"Nissan\", modelo: \"March 1.6\", ano: 2012, precio: 10.0, color: Color::Negro };\r\n\r\n        let res_agregar_1 = c.agregar_auto(auto1.clone());\r\n\r\n        let res_eliminar_1 = c.eliminar_auto(\"asd\", \"asdasdanoexiste\", 9999);\r\n\r\n        match res_eliminar_1 {\r\n            Ok(_) =\u003e { panic!(\"Debería fallar\") }\r\n            Err(err) =\u003e { assert_eq!(err, ErrorEliminarAuto::AutoInexistente, \"el auto a eliminar no existe\") }\r\n        }\r\n\r\n        let res_eliminar_2 = c.eliminar_auto(auto1.marca, auto1.modelo, auto1.ano);\r\n\r\n        assert!(res_eliminar_2.is_ok(), \"No debería fallar, el auto existe\");\r\n\r\n        let res_eliminar_3 = c.eliminar_auto(auto1.marca, auto1.modelo, auto1.ano);\r\n\r\n        match res_eliminar_3 {\r\n            Ok(_) =\u003e {}\r\n            Err(err) =\u003e { assert_eq!(err, ErrorEliminarAuto::ConcesionarioVacio, \"el concesionario está vacío\") }\r\n        }\r\n    }\r\n\r\n}","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e1","src","structs","mod.rs"],"content":"pub mod concesionario;\r\npub mod auto;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e2","src","main.rs"],"content":"// 2- En base al ejercicio 8 del tp#3 implemente lo siguiente:\n//      a- Realice todos los tests de la funcionalidad implementada obteniendo un coverage de por lo menos 90%\n//      b- Una vez obtenido dicho coverage, las canciones de la playlist deben ser guardadas en un archivo en formato JSON,\n//          por lo tanto las operaciones que agreguen, quiten o modifiquen la playlist deben estar respaldadas sobre dicho archivo.\n//      \n//      No debe modificar los tests hechos en el punto a.\n//      Si puede agregar más en caso de que haga métodos nuevos.\n//      Recuerde también que se debe seguir manteniendo un coverage de al menos 90%,\n\nmod structs;\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e2","src","structs","cancion.rs"],"content":"use serde::Serialize;\r\n\r\n#[derive(Serialize, PartialEq, Clone, Copy, Debug)]\r\npub enum Genero {\r\n    Rock, Pop, Rap, Jazz, Otros\r\n}\r\n\r\n#[derive(Serialize, PartialEq, Clone, Debug)]\r\npub struct Cancion\u003c'a\u003e {\r\n    pub titulo: \u0026'a str,\r\n    pub artista: \u0026'a str,\r\n    pub genero: Genero,\r\n}\r\n\r\nimpl\u003c'a\u003e Cancion\u003c'a\u003e {\r\n    pub fn new(titulo: \u0026'a str, artista: \u0026'a str, genero: Genero) -\u003e Self {\r\n        Self { titulo, artista, genero }\r\n    }\r\n}","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e2","src","structs","mod.rs"],"content":"pub mod cancion;\r\npub mod playlist;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e2","src","structs","playlist.rs"],"content":"use std::fs::File;\r\nuse std::io::Write;\r\nuse error_proc_macro::Error;\r\nuse serde::Serialize;\r\nuse crate::structs::cancion::{Cancion, Genero};\r\n\r\n#[derive(Serialize)]\r\npub struct Playlist\u003c'a\u003e {\r\n    pub nombre: \u0026'a str,\r\n    pub canciones: Vec\u003cCancion\u003c'a\u003e\u003e\r\n}\r\n\r\npub enum ResultAgregarCancion {\r\n    Exito(ResultSobreescribirArchivo),\r\n    PlaylistLlena{ capacity: usize },\r\n}\r\n\r\npub enum ResultMoverCancion {\r\n    Exito(ResultSobreescribirArchivo),\r\n    PosicionFueraDeLimites { limite: usize },\r\n    CancionNoEncontrada\r\n}\r\n\r\npub enum ResultEliminarCancion\u003c'a\u003e {\r\n    Exito{ cancion: Cancion\u003c'a\u003e, resultado_sobreescribir_archivo: ResultSobreescribirArchivo },\r\n    CancionNoExiste,\r\n}\r\n\r\n#[derive(Error)]\r\nenum ResultSobreescribirArchivo {\r\n    Exito,\r\n    CrearArchivo,\r\n    SerializarPlaylist,\r\n    EscribirArchivo\r\n}\r\n\r\nimpl\u003c'a\u003e Playlist\u003c'a\u003e {\r\n    pub fn new(nombre: \u0026'a str) -\u003e Self {\r\n        Self { nombre, canciones: Vec::new() }\r\n    }\r\n\r\n    // ➔ agregar canción.\r\n    pub fn agregar_cancion(\u0026mut self, cancion: Cancion\u003c'a\u003e) -\u003e ResultAgregarCancion {\r\n        if self.canciones.len() == self.canciones.capacity() { return ResultAgregarCancion::PlaylistLlena { capacity: self.canciones.len() } }\r\n        self.canciones.push(cancion);\r\n        ResultAgregarCancion::Exito(self.sobreescribir_archivo())\r\n    }\r\n\r\n    // ➔ eliminar canción.\r\n    pub fn eliminar_cancion(\u0026mut self, titulo: \u0026'a str, artista: \u0026'a str) -\u003e ResultEliminarCancion {\r\n        if let Some(index) = self.canciones.iter().position(|c| c.titulo == titulo \u0026\u0026 c.artista == artista) {\r\n            let cancion = self.canciones.remove(index);\r\n            ResultEliminarCancion::Exito { cancion, resultado_sobreescribir_archivo: self.sobreescribir_archivo() } // no usar swap_remove para mantener orden relativo\r\n        } else {\r\n            ResultEliminarCancion::CancionNoExiste\r\n        }\r\n    }\r\n\r\n    // ➔ mover canción: mueve la canción a una determinada posición de la playlist.\r\n    pub fn mover_cancion(\u0026mut self, titulo: \u0026'a str, artista: \u0026'a str, posicion: usize) -\u003e ResultMoverCancion {\r\n        if posicion \u003e= self.canciones.len() { return ResultMoverCancion::PosicionFueraDeLimites{ limite: self.canciones.len() - 1 } }\r\n\r\n        let index_cancion = if let Some(index) = self.canciones.iter().position(|c| c.titulo == titulo \u0026\u0026 c.artista == artista) {\r\n            index\r\n        } else { return ResultMoverCancion::CancionNoEncontrada };\r\n\r\n        // mover\r\n        let cancion = self.canciones.remove(index_cancion);\r\n        self.canciones.insert(posicion, cancion);\r\n\r\n        ResultMoverCancion::Exito(self.sobreescribir_archivo())\r\n    }\r\n\r\n    // ➔ buscar canción por nombre. (no puede ser solo una :/)\r\n    pub fn buscar_cancion(\u0026self, nombre_cancion: \u0026'a str) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n        let mut canciones_encontradas = Vec::with_capacity(self.canciones.capacity());\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.titulo == nombre_cancion {\r\n                canciones_encontradas.push(cancion);\r\n            }\r\n        }\r\n        canciones_encontradas\r\n    }\r\n\r\n    // ➔ obtener las canciones de un determinado género.\r\n    pub fn listar_canciones_genero(\u0026self, genero: \u0026Genero) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n        let mut vec: Vec\u003c\u0026Cancion\u003e = Vec::new();\r\n\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.genero == *genero {\r\n                vec.push(cancion);\r\n            }\r\n        }\r\n\r\n        vec\r\n    }\r\n\r\n    // ➔ obtener las canciones de un determinado artista.\r\n    pub fn listar_canciones_artista(\u0026self, artista: \u0026str) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n        let mut vec: Vec\u003c\u0026Cancion\u003e = Vec::new();\r\n\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.artista == artista {\r\n                vec.push(cancion);\r\n            }\r\n        }\r\n\r\n        vec\r\n    }\r\n\r\n    // ➔ modificar título de la playlist.\r\n    pub fn modificar_titulo(\u0026mut self, titulo: \u0026'a str) -\u003e ResultSobreescribirArchivo {\r\n        self.nombre = titulo;\r\n        self.sobreescribir_archivo()\r\n    }\r\n\r\n    // ➔ eliminar todas las canciones.\r\n    pub fn clear(\u0026mut self) -\u003e ResultSobreescribirArchivo {\r\n        self.canciones.clear();\r\n        self.sobreescribir_archivo()\r\n    }\r\n\r\n    //      b- Una vez obtenido dicho coverage, las canciones de la playlist deben ser guardadas en un archivo en formato JSON,\r\n    //          por lo tanto las operaciones que agreguen, quiten o modifiquen la playlist deben estar respaldadas sobre dicho archivo.\r\n\r\n    fn sobreescribir_archivo(\u0026self) -\u003e ResultSobreescribirArchivo {\r\n        let mut file = match File::create(format!(\"{}.json\", self.nombre)) {\r\n            Ok(res) =\u003e { res }\r\n            Err(_) =\u003e { return ResultSobreescribirArchivo::CrearArchivo }\r\n        };\r\n\r\n        let json_data = match serde_json::to_string_pretty(self) {\r\n            Ok(res) =\u003e { res }\r\n            Err(_) =\u003e { return ResultSobreescribirArchivo::SerializarPlaylist }\r\n        };\r\n\r\n        match file.write(json_data.as_bytes()) {\r\n            Ok(res) =\u003e { ResultSobreescribirArchivo::Exito },\r\n            Err(_) =\u003e { ResultSobreescribirArchivo::EscribirArchivo }\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::cmp::PartialEq;\r\n    use crate::structs::cancion::{Cancion, Genero};\r\n    use crate::structs::playlist::Playlist;\r\n\r\n    impl\u003c'a\u003e PartialEq\u003cCancion\u003c'a\u003e\u003e for \u0026Cancion\u003c'a\u003e {\r\n        fn eq(\u0026self, cancion: \u0026Cancion) -\u003e bool {\r\n            cancion.titulo == self.titulo\r\n                \u0026\u0026 cancion.artista == self.artista\r\n                \u0026\u0026 cancion.genero == self.genero\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test() {\r\n        let mut mi_playlist = Playlist::new(\"platuka\");\r\n\r\n        let mi_cancion_1 = Cancion::new(\"Un siglo sin tí\", \"Chayanne\", Genero::Pop);\r\n        let mi_cancion_2 = Cancion::new(\"Mi abuela\", \"Molotov\", Genero::Rap);\r\n        let mi_cancion_3 = Cancion::new(\"Te odio y te quiero\", \"Julio Jaramillo\", Genero::Otros);\r\n        let mi_cancion_4 = Cancion::new(\"Fatalidad\", \"Julio Jaramillo\", Genero::Otros);\r\n\r\n        mi_playlist.agregar_cancion(mi_cancion_1.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_2.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_3.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_4.clone());\r\n\r\n        // test agregado\r\n        assert_eq!(mi_playlist.listar_canciones_genero(\u0026Genero::Otros).len(), 2, \"Deberían haber 2 canciones de género \\\"otros\\\"\");\r\n\r\n        // test mover\r\n        mi_playlist.mover_cancion(mi_cancion_1.titulo, mi_cancion_1.artista, 4);\r\n        assert_eq!(mi_playlist.canciones.get(3).unwrap(), mi_cancion_1, \"La canción no parece haberse movido...\");\r\n\r\n        // test buscar genero\r\n        assert_eq!(mi_playlist.listar_canciones_genero(\u0026Genero::Otros).len(), 2, \"Deberían haber 2 canciones en género Otros\");\r\n\r\n        // test clear\r\n        mi_playlist.clear();\r\n        assert_eq!(mi_playlist.canciones.len(), 0, \"La playlist debería estar vacía\");\r\n    }\r\n\r\n}","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":52},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e3","src","main.rs"],"content":"// 3- En base al ejercicio 9 del tp#3 implemente lo siguiente:\n//  a- Realice todos los tests de la funcionalidad implementada obteniendo un coverage de por lo menos 90%\n//  b- Ahora el registro de atenciones debe persistir en un archivo en formato JSON,\n//      es decir todas la operaciones que lectura, agregar y modificación de atenciones se realizan sobre un archivo.\n//\n//      No debe modificar los tests hechos en el punto a.\n//      Si puede agregar más en caso de que haga métodos nuevos para cumplir con este punto.\n//      Recuerde también que se debe seguir manteniendo un coverage de al menos 90%.\n\nmod structs;\n\nfn main() {\n    println!(\"Hello, world!\");\n    \n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e3","src","structs","atencion.rs"],"content":"use std::fmt;\r\nuse std::fmt::{format, write, Formatter};\r\nuse serde::{Deserialize, Deserializer, Serialize};\r\npub(crate) use crate::structs::fecha::Fecha;\r\n\r\n// Luego de la atención se desea tener un registro de las atenciones realizadas guardando:\r\n// - datos de la mascota\r\n// - el diagnóstico final\r\n// - tratamiento\r\n// - fecha de la próxima visita si es que se requiere.\r\n\r\n#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, Default)]\r\npub struct Atencion {\r\n    pub mascota: Mascota,\r\n    pub diagnostico: String,\r\n    pub tratamiento: String,\r\n    pub proxima_visita: Fecha,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, Default)]\r\npub enum Animal {\r\n    Perro, Gato, Caballo,\r\n    #[default] Otros\r\n}\r\n\r\n// De la mascota se conoce\r\n// - nombre\r\n// - edad\r\n// - tipo de animal (perro, gato, caballo, otros)\r\n// - su dueño.\r\n#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, Default)]\r\npub struct Mascota {\r\n    pub nombre: String,\r\n    pub edad: u16,\r\n    pub animal: Animal,\r\n    pub dueno: Dueno,\r\n}\r\n\r\nimpl fmt::Display for Mascota {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        write!(f, \"({}) {}\", self.edad, self.nombre)\r\n    }\r\n}\r\n\r\n// Del dueño se conoce\r\n// - nombre\r\n// - direccion\r\n// - teléfono de contacto.\r\n#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, Default)]\r\npub struct Dueno {\r\n    pub nombre: String,\r\n    pub direccion: String,\r\n    pub telefono: u64,\r\n}\r\n\r\nimpl Atencion {\r\n    // ➔ modificar el diagnóstico de una determinada atención.\r\n    pub fn modificar_diagnostico_atencion(\u0026mut self, nuevo_diagnostico: String) {\r\n        self.diagnostico = nuevo_diagnostico;\r\n    }\r\n\r\n    // ➔ modificar la fecha de la próxima visita de una determinada atención.\r\n    pub fn modificar_fecha_atencion(\u0026mut self, nueva_fecha: Fecha) {\r\n        self.proxima_visita = nueva_fecha;\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e3","src","structs","fecha.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Serialize, Deserialize, Clone, PartialEq, Debug)]\r\npub struct Fecha {\r\n    pub(crate) dia: u8,\r\n    pub(crate) mes: u8,\r\n    pub(crate) ano: i64\r\n}\r\n\r\nimpl Default for Fecha {\r\n    fn default() -\u003e Self {\r\n        Fecha { dia: 1, mes: 1, ano: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Fecha {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.dia == other.dia\r\n            \u0026\u0026 self.mes == other.mes\r\n            \u0026\u0026 self.ano == other.ano\r\n        { return Some(Equal) }\r\n\r\n        if self.ano \u003e other.ano { return Some(Greater) }\r\n        if self.mes \u003e other.mes { return Some(Greater) }\r\n        if self.dia \u003e other.dia { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cFecha\u003e {\r\n        let fecha = Fecha { dia, mes, ano };\r\n        if fecha.es_fecha_valida() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia == 0\r\n            || self.dia \u003e self.dias_mes_actual()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n\r\n    pub fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n\r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e3","src","structs","mod.rs"],"content":"pub mod veterinaria;\r\npub mod atencion;\r\npub mod fecha;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e3","src","structs","veterinaria.rs"],"content":"use std::collections::VecDeque;\r\nuse std::{fmt, fs, io};\r\nuse std::fmt::Formatter;\r\nuse std::fs::File;\r\nuse std::io::Read;\r\nuse crate::structs::atencion::{Atencion, Mascota};\r\nuse crate::structs::fecha::Fecha;\r\n\r\nconst BASE_FOLDER: \u0026str = \"R:/appcrap/RustRover/SdL-Rust/prac5/_p5e3/res/\";\r\n\r\n// De la veterinaria se conoce\r\n// - nombre\r\n// - la dirección\r\n// - un id.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Veterinaria\u003c'a\u003e {\r\n    pub nombre: \u0026'a str,\r\n    pub direccion: \u0026'a str,\r\n    pub id: u64,\r\n    pub cola: VecDeque\u003cMascota\u003e,\r\n    pub atenciones: Vec\u003cAtencion\u003e\r\n}\r\n\r\n//\r\n// results ArchivoAtenciones\r\n//\r\n\r\n#[derive(Debug)]\r\npub enum ResultArchivoAtenciones {\r\n    Read{ atenciones: Vec\u003cAtencion\u003e },\r\n    Written{ json: String },\r\n    IOError(io::Error),\r\n    SerializeError(serde_json::error::Error),\r\n    DeserializeError(serde_json::error::Error)\r\n}\r\n\r\nimpl\u003c'a\u003e fmt::Display for ResultArchivoAtenciones {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        match self {\r\n            ResultArchivoAtenciones::Read { atenciones } =\u003e {\r\n                write!(f, \"Archivo leído con éxito. Contiene {} atenciones.\", atenciones.len())\r\n            }\r\n            ResultArchivoAtenciones::Written { json } =\u003e {\r\n                write!(f, \"Archivo escrito con éxito. Contenido JSON: {}\", json)\r\n            }\r\n            ResultArchivoAtenciones::IOError(error) =\u003e {\r\n                write!(f, \"Error de E/S: {}\", error)\r\n            }\r\n            ResultArchivoAtenciones::SerializeError(error) =\u003e {\r\n                write!(f, \"Error al serializar: {}\", error)\r\n            }\r\n            ResultArchivoAtenciones::DeserializeError(error) =\u003e {\r\n                write!(f, \"Error al deserializar: {}\", error)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//\r\n// errores veterinaria\r\n//\r\n\r\n#[derive(Debug)]\r\npub enum ErrorNewVeterinaria {\r\n    VecColaCapacidad0,\r\n    VecAtencionesCapacidad0,\r\n    ArchivoAtenciones(ResultArchivoAtenciones)\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ResultAgregarMascota {\r\n    Exito,\r\n    ColaLlena{ capacity: usize },\r\n    ArchivoAtenciones(ResultArchivoAtenciones)\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ResultRemoverMascota\u003c'a\u003e {\r\n    Exito (Mascota),\r\n    ColaVacia { capacity: usize },\r\n    MascotaInexistente { nombre_mascota: \u0026'a str, nombre_dueno: \u0026'a str },\r\n    ArchivoAtenciones(ResultArchivoAtenciones),\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ResultAgregarAtencion {\r\n    Exito,\r\n    VectorLleno { capacity: usize},\r\n    ArchivoAtenciones(ResultArchivoAtenciones)\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ResultRemoverAtencion\u003c'a\u003e {\r\n    Exito(Atencion),\r\n    VectorVacio { capacity: usize },\r\n    AtencionInexistente { nombre_mascota: \u0026'a str, nombre_dueno: \u0026'a str, diagnostico: \u0026'a str },\r\n    ArchivoAtenciones(ResultArchivoAtenciones)\r\n}\r\n\r\n\r\n//\r\n// impl Veterinaria\r\n//\r\n\r\nimpl\u003c'a\u003e Veterinaria\u003c'a\u003e {\r\n\r\n    // ➔ crear una veterinaria.\r\n    pub fn new(\r\n        nombre: \u0026'a str,\r\n        direccion: \u0026'a str,\r\n        id: u64,\r\n        cola: Option\u003cVecDeque\u003cMascota\u003e\u003e,\r\n        atenciones: Option\u003cVec\u003cAtencion\u003e\u003e\r\n    ) -\u003e Result\u003cSelf, ErrorNewVeterinaria\u003e {\r\n        let cola = if let Some(cola) = cola {\r\n            if cola.capacity() == 0 { return Err(ErrorNewVeterinaria::VecColaCapacidad0) }\r\n            cola\r\n        } else { VecDeque::new() };\r\n\r\n        // si atenciones some(val) -\u003e crear un archivo que contenga val\r\n        // si atenciones none -\u003e intentar abrir el archivo y colocar su información en self.atenciones\r\n\r\n         let atenciones = if let Some(atenciones) = atenciones {\r\n             if atenciones.capacity() == 0 { return Err(ErrorNewVeterinaria::VecAtencionesCapacidad0)  }\r\n             sobreescribir_archivo_atenciones(nombre, \u0026atenciones);\r\n             atenciones\r\n         } else {\r\n             // leer o crear\r\n             match leer_archivo_atenciones(nombre) {\r\n                 ResultArchivoAtenciones::Read { atenciones } =\u003e { atenciones },\r\n                 error =\u003e return Err(ErrorNewVeterinaria::ArchivoAtenciones(error))\r\n             }\r\n         };\r\n\r\n        Ok(\r\n            Self { nombre, direccion, id, cola, atenciones }\r\n        )\r\n    }\r\n\r\n    // ➔ agregar una nueva mascota a la cola de atención de la veterinaria.\r\n    pub fn agregar_mascota(\u0026mut self, mascota: Mascota) -\u003e ResultAgregarMascota {\r\n        if self.cola.len() == self.cola.capacity() { return ResultAgregarMascota::ColaLlena { capacity: self.cola.capacity() } }\r\n        self.cola.push_back(mascota);\r\n        ResultAgregarMascota::Exito\r\n    }\r\n\r\n    // ➔ agregar una nueva mascota a la cola de atención pero que sea la siguiente en atender porque tiene la máxima prioridad.\r\n    pub fn agregar_mascota_prioridad(\u0026mut self, mascota: Mascota) -\u003e ResultAgregarMascota {\r\n        if self.cola.len() == self.cola.capacity() { return ResultAgregarMascota::ColaLlena { capacity: self.cola.capacity() } }\r\n        self.cola.push_front(mascota);\r\n        match sobreescribir_archivo_atenciones(self.nombre, \u0026self.atenciones) {\r\n            ResultArchivoAtenciones::Written { json: _ } =\u003e ResultAgregarMascota::Exito,\r\n            x =\u003e ResultAgregarMascota::ArchivoAtenciones(x)\r\n        }\r\n    }\r\n\r\n    // ➔ atender la próxima mascota de la cola.\r\n    pub fn atender_proxima_mascota(\u0026mut self) -\u003e ResultRemoverMascota {\r\n        if let Some(mascota) = self.cola.pop_front() { ResultRemoverMascota::Exito(mascota) }\r\n        else { ResultRemoverMascota::ColaVacia { capacity: self.cola.capacity() } }\r\n    }\r\n\r\n    // ➔ eliminar una mascota específica de la cola de atención dado que se retira.\r\n    pub fn eliminar_mascota(\u0026mut self, nombre_mascota: \u0026'a str, nombre_dueno: \u0026'a str) -\u003e ResultRemoverMascota {\r\n        let index = if let Some(index) = self.cola.iter().position(|m| m.nombre == nombre_mascota \u0026\u0026 m.dueno.nombre == nombre_dueno ) { index }\r\n        else { return ResultRemoverMascota::MascotaInexistente { nombre_mascota, nombre_dueno } };\r\n\r\n        if let Some(mascota) = self.cola.remove(index) {\r\n            ResultRemoverMascota::Exito(mascota)\r\n        } else {\r\n            ResultRemoverMascota::MascotaInexistente { nombre_mascota, nombre_dueno }\r\n        }\r\n    }\r\n\r\n    // ➔ registrar una atención.\r\n    pub fn registrar_atencion(\u0026mut self, atencion: Atencion) -\u003e ResultAgregarAtencion {\r\n        if self.atenciones.len() == self.atenciones.capacity() { return ResultAgregarAtencion::VectorLleno{ capacity: self.atenciones.capacity() } }\r\n        self.atenciones.push(atencion);\r\n\r\n        match sobreescribir_archivo_atenciones(\u0026self.nombre, \u0026self.atenciones) {\r\n            ResultArchivoAtenciones::Written { .. } =\u003e { ResultAgregarAtencion::Exito },\r\n            x =\u003e ResultAgregarAtencion::ArchivoAtenciones(x)\r\n        }\r\n    }\r\n\r\n    /// Searches for an Atencion by Mascota's name and Dueno's details.\r\n    ///\r\n    /// # Arguments\r\n    /// * `mascota_nombre` - The name of the Mascota.\r\n    /// * `dueno_nombre` - The name of the Dueno.\r\n    /// * `telefono` - The Dueno's phone number.\r\n    ///\r\n    /// # Returns\r\n    /// * `Some(\u0026Atencion)` - If an Atencion is found.\r\n    /// * `None` - If no match is found.\r\n    pub fn buscar_atencion(\u0026self, mascota_nombre: String, dueno_nombre: String, telefono: u64, ) -\u003e Option\u003c\u0026Atencion\u003e {\r\n        self.atenciones.iter().find(|atencion| {\r\n            atencion.mascota.nombre == mascota_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.nombre == dueno_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.telefono == telefono\r\n        })\r\n    }\r\n\r\n    // pub fn buscar_atencion_mut(\u0026mut self, mascota_nombre: String, dueno_nombre: String, telefono: u64, ) -\u003e Option\u003c\u0026mut Atencion\u003e {\r\n    //     self.atenciones.iter_mut().find(|atencion| {\r\n    //         atencion.mascota.nombre == mascota_nombre\r\n    //             \u0026\u0026 atencion.mascota.dueno.nombre == dueno_nombre\r\n    //             \u0026\u0026 atencion.mascota.dueno.telefono == telefono\r\n    //     }) // cómo hago para editar el archivo cuando se haya actualizado un \u0026mut Atencion?\r\n    //         // cómo hago para saber cuándo se edita con un préstamo mutable de un elemento?\r\n    //          // cómo hago para saber cuándo finaliza el préstamo mutable?\r\n    // }\r\n\r\n    pub fn buscar_atencion_mut(\u0026mut self, mascota_nombre: String, dueno_nombre: String, telefono: u64) -\u003e Option\u003c\u0026 mut Atencion\u003e {\r\n        self.atenciones.iter_mut().find(|atencion|\r\n            atencion.mascota.nombre == mascota_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.nombre == dueno_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.telefono == telefono)\r\n    }\r\n\r\n    /// Deletes an Atencion record from the Veterinaria records\r\n    ///\r\n    /// # Arguments\r\n    /// * `atencion` - A reference to the Atencion to delete\r\n    ///\r\n    /// # Returns\r\n    /// `Some(Atencion)` - The deleted Atencion\r\n    /// `None` - If no match is found\r\n    ///\r\n    /// # Notes\r\n    /// Requires `PartialEq` on Atencion for comparison\r\n    pub fn eliminar_atencion (\u0026mut self, nombre_mascota: \u0026'a str, nombre_dueno: \u0026'a str, diagnostico: \u0026'a str) -\u003e ResultRemoverAtencion {\r\n        if self.atenciones.len() == 0 {\r\n            return ResultRemoverAtencion::VectorVacio { capacity: self.atenciones.capacity() }\r\n        }\r\n\r\n        if let Some(index) = self.atenciones.iter().position( |a|\r\n                a.mascota.nombre == nombre_mascota\r\n             \u0026\u0026 a.mascota.dueno.nombre == nombre_dueno\r\n             \u0026\u0026 a.diagnostico == diagnostico) {\r\n\r\n            ResultRemoverAtencion::Exito(self.atenciones.remove(index))\r\n        } else {\r\n            ResultRemoverAtencion::AtencionInexistente { nombre_mascota, nombre_dueno, diagnostico }\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n//  atenciones file\r\n//\r\n\r\nfn archivo_atenciones_filepath(nombre_vet: \u0026str) -\u003e String {\r\n    format!(\"{}veterinaria_{}_atenciones.json\", BASE_FOLDER, nombre_vet)\r\n}\r\n\r\n//\r\n\r\nfn sobreescribir_archivo_atenciones(nombre_vet: \u0026str, atenciones: \u0026Vec\u003cAtencion\u003e) -\u003e ResultArchivoAtenciones {\r\n    // crear y/o escribir\r\n    // presupongo que la imposibilidad de persistir como archivo es un error semi-catastrófico\r\n    // semi-catastrófico == no runtime panic, pero se aborta la creación de la veterinaria\r\n    let json_data = match serde_json::to_string_pretty(atenciones) {\r\n        Ok(data) =\u003e { data }\r\n        Err(error) =\u003e { return ResultArchivoAtenciones::SerializeError(error) }\r\n    };\r\n\r\n    // escribir\r\n    match fs::write(archivo_atenciones_filepath(nombre_vet), json_data.clone()) {\r\n        Ok(_) =\u003e {  },\r\n        Err(error) =\u003e {\r\n            return ResultArchivoAtenciones::IOError(error)\r\n        }\r\n    };\r\n\r\n    // éxito\r\n    ResultArchivoAtenciones::Written { json: json_data }\r\n}\r\n\r\n//\r\n\r\nfn leer_archivo_atenciones(nombre_vet: \u0026str) -\u003e ResultArchivoAtenciones {\r\n    // leer\r\n    let mut file = match File::open(archivo_atenciones_filepath(nombre_vet)) {\r\n        Ok(file) =\u003e { file }\r\n        Err(error) =\u003e { return ResultArchivoAtenciones::IOError(error) }\r\n    };\r\n\r\n    let mut contents = String::new();\r\n    match file.read_to_string(\u0026mut contents) {\r\n        Ok(_) =\u003e {},\r\n        Err(error) =\u003e return ResultArchivoAtenciones::IOError(error)\r\n    };\r\n\r\n    let json_value: serde_json::Value = match serde_json::from_str(\u0026contents) {\r\n        Ok(value) =\u003e value,\r\n        Err(error) =\u003e return ResultArchivoAtenciones::DeserializeError(error),\r\n    };\r\n\r\n    let atenciones: Vec\u003cAtencion\u003e = match serde_json::from_value(json_value) {\r\n        Ok(atenciones) =\u003e atenciones,\r\n        Err(error) =\u003e return ResultArchivoAtenciones::DeserializeError(error),\r\n    };\r\n\r\n    ResultArchivoAtenciones::Read { atenciones }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::collections::VecDeque;\r\n    use crate::structs::atencion::{Animal, Dueno, Fecha};\r\n    use super::*;\r\n\r\n    fn veterinaria_de_pepe\u003c'a\u003e(capacidad: usize) -\u003e Veterinaria\u003c'a\u003e {\r\n        // Crear dueños\r\n        let dueno1 = Dueno {\r\n            nombre: \"Juan Pérez\".to_string(),\r\n            direccion: \"Calle 123\".to_string(),\r\n            telefono: 1234567890,\r\n        };\r\n        let dueno2 = Dueno {\r\n            nombre: \"María Gómez\".to_string(),\r\n            direccion: \"Avenida 456\".to_string(),\r\n            telefono: 9876543210,\r\n        };\r\n        let dueno3 = Dueno {\r\n            nombre: \"Carlos López\".to_string(),\r\n            direccion: \"Carrera 789\".to_string(),\r\n            telefono: 5555555555,\r\n        };\r\n\r\n        // Crear mascotas para la cola\r\n        let mascota1 = Mascota {\r\n            nombre: \"Max\".to_string(),\r\n            edad: 3,\r\n            animal: Animal::Perro,\r\n            dueno: dueno1,\r\n        };\r\n        let mascota2 = Mascota {\r\n            nombre: \"Luna\".to_string(),\r\n            edad: 2,\r\n            animal: Animal::Gato,\r\n            dueno: dueno2,\r\n        };\r\n        let mascota3 = Mascota {\r\n            nombre: \"Tormenta\".to_string(),\r\n            edad: 5,\r\n            animal: Animal::Caballo,\r\n            dueno: dueno3,\r\n        };\r\n\r\n        // Crear fechas para atenciones\r\n        let fecha1 = Fecha { dia: 15, mes: 10, ano: 2023 };\r\n        let fecha2 = Fecha { dia: 20, mes: 10, ano: 2023 };\r\n        let fecha3 = Fecha { dia: 25, mes: 10, ano: 2023 };\r\n\r\n        // Crear atenciones\r\n        let atencion1 = Atencion {\r\n            mascota: mascota1.clone(),\r\n            diagnostico: \"Resfriado leve\".to_string(),\r\n            tratamiento: \"Antibióticos\".to_string(),\r\n            proxima_visita: fecha1,\r\n        };\r\n        let atencion2 = Atencion {\r\n            mascota: mascota2.clone(),\r\n            diagnostico: \"Infección ocular\".to_string(),\r\n            tratamiento: \"Gotas\".to_string(),\r\n            proxima_visita: fecha2,\r\n        };\r\n        let atencion3 = Atencion {\r\n            mascota: mascota3.clone(),\r\n            diagnostico: \"Cojeo\".to_string(),\r\n            tratamiento: \"Reposo\".to_string(),\r\n            proxima_visita: fecha3,\r\n        };\r\n\r\n        let mut vec_cola: VecDeque\u003cMascota\u003e = VecDeque::with_capacity(capacidad);\r\n        vec_cola.push_back(mascota1);\r\n        vec_cola.push_back(mascota2);\r\n        vec_cola.push_back(mascota3);\r\n\r\n        // Crear la veterinaria con cola y atenciones\r\n        match Veterinaria::new (\r\n            \"Pepe's Pet Shop\",\r\n            \"Calle Principal 100\",\r\n             1,\r\n            Some(vec_cola),\r\n            Some(vec![atencion1, atencion2, atencion3]),\r\n        ) {\r\n            Ok(vet) =\u003e { vet }\r\n            Err(err) =\u003e { panic!(\"error: {:?}\", err) }\r\n        }\r\n    }\r\n\r\n    /*\r\n        let dueno1 = Dueno {\r\n            nombre: String::from(\"Juan Pérez\"),\r\n            direccion: String::from(\"Calle 123\"),\r\n            telefono: 1234567890,\r\n        };\r\n\r\n        let mascota1 = Mascota {\r\n            nombre: String::from(\"Max\"),\r\n            edad: 3,\r\n            animal: Animal::Perro,\r\n            dueno: dueno1,\r\n        };\r\n\r\n        let fecha1 = Fecha { dia: 15, mes: 10, ano: 2023 };\r\n\r\n        let atencion1 = Atencion {\r\n            mascota: mascota1.clone(),\r\n            diagnostico: String::from(\"Resfriado leve\"),\r\n            tratamiento: String::from(\"Antibióticos\"),\r\n            proxima_visita: fecha1,\r\n        };\r\n\r\n        Veterinaria {\r\n            nombre: String::from(\"Pepe's Pet Shop\"),\r\n            direccion: String::from(\"Calle Principal 100\"),\r\n            id: 1,\r\n            cola: VecDeque::from([mascota1, mascota2, mascota3]),\r\n            atenciones: vec![atencion1, atencion2, atencion3],\r\n        }\r\n     */\r\n\r\n    #[test]\r\n    fn test_atencion() {\r\n        let mut veterinaria = veterinaria_de_pepe(10);\r\n\r\n        // Verificar visualmente el contenido\r\n        println!(\"Veterinaria: {}\", veterinaria.nombre);\r\n        println!(\"Cola: {:?}\", veterinaria.cola);\r\n        println!(\"Atenciones: {:?}\", veterinaria.atenciones);\r\n\r\n        // Buscar\r\n\r\n        let atencion = veterinaria.buscar_atencion_mut(\"Max\".to_string(), \"Juan Pérez\".to_string(), 1234567890);\r\n        assert!(atencion.is_some(), \"La atención no puede no existir\");\r\n        let atencion = atencion.unwrap();\r\n\r\n        atencion.modificar_diagnostico_atencion(\"jijodebu en los jijolines jijox\".to_string());\r\n\r\n        println!(\"Atenciones: {:?}\", veterinaria.atenciones);\r\n    }\r\n\r\n    #[test]\r\n    fn test_agregar_eliminar() {\r\n        let mut veterinaria = veterinaria_de_pepe(10);\r\n\r\n        let dueno1 = Dueno {\r\n            nombre: \"Enrique Ibañez\".to_string(),\r\n            direccion: \"Calle 437\".to_string(),\r\n            telefono: 1234567890,\r\n        };\r\n\r\n        let mascota1 = Mascota {\r\n            nombre: \"Rodolfoasdasda\".to_string(),\r\n            edad: 72,\r\n            animal: Animal::Caballo,\r\n            dueno: dueno1,\r\n        };\r\n\r\n        match veterinaria.agregar_mascota(mascota1.clone()) {\r\n            ResultAgregarMascota::Exito =\u003e {},\r\n            ResultAgregarMascota::ColaLlena { capacity } =\u003e { panic!(\"No deberia estar llena. Capacidad: {}\", capacity) },\r\n            ResultAgregarMascota::ArchivoAtenciones(aa) =\u003e { panic!(\"e? {:?}\", aa) }\r\n        }\r\n\r\n        println!(\"{:?}\", veterinaria.cola);\r\n        assert_eq!(veterinaria.cola.len(), 4, \"Deberían haber 4 mascotas en total.\");\r\n\r\n        veterinaria.agregar_mascota_prioridad(mascota1.clone());\r\n        let prox_mascota = veterinaria.atender_proxima_mascota();\r\n\r\n        let mascota = match prox_mascota {\r\n            ResultRemoverMascota::Exito(mascota) =\u003e { mascota },\r\n            _ =\u003e panic!(\"deberia existir\")\r\n        };\r\n\r\n        assert_eq!(mascota, mascota1, \"La primer mascota en la fila debería ser la misma mascota que se agregó con prioridad\");\r\n\r\n        println!(\"{:?}\", veterinaria.eliminar_mascota(mascota1.nombre.as_str(), mascota1.dueno.nombre.as_str()));\r\n\r\n        assert_eq!(veterinaria.cola.len(), 3, \"La lista de mascotas debería haber vuelto a su estado original (3 items).\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_json() {\r\n        veterinaria_de_pepe(10); // creará el .json\r\n\r\n        match Veterinaria::new( // cargará el .json\r\n            \"Pepe's Pet Shop\",\r\n            \"asd\",\r\n            1,\r\n            None,\r\n            None\r\n        ) {\r\n            Ok(vet) =\u003e {\r\n                assert_eq!(vet.atenciones.len(), 3, \"deberían ser 3 según el archivo\");\r\n\r\n                for atencion in vet.atenciones {\r\n                    println!(\"{} ({}): {}\", atencion.mascota.nombre, atencion.mascota.edad, atencion.diagnostico)\r\n                }\r\n            }\r\n            Err(err) =\u003e { panic!(\"error new veterinaria: {:?}\", err) }\r\n        }\r\n    }\r\n}","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":66},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","main.rs"],"content":"// 4- En base al ejercicio 10 del tp#3 implemente lo siguiente:\n//  a- Realice todos los tests de la funcionalidad implementada obteniendo un coverage de por lo menos 90%\n//  b- Tanto los libros con sus copias como la administración de préstamos se realizan sobre archivos en formato JSON.\n//\n//      Realice las modificaciones pertinentes para poder hacerlo así.\n//      No debe modificar los tests hechos en el punto a.\n//      Si puede agregar más en caso de que haga métodos nuevos para cumplir con este punto.\n//      Recuerde también que se debe seguir manteniendo un coverage de al menos 90%.\n\nmod structs;\n\nfn main() {\n    \n\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","biblioteca.rs"],"content":"use std::collections::BTreeMap;\r\nuse crate::structs::cliente::Cliente;\r\nuse crate::structs::fecha::Fecha;\r\nuse crate::structs::prestamo::{EstadoPrestamo, Prestamo};\r\nuse super::libro::Libro;\r\n\r\n/// # Biblioteca\r\n///\r\n/// `nombre: String` - Nombre de la biblioteca\u003cbr\u003e\r\n/// `direccion: String` - Dirección física de la biblioteca\u003cbr\u003e\r\n/// `libros: BTreeMap\u003cu64, Libro\u003e` - Libros de la biblioteca\u003cbr\u003e\r\n/// `prestamos: BTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e` - \u003cb\u003e BTreeMap\u003cID del cliente, (Cliente, Vec\u003cPrestamo\u003e)\u003e\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Biblioteca {\r\n    pub nombre: String,\r\n    pub direccion: String,\r\n    pub libros: BTreeMap\u003cu64, Libro\u003e,\r\n    pub prestamos: BTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e // \u003cID cliente, (Cliente, Vec\u003cPréstamo\u003e)\u003e\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorDecrementarStock {\r\n    StockEsCero, LibroNoExiste\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorIncrementarStock {\r\n    LibroNoExiste, Overflow\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorRealizarPrestamo {\r\n    PrestamosMaximosAlcanzados, StockInsuficiente, LibroNoExiste\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorBuscarPrestamo {\r\n    PrestamoInexistente, ClienteInexistente\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorDevolverLibro {\r\n    PrestamoInexistente, ClienteInexistente, LibroYaDevuelto\r\n}\r\n\r\nimpl Biblioteca {\r\n\r\n    /// ### fn new() -\u003e Biblioteca\r\n    /// Crea una nueva instancia de biblioteca\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `nombre` - Nombre de la biblioteca\u003cbr\u003e\r\n    /// `direccion` - Dirección de la biblioteca\u003cbr\u003e\r\n    /// `libros` - Opcional: Lista de libros de la biblioteca\u003cbr\u003e\r\n    /// `prestamos` - Opcional: Lista de préstamos de la biblioteca\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Biblioteca` - Nueva instancia de Biblioteca\r\n    fn new(nombre: String, direccion: String, libros: Option\u003cBTreeMap\u003cu64, Libro\u003e\u003e, prestamos: Option\u003cBTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e\u003e) -\u003e Biblioteca {\r\n        Biblioteca {\r\n            nombre,\r\n            direccion,\r\n            libros: libros.unwrap_or_default(),\r\n            prestamos: prestamos.unwrap_or_default()\r\n        }\r\n    }\r\n\r\n    /// ### fn cantidad_de_copias_en_stock(isbn) -\u003e Option\u003cu32\u003e\r\n    /// Devuelve la cantidad de copias disponibles de un libro\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(u32)` - Cantidad (u32) de libros en stock\u003cbr\u003e\r\n    /// `None` - No existe el libro consultado\r\n    fn cantidad_de_copias_en_stock(\u0026self, isbn: u64) -\u003e Option\u003cu32\u003e {\r\n        self.libros.get(\u0026isbn).map(|libro| libro.stock)\r\n    }\r\n\r\n    /// ### fn decrementar_stock_libro(isbn) -\u003e Result\u003cu32, ErrorDecrementarStock\u003e\r\n    /// Devuelve la cantidad de libros en stock después de decrementarla en 1\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `u32` - Cantidad de libros después de decrementar\u003cbr\u003e\r\n    /// `ErrorDecrementarStock` - El stock es cero o el libro no existe\r\n    fn decrementar_stock_libro(\u0026mut self, isbn: u64) -\u003e Result\u003cu32, ErrorDecrementarStock\u003e {\r\n        match self.libros.get_mut(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == 0 {\r\n                    Err(ErrorDecrementarStock::StockEsCero)\r\n                } else {\r\n                    libro.stock-= 1;\r\n                    Ok(libro.stock)\r\n                }\r\n            },\r\n            None =\u003e Err(ErrorDecrementarStock::LibroNoExiste)\r\n        }\r\n    }\r\n\r\n\r\n    /// ### fn incrementar_stock_libro(isbn) -\u003e Result\u003cu32, ErrorIncrementarStock\u003e\r\n    /// Devuelve la cantidad de libros en stock después de incrementarla en 1\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `u32` - Cantidad de libros después de decrementar\u003cbr\u003e\r\n    /// `ErrorIncrementarStock` - El stock es `u32::MAX` o el libro no existe\r\n    fn incrementar_stock_libro(\u0026mut self, isbn: u64) -\u003e Result\u003cu32, ErrorIncrementarStock\u003e {\r\n        match self.libros.get_mut(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == u32::MAX {\r\n                    Err(ErrorIncrementarStock::Overflow)\r\n                } else {\r\n                    libro.stock+= 1;\r\n                    Ok(libro.stock)\r\n                }\r\n            },\r\n            None =\u003e Err(ErrorIncrementarStock::LibroNoExiste)\r\n        }\r\n    }\r\n\r\n    /// ### fn cantidad_prestamos_cliente(cliente) -\u003e Option\u003cusize\u003e\r\n    /// Devuelve la cantidad de préstamos efectuados a un cliente\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `cliente` - ID del cliente a consultar\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(usize)` - Cantidad de préstamos efectuados al cliente\u003cbr\u003e\r\n    /// `None` - El cliente no existe\r\n    fn cantidad_prestamos_cliente(\u0026self, cliente: u32) -\u003e Option\u003cusize\u003e {\r\n        // match self.prestamos.get(cliente) {\r\n        //     Some(cliente) =\u003e {\r\n        //         Some(cliente.len())\r\n        //     },\r\n        //     None =\u003e None\r\n        // }\r\n\r\n        self.prestamos.get(\u0026cliente).map(|cliente| cliente.1.len()) // compiler suggestion\r\n    }\r\n\r\n    /// ### fn cantidad_stock_libro(isbn) -\u003e Option\u003cu32\u003e\r\n    /// Devuelve la cantidad de libros en stock del libro consultado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(u32)` - Cantidad de libros en stock\u003cbr\u003e\r\n    /// `None` - El libro no existe\r\n    fn cantidad_stock_libro(\u0026self, isbn: u64) -\u003e Option\u003cu32\u003e {\r\n        self.libros.get(\u0026isbn).map(|libro| libro.stock) // compiler suggestion\r\n    }\r\n\r\n    /// ### fn realizar_prestamo(cliente, isbn, vencimiento) -\u003e Result(usize, ErrorRealizarPrestamo)\r\n    /// Realiza un préstamo del libro en nombre del cliente con el vencimiento especificado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `cliente` - Cliente a efectuar el préstamo\u003cbr\u003e\r\n    /// `isbn` - ID del libro a prestar\u003cbr\u003e\r\n    /// `vencimiento` - Fecha de vencimiento del préstamo\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `usize` - Cantidad de préstamos del cliente, incluyendo el recién realizado\r\n    fn realizar_prestamo(\u0026mut self, cliente: Cliente, isbn: u64, vencimiento: Fecha) -\u003e Result\u003cusize, ErrorRealizarPrestamo\u003e /* \u003cCant. préstamos del cliente, Error\u003e */ {\r\n        match self.libros.get(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == 0 {\r\n                    return Err(ErrorRealizarPrestamo::StockInsuficiente)\r\n                }\r\n            },\r\n            None =\u003e return Err(ErrorRealizarPrestamo::LibroNoExiste)\r\n        }\r\n\r\n        let prestamo = Prestamo::new(isbn, cliente.id, vencimiento, None, EstadoPrestamo::Prestando);\r\n\r\n        match self.prestamos.get_mut(\u0026cliente.id) {\r\n            Some(dato) =\u003e {\r\n                let cant_libros_no_devueltos = dato.1.iter().filter(|p| p.devolucion.is_none() \u0026\u0026 p.estado == EstadoPrestamo::Prestando).count();\r\n                if cant_libros_no_devueltos \u003e= 5 {\r\n                    return Err(ErrorRealizarPrestamo::PrestamosMaximosAlcanzados);\r\n                }\r\n\r\n                // si el préstamo alguna vez se realizó, eliminar el antiguo préstamo\r\n                dato.1.retain(|p| p.isbn != isbn);\r\n\r\n                // quitar stock al libro a prestar\r\n                // no puedo usar self.decrementar_stock_libro() porque tendría 2 borrows mutables en simultáneo\r\n                if let Some(libro) = self.libros.get_mut(\u0026isbn) { libro.stock-= 1 } // compiler suggestion\r\n\r\n                dato.1.push(prestamo);\r\n                Ok(cant_libros_no_devueltos)\r\n            },\r\n            None =\u003e {\r\n                // insertar cliente\r\n                self.prestamos.insert(cliente.id, (cliente, vec![prestamo]));\r\n                self.decrementar_stock_libro(isbn);\r\n                Ok(1)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// ### fn prestamos_a_vencer(feca_hoy, dias) -\u003e Vec\u003c\u0026Prestamo\u003e\r\n    /// Devuelve un Vec\u003c\u0026Prestamo\u003e con los préstamos a vencer en los próximos `dias` días\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `fecha_hoy` - Fecha del día de hoy\u003cbr\u003e\r\n    /// `dias` - Días en los que vencerán los préstamos devueltos\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Vec\u003c\u0026Prestamo\u003e` - Los préstamos que vencerán en los próximos `dias` días\r\n    fn prestamos_por_vencer(\u0026self, fecha_hoy: Fecha, dias: u32) -\u003e Vec\u003c\u0026Prestamo\u003e {\r\n        let mut prestamos_por_vencer: Vec\u003c\u0026Prestamo\u003e = Vec::new();\r\n\r\n        let mut fecha_limte = fecha_hoy;\r\n        fecha_limte.sumar_dias(dias);\r\n        let fecha_limite = fecha_limte; // quitar mutabilidad\r\n\r\n        for prestamos_cliente in self.prestamos.values() {\r\n            for prestamo in \u0026prestamos_cliente.1 {\r\n\r\n                match \u0026prestamo.devolucion {\r\n                    Some(_) =\u003e continue, // ya fue devuelto, no contabilizar\r\n                    None =\u003e {\r\n                        if prestamo.devolucion.is_none() \u0026\u0026 prestamo.estado == EstadoPrestamo::Prestando \u0026\u0026 prestamo.vencimiento \u003c= fecha_limite {\r\n                            prestamos_por_vencer.push(prestamo);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        prestamos_por_vencer\r\n    }\r\n\r\n    /// ### fn prestamos_vencidos(fecha_hoy) -\u003e Vec\u003c\u0026Prestamo\u003e\r\n    /// Devuelve los prestamos que hayan vencido\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `fecha_hoy` - La fecha de hoy\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Vec\u003c\u0026Prestamo\u003e` - Los préstamos que han vencido\r\n    fn prestamos_vencidos(\u0026self, fecha_hoy: Fecha) -\u003e Vec\u003c\u0026Prestamo\u003e {\r\n        let mut prestamos_vencidos: Vec\u003c\u0026Prestamo\u003e = Vec::new();\r\n\r\n        for prestamos_cliente in self.prestamos.values() {\r\n            for prestamo in \u0026prestamos_cliente.1 {\r\n                if prestamo.estado == EstadoPrestamo::Prestando \u0026\u0026 prestamo.vencimiento \u003c fecha_hoy {\r\n                    prestamos_vencidos.push(prestamo);\r\n                }\r\n            }\r\n        }\r\n\r\n        prestamos_vencidos\r\n    }\r\n\r\n    /// ### fn buscar_prestamo(isbn, id_cliente) -\u003e Result\u003c\u0026Prestamo, ErrorBuscarPrestamo\u003e\r\n    /// Devuelve un préstamo en específico\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro prestado\u003cbr\u003e\r\n    /// `id_cliente` - ID del cliente del préstamo\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `\u0026Prestamo` - El préstamo buscado\u003cbr\u003e\r\n    /// `ErrorBuscarPrestamo` - El préstamo o el cliente no existen\r\n    fn buscar_prestamo(\u0026self, isbn: u64, id_cliente: u32) -\u003e Result\u003c\u0026Prestamo, ErrorBuscarPrestamo\u003e {\r\n        match self.prestamos.get(\u0026id_cliente) {\r\n            Some(dato) =\u003e {\r\n                for prestamo in \u0026dato.1 {\r\n                    if prestamo.isbn == isbn { return Ok(prestamo) }\r\n                }\r\n                    Err(ErrorBuscarPrestamo::PrestamoInexistente)\r\n            },\r\n            None =\u003e Err(ErrorBuscarPrestamo::ClienteInexistente)\r\n        }\r\n    }\r\n\r\n    /// ### fn devolver_libro(isbn, id_cliente, fecha_hoy) -\u003e Result\u003c\u0026Prestamo, ErrorDevolverLibro\u003e\r\n    /// Realiza la devolución del libro especificado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a devolver\u003cbr\u003e\r\n    /// `id_cliente` - ID del cliente que devuelve\u003cbr\u003e\r\n    /// `fecha_hoy` - La fecha de hoy\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `\u0026Prestamo` - El préstamo del libro que se ha devuelto\u003cbr\u003e\r\n    /// `ErrorDevolverLibro` - El cliente o el préstamo no existen o ya fue devuelto\r\n    fn devolver_libro(\u0026mut self, isbn: u64, id_cliente: u32, fecha_hoy: Fecha) -\u003e Result\u003c\u0026Prestamo, ErrorDevolverLibro\u003e {\r\n        match self.prestamos.get_mut(\u0026id_cliente) {\r\n            Some(dato) =\u003e {\r\n                for prestamo in dato.1.iter_mut() {\r\n                    if prestamo.isbn == isbn {\r\n                        if prestamo.estado == EstadoPrestamo::Devuelto {\r\n                            return Err(ErrorDevolverLibro::LibroYaDevuelto)\r\n                        }\r\n\r\n                        prestamo.devolucion = Some(fecha_hoy);\r\n                        prestamo.estado = EstadoPrestamo::Devuelto;\r\n\r\n                        // no puedo usar self.incrementar_stock_libro() porque tendría 2 borrows mutables en simultáneo\r\n                        if let Some(libro) = self.libros.get_mut(\u0026isbn) { libro.stock-= 1 }\r\n\r\n                        return Ok(prestamo)\r\n                    }\r\n                }\r\n                Err(ErrorDevolverLibro::PrestamoInexistente)\r\n            },\r\n            None =\u003e Err(ErrorDevolverLibro::ClienteInexistente)\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::collections::BTreeMap;\r\n    use crate::structs::biblioteca::{Biblioteca, ErrorDecrementarStock, ErrorIncrementarStock, ErrorRealizarPrestamo};\r\n    use crate::structs::cliente::Cliente;\r\n    use crate::structs::fecha::Fecha;\r\n    use crate::structs::libro::{Genero, Libro};\r\n    use crate::structs::prestamo::EstadoPrestamo;\r\n\r\n    fn biblioteca_de_pepe() -\u003e Biblioteca {\r\n        Biblioteca::new(\r\n            \"biblio de pepe\".to_string(),\r\n            \"donde queda\".to_string(),\r\n            Some(BTreeMap::from(\r\n                [(1, libro_economia_1()),\r\n                    (2, libro_xd_2()),\r\n                    (3, libro_harrypotter_3()),\r\n                    (4, libro_asd_4()),\r\n                    (5, libro_estadistica_5()),\r\n                    (u32::MAX as u64, libro_algo_u32max())])),\r\n            None)\r\n    }\r\n    fn cliente_pepe() -\u003e Cliente {\r\n        Cliente::new(\r\n            1,\r\n            \"pepe\".to_string(),\r\n            \"123\".to_string(),\r\n            \"pepe@gmail.com\".to_string()\r\n        )\r\n    }\r\n    fn cliente_manuel() -\u003e Cliente {\r\n        Cliente::new(\r\n            3,\r\n            \"manuel\".to_string(),\r\n            \"123\".to_string(),\r\n            \"manuel@gmail.com\".to_string()\r\n        )\r\n    }\r\n    fn libro_economia_1() -\u003e Libro {\r\n        Libro::new(\r\n            1,\r\n            \"Economía en una lección\".to_string(),\r\n            \"xd\".to_string(),\r\n            1,\r\n            Genero::Tecnico,\r\n            1\r\n        )\r\n    }\r\n    fn libro_xd_2() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 2;\r\n        libro.titulo = \"xd\".to_string();\r\n        libro.stock = 2;\r\n        libro\r\n    }\r\n    fn libro_harrypotter_3() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 3;\r\n        libro.titulo = \"Harry Potter y qsy q mas\".to_string();\r\n        libro.stock = 3;\r\n        libro\r\n    }\r\n    fn libro_asd_4() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 4;\r\n        libro.titulo = \"asd\".to_string();\r\n        libro.stock = 4;\r\n        libro\r\n    }\r\n    fn libro_estadistica_5() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 5;\r\n        libro.titulo = \"Estadística\".to_string();\r\n        libro.stock = 5;\r\n        libro\r\n    }\r\n    fn libro_algo_u32max() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = u32::MAX as u64;\r\n        libro.titulo = \"algo\".to_string();\r\n        libro.stock = u32::MAX;\r\n        libro\r\n    }\r\n\r\n    #[test]\r\n    fn test_cant_copias() {\r\n        let mut biblioteca = biblioteca_de_pepe();\r\n\r\n        // test dec\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 5, \"ISBN 5 tiene 5 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 3, \"ISBN 3 tiene 3 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 1, \"ISBN 1 tiene 1 copias\");\r\n\r\n        biblioteca.decrementar_stock_libro(5);\r\n        biblioteca.decrementar_stock_libro(3);\r\n        biblioteca.decrementar_stock_libro(1);\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 4, \"ISBN 5 tiene 4 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 2, \"ISBN 3 tiene 2 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 0, \"ISBN 1 tiene 0 copias\");\r\n\r\n        // test inc\r\n\r\n        biblioteca.incrementar_stock_libro(5);\r\n        biblioteca.incrementar_stock_libro(3);\r\n        biblioteca.incrementar_stock_libro(1);\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 5, \"ISBN 5 tiene 5 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 3, \"ISBN 3 tiene 3 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 1, \"ISBN 1 tiene 1 copias\");\r\n\r\n        // test 0\r\n\r\n        biblioteca.decrementar_stock_libro(1);\r\n\r\n        biblioteca.decrementar_stock_libro(5);\r\n        biblioteca.decrementar_stock_libro(3);\r\n        let dec = biblioteca.decrementar_stock_libro(1);\r\n\r\n        assert_eq!(dec.unwrap_err(), ErrorDecrementarStock::StockEsCero, \"stock debería ser cero\");\r\n\r\n        // test overflow\r\n\r\n        let inc = biblioteca.incrementar_stock_libro(u32::MAX as u64);\r\n        assert_eq!(inc.unwrap_err(), ErrorIncrementarStock::Overflow, \"stock debería ser u32::MAX\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_prestamos() {\r\n        let mut biblioteca = biblioteca_de_pepe();\r\n\r\n        // init realizar prestamos\r\n\r\n        let fecha5 = Fecha{ dia: 1, mes: 1, ano: 1 };\r\n        let fecha3 = Fecha{ dia: 2, mes: 1, ano: 1 };\r\n\r\n        let p5 = biblioteca.realizar_prestamo(cliente_pepe(), 5, fecha5.clone());\r\n        let p3 = biblioteca.realizar_prestamo(cliente_manuel(), 3, fecha3.clone());\r\n\r\n        // check\r\n\r\n        if p5.is_err() { panic!(\"Error inesperado realizando préstamo: {:?}\", p5.unwrap_err()) }\r\n        if p3.is_err() { panic!(\"Error inesperado realizando préstamo: {:?}\", p3.unwrap_err()) }\r\n\r\n        assert_eq!(p5.unwrap(), 1, \"Debería tener 1 préstamo\");\r\n        assert_eq!(p3.unwrap(), 1, \"Debería tener 1 préstamo\");\r\n\r\n        // init cant copias\r\n\r\n        let stock5 = biblioteca.cantidad_de_copias_en_stock(5);\r\n        let stock3 = biblioteca.cantidad_de_copias_en_stock(3);\r\n\r\n        // check\r\n\r\n        if stock5.is_none() { panic!(\"cantidad_de_copias_en_strock(): None\") }\r\n        if stock3.is_none() { panic!(\"cantidad_de_copias_en_strock(): None\") }\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 4, \"Deberían haber 4 copias en stock\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 2, \"Deberían haber 2 copias en stock\");\r\n\r\n        // init prestamos por vencer\r\n\r\n        let prestamos_a_vencer0 = biblioteca.prestamos_por_vencer(Fecha { dia: 1, mes: 1, ano: -1 }, 0);\r\n        let prestamos_a_vencer1 = biblioteca.prestamos_por_vencer(fecha5.clone(), 0);\r\n        let prestamos_a_vencer2 = biblioteca.prestamos_por_vencer(fecha5.clone(), 1);\r\n        let prestamos_a_vencer2_2 = biblioteca.prestamos_por_vencer(Fecha { dia: 22, mes: 08, ano: 2002 }, 0);\r\n\r\n        // check\r\n\r\n        assert_eq!(prestamos_a_vencer0.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer1.len(), 1, \"Debería haber 1 préstamo a vencer\");\r\n        assert_eq!(prestamos_a_vencer2.len(), 2, \"Deberían haber 2 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2_2.len(), 2, \"Deberían haber 0 préstamos a vencer\");\r\n\r\n        // init buscar prestamos\r\n\r\n        let buscar_prestamo5 = biblioteca.buscar_prestamo(5, cliente_pepe().id);\r\n        let buscar_prestamo3 = biblioteca.buscar_prestamo(3, cliente_manuel().id);\r\n\r\n        // check\r\n\r\n        if buscar_prestamo5.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo5.unwrap_err()) }\r\n        if buscar_prestamo3.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo3.unwrap_err()) }\r\n\r\n        assert_eq!(buscar_prestamo5.unwrap().isbn, 5, \"El préstamo encontrado debería ser sobre el libro #5\");\r\n        assert_eq!(buscar_prestamo3.unwrap().isbn, 3, \"El préstamo encontrado debería ser sobre el libro #3\");\r\n\r\n        // init-check devolver prestamos\r\n\r\n        let devolucion_prestamo5 = biblioteca.devolver_libro(5, cliente_pepe().id, fecha5.clone());\r\n        if devolucion_prestamo5.is_err() { panic!(\"\") }\r\n\r\n        let devolucion_prestamo3 = biblioteca.devolver_libro(3, cliente_manuel().id, fecha3.clone());\r\n        if devolucion_prestamo3.is_err() { panic!(\"\") }\r\n\r\n        // init prestamos por vencer post-devolver\r\n\r\n        let prestamos_a_vencer0 = biblioteca.prestamos_por_vencer(Fecha { dia: 1, mes: 1, ano: -1 }, 0);\r\n        let prestamos_a_vencer1 = biblioteca.prestamos_por_vencer(fecha5.clone(), 0);\r\n        let prestamos_a_vencer2 = biblioteca.prestamos_por_vencer(fecha5.clone(), 1);\r\n        let prestamos_a_vencer2_2 = biblioteca.prestamos_por_vencer(Fecha { dia: 22, mes: 08, ano: 2002 }, 0);\r\n\r\n        // check\r\n\r\n        assert_eq!(prestamos_a_vencer0.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer1.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2_2.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n\r\n        // init buscar prestamos post-devolver\r\n\r\n        let buscar_prestamo5 = biblioteca.buscar_prestamo(5, cliente_pepe().id);\r\n        let buscar_prestamo3 = biblioteca.buscar_prestamo(3, cliente_manuel().id);\r\n\r\n        // check\r\n\r\n        if buscar_prestamo5.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo5.unwrap_err()) }\r\n        if buscar_prestamo3.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo3.unwrap_err()) }\r\n\r\n        assert_eq!(buscar_prestamo5.clone().unwrap().isbn, 5, \"El préstamo encontrado debería ser sobre el libro #5\");\r\n        assert_eq!(buscar_prestamo3.clone().unwrap().isbn, 3, \"El préstamo encontrado debería ser sobre el libro #3\");\r\n\r\n        assert_eq!(buscar_prestamo5.clone().unwrap().estado, EstadoPrestamo::Devuelto, \"El préstamo encontrado debería haber sido devuelto\");\r\n        assert_eq!(buscar_prestamo3.clone().unwrap().estado, EstadoPrestamo::Devuelto, \"El préstamo encontrado debería haber sido devuelto\");\r\n\r\n        assert!(buscar_prestamo5.unwrap().devolucion.is_some(), \"El préstamo encontrado debería haber sido devuelto\");\r\n        assert!(buscar_prestamo3.unwrap().devolucion.is_some(), \"El préstamo encontrado debería haber sido devuelto\");\r\n\r\n        // init max prestamos (5)\r\n\r\n        let p1 = biblioteca.realizar_prestamo(cliente_pepe(), 1, fecha5.clone());\r\n        let p2 = biblioteca.realizar_prestamo(cliente_pepe(), 2, fecha5.clone());\r\n        let p3 = biblioteca.realizar_prestamo(cliente_pepe(), 3, fecha5.clone());\r\n        let p4 = biblioteca.realizar_prestamo(cliente_pepe(), 4, fecha5.clone());\r\n        let p5 = biblioteca.realizar_prestamo(cliente_pepe(), 5, fecha5.clone());\r\n\r\n        let p6 = biblioteca.realizar_prestamo(cliente_pepe(), u32::MAX as u64, fecha3.clone());\r\n\r\n        // check\r\n\r\n        assert!(p1.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p2.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p3.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p4.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p5.is_ok(), \"El préstamo debería ser exitoso\");\r\n\r\n        assert!(p6.is_err(), \"El préstamo no debería ser exitoso\");\r\n        assert_eq!(p6.unwrap_err(), ErrorRealizarPrestamo::PrestamosMaximosAlcanzados, \"Debería haberse alcanzado el límite máximo de préstamos\");\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","cliente.rs"],"content":"/// Del cliente se conoce:\r\n///     el nombre,\r\n///     teléfono\r\n///     y dirección de correo electrónico.\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Cliente {\r\n    pub id: u32,\r\n    pub nombre: String,\r\n    pub telefono: String,\r\n    pub email: String,\r\n}\r\n\r\nimpl Cliente {\r\n    pub fn new(id: u32, nombre: String, telefono: String, email: String) -\u003e Cliente {\r\n        Cliente { id, nombre, telefono, email }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","fecha.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct Fecha {\r\n    pub(crate) dia: u8,\r\n    pub(crate) mes: u8,\r\n    pub(crate) ano: i64\r\n}\r\n\r\nimpl Default for Fecha {\r\n    fn default() -\u003e Self {\r\n        Fecha { dia: 1, mes: 1, ano: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Fecha {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.dia == other.dia\r\n            \u0026\u0026 self.mes == other.mes\r\n            \u0026\u0026 self.ano == other.ano\r\n        { return Some(Equal) }\r\n\r\n        if self.ano \u003e other.ano { return Some(Greater) }\r\n        if self.mes \u003e other.mes { return Some(Greater) }\r\n        if self.dia \u003e other.dia { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cFecha\u003e {\r\n        let fecha = Fecha { dia, mes, ano };\r\n        if fecha.es_fecha_valida() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia == 0\r\n            || self.dia \u003e self.dias_mes_actual()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n\r\n    pub fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n\r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use std::fmt::{format, Display};\r\n    use crate::structs::fecha::{Fecha, NOMBRE_MESES};\r\n\r\n    #[test]\r\n    fn test_default() {\r\n        // default: 01/01/0000\r\n        let default_fecha = Fecha::default();\r\n        assert_eq!(default_fecha.dia, 1);\r\n        assert_eq!(default_fecha.mes, 1);\r\n        assert_eq!(default_fecha.ano, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_display() {\r\n        let valid_fecha = Fecha::default();\r\n        let invalid_fecha = Fecha { dia: 0, mes: 1, ano: 0 };\r\n        \r\n        // write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        \r\n        assert_ne!(format!(\"{}\", valid_fecha), format!(\"{}\", invalid_fecha));\r\n        assert_eq!(format!(\"{}\", valid_fecha), format!(\"{} de {} del {}\", valid_fecha.dia, NOMBRE_MESES[valid_fecha.mes as usize - 1], valid_fecha.ano));\r\n        assert_eq!(format!(\"{}\", invalid_fecha), format!(\"{}/{}/{}\", invalid_fecha.dia, invalid_fecha.mes, invalid_fecha.ano))\r\n    }\r\n    \r\n    #[test]\r\n    fn test_new() {\r\n        // invalida\r\n        let fecha = Fecha::new(0, 0, 0);\r\n        assert!(fecha.is_none());\r\n        \r\n        // valida\r\n        let fecha = Fecha::new(22, 08, 2002);\r\n        assert!(fecha.is_some());\r\n    }\r\n    \r\n    #[test]\r\n    fn test_bisiesto() {\r\n        let fecha = Fecha::new(1, 1, 0).unwrap();\r\n        assert!(fecha.es_bisiesto());\r\n\r\n        let fecha = Fecha::new(1, 1, 2000).unwrap();\r\n        assert!(fecha.es_bisiesto());\r\n\r\n        let fecha = Fecha::new(1, 1, -4).unwrap();\r\n        assert!(fecha.es_bisiesto());\r\n\r\n        let fecha = Fecha::new(1, 1, 1).unwrap();\r\n        assert!(!fecha.es_bisiesto());\r\n    }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","libro.rs"],"content":"/// De cada libro se conoce:\r\n///     el título,\r\n///     autor,\r\n///     número de páginas,\r\n///     género (novela, infantil, técnico, otros).\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub(crate) struct Libro {\r\n    pub isbn: u64,\r\n    pub titulo: String,\r\n    pub autor: String,\r\n    pub paginas: u16,\r\n    pub genero: Genero,\r\n    pub stock: u32\r\n}\r\n\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub enum Genero {\r\n    Novela, Infantil, Tecnico, #[default] Otros\r\n}\r\n\r\nimpl Libro {\r\n    pub fn new(isbn: u64, titulo: String, autor: String, paginas: u16, genero: Genero, stock: u32) -\u003e Self {\r\n        Self { isbn, titulo, autor, paginas, genero, stock }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","mod.rs"],"content":"pub mod prestamo;\r\npub mod biblioteca;\r\npub mod cliente;\r\npub mod libro;\r\npub mod fecha;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","prestamo.rs"],"content":"use crate::structs::fecha::Fecha;\r\n\r\n/// Para registrar un préstamo se requiere:\r\n///     el libro,\r\n///     el cliente,\r\n///     la fecha de vencimiento del préstamo,\r\n///     la fecha de devolución\r\n///     y el estado (devuelto o en préstamo)\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Prestamo {\r\n    pub isbn: u64, // isbn\r\n    pub cliente: u32, // id\r\n    pub vencimiento: Fecha,\r\n    pub devolucion: Option\u003cFecha\u003e,\r\n    pub estado: EstadoPrestamo\r\n}\r\n\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub enum EstadoPrestamo {\r\n    Devuelto, #[default] Prestando\r\n}\r\n\r\nimpl Prestamo {\r\n    \r\n    pub fn new(isbn: u64, cliente: u32, vencimiento: Fecha, devolucion: Option\u003cFecha\u003e, estado: EstadoPrestamo) -\u003e Prestamo {\r\n        Prestamo { isbn, cliente, vencimiento, devolucion, estado }\r\n    }\r\n    \r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","target","debug","build","mime_guess-2521a3dfd26120e6","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","target","debug","build","mime_guess-354e957788aeeb2d","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","target","debug","build","mime_guess-6d2f70cc5ef81be4","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","src","main.rs"],"content":"fn main() {}","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1}]};
        var previousData = {"files":[{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej1","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let num: f32 = 13548.0;\r\n    println!(\"El número a operar es {}\", num);\r\n    const FLOAT_ERROR_MSG: \u0026str = \"Error convirtiendo input (\u0026str) en f32\";\r\n\r\n    println!(\"Ingrese un número (f32) para sumar al operador:\");\r\n    let num_suma = leer_float(FLOAT_ERROR_MSG);\r\n\r\n    println!(\"Ingrese un número (f32) para restar al operador:\");\r\n    let num_resta = leer_float(FLOAT_ERROR_MSG);\r\n\r\n    println!(\"Ingrese un número (f32) para multiplicar al operador:\");\r\n    let num_mul = leer_float(FLOAT_ERROR_MSG);\r\n\r\n    println!(\"Ingrese un número (f32) para dividir al operador:\");\r\n    let num_div = leer_float(FLOAT_ERROR_MSG);\r\n\r\n    println!(\"Suma: {num} + {num_suma} = {}\", num + num_suma);\r\n    println!(\"Resta: {num} - {num_resta} = {}\", num - num_resta);\r\n    println!(\"Multiplicación: {num} * {num_mul} = {}\", num * num_mul);\r\n    println!(\"División: {num} / {num_div} = {}\", num / num_div);\r\n}\r\n\r\nfn leer_float(panic_msg: \u0026str) -\u003e f32{\r\n    let mut inp: String = String::new();\r\n    stdin().read_line(\u0026mut inp).expect(\"String input\");\r\n    match inp.trim().parse::\u003cf32\u003e() {\r\n        Ok(num) =\u003e num,\r\n        _ =\u003e panic!(\"{}\", panic_msg)\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej10","main.rs"],"content":"fn main() {\r\n    let arr1 = [1, 2, 3, 4, 5];\r\n    let arr2 = [2, 3, 4, 5, 6];\r\n    let mut arr3: Vec\u003ci32\u003e = Vec::with_capacity(5);\r\n\r\n    for i in 0..5 {\r\n        arr3[i] = arr1[i] + arr2[i];\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej11","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let arr: [\u0026str; 5] = [\"hola\", \"mundo\", \"como\", \"estas\", \"hoy\"];\r\n    let mut cadena = String::new();\r\n\r\n    println!(\"Ingrese una cadena:\");\r\n    stdin().read_line(\u0026mut cadena).unwrap();\r\n\r\n    if arr.contains(\u0026cadena.trim()) {\r\n        println!(\"La cadena se encuentra en el arreglo.\");\r\n    } else {\r\n        println!(\"La cadena no se encuentra en el arreglo.\");\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej12","main.rs"],"content":"fn main() {\r\n    let t: (\u0026str, Vec\u003cu32\u003e) = (\"josejuanjo\", [1, 2, 3, 4, 5].to_vec());\r\n\r\n    let suma: u32 = t.1.iter().sum();\r\n\r\n    println!(\"{} {}\", t.0, suma);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej2","main.rs"],"content":"fn main() {\r\n    let mi_var: u32 = 15*16*16*16; // 61440\r\n    let mi_var_hex = u32_to_hex(mi_var); // F000\r\n\r\n    println!(\"MiVar: {mi_var}, MiVarHex: {mi_var_hex}\");\r\n}\r\n\r\nfn u32_to_hex(num: u32) -\u003e String {\r\n    // convert num into hex string\r\n    format!(\"{:X}\", num)\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej3","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let mi_bool = true;\r\n\r\n    println!(\"{mi_bool} AND?\");\r\n    let bool_and = leer_bool();\r\n\r\n    println!(\"{mi_bool} OR?\");\r\n    let bool_or = leer_bool();\r\n\r\n    println!(\"{mi_bool} AND {bool_and} = {}\", mi_bool \u0026\u0026 bool_and);\r\n    println!(\"{mi_bool} OR {bool_or} = {}\", mi_bool || bool_or);\r\n}\r\n\r\nfn leer_bool() -\u003e bool {\r\n    let mut input = String::new();\r\n    stdin().read_line(\u0026mut input).expect(\"bool input\");\r\n    input.trim().parse::\u003cbool\u003e().unwrap()\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej4","main.rs"],"content":"fn main() {\r\n    let mi_tupla = (\"ohmama\", 13658, false);\r\n    println!(\"Impresión directa: {mi_tupla:?}\");\r\n    println!(\"Impresión individual: {}, {}, {}\", mi_tupla.0, mi_tupla.1, mi_tupla.2);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej5","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let cadena = \"asd \";\r\n    // concatenar:\r\n\r\n    let mut input = String::new();\r\n    stdin().read_line(\u0026mut input).expect(\"String input\");\r\n\r\n    let cadena = cadena.to_string() + \u0026input;\r\n\r\n    println!(\"{}\", cadena.to_uppercase());\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej6","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let num: u32 = 13548;\r\n    println!(\"El número a operar es {}\", num);\r\n\r\n    let mut input = String::new();\r\n\r\n    println!(\"Ingrese un número (u32) para sumar al operador:\");\r\n    stdin().read_line(\u0026mut input).expect(\"u32 input\");\r\n    let num_suma = input.trim().parse::\u003cu32\u003e().unwrap();\r\n\r\n    let suma = num + num_suma;\r\n    let cuadrado = suma.pow(2);\r\n\r\n    println!(\"Suma: {}\", suma);\r\n    println!(\"Cuadrado: {}\", cuadrado);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej7","main.rs"],"content":"fn main() {\r\n    let mut arr = vec![1, 2, 3, 4, 5, 6];\r\n    const _MULTIPLICADOR: u16 = 31;\r\n\r\n    for num in arr.iter_mut() {\r\n        *num *= _MULTIPLICADOR;\r\n    }\r\n\r\n    let arr = arr; // arr is now immutable\r\n\r\n    println!(\"{:?}\", arr);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej8","main.rs"],"content":"use std::io::stdin;\r\n\r\nfn main() {\r\n    let arr = vec![1, 4, 7, 8, 13548, 13548, 13548, 7];\r\n\r\n    let mut inp = String::new();\r\n    println!(\"Ingrese un número a corroborar de la cadena\");\r\n    stdin().read_line(\u0026mut inp).expect(\"i32 input\");\r\n    let inp = inp.trim().parse::\u003ci32\u003e().expect(\"i32 input\");\r\n\r\n    let cont = arr.iter().filter(|\u0026x| *x == inp).count();\r\n    println!(\"En el array {arr:?} hay {cont} elementos iguales a {inp}\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","ej9","main.rs"],"content":"fn main() {\r\n    let arr: [i32; 5] = [1, 2, 3, 4, 5];\r\n    let suma: i32 = arr.iter().sum();\r\n\r\n    println!(\"Suma de los valores: {}\", suma);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac1","src","main.rs"],"content":"fn main() {\r\n    println!(\"Hello, world! prac1\");\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej1","main.rs"],"content":"/*\r\n 1-Definir la función llamada es_par que recibe como parámetro un número entero\r\n    y retorna true si el número es par, false caso contrario.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn es_par(num: i32) -\u003e bool {\r\n    num % 2 == 0\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej10","main.rs"],"content":"/*\r\n    Definir la función llamada cantidad_de_cadenas_mayor_a que recibe como parámetros\r\n    un arreglo de String y un entero llamado límite.\r\n    Esta función retorna la cantidad de Strings del arreglo que son de longitud mayor\r\n    al parámetro límite\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn cantidad_de_cadenas_mayor_a(arr: Vec\u003cString\u003e, limite: u32) -\u003e u32 {\r\n    let mut res: u32 = 0;\r\n\r\n    for str in arr {\r\n        if str.len() \u003e limite as usize { res+= 1 }\r\n    }\r\n\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej11","main.rs"],"content":"/*\r\n    Definir la función llamada multiplicar_valores que recibe como parámetro\r\n    un arreglo de enteros y otro número entero llamado factor.\r\n    Esta función multiplica los valores del arreglo por el parámetro factor modificándolo.\r\n */\r\n\r\nfn main() {\r\n    const HHHH: \u0026str = \"hola\";\r\n}\r\n\r\nfn multiplicar_valores(arr: Vec\u003ci32\u003e, factor: i32) -\u003e Vec\u003ci32\u003e {\r\n    let mut res: Vec\u003ci32\u003e = Vec::with_capacity(arr.len());\r\n\r\n    arr.iter().for_each(|num| res.push(*num*factor));\r\n\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej12","main.rs"],"content":"/*\r\n    Definir una función llamada reemplazar_pares que recibe un arreglo de enteros\r\n    y reemplaza todos los números pares por -1.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn reemplazar_pares(arr: Vec\u003ci32\u003e) -\u003e Vec\u003ci32\u003e {\r\n    let mut res: Vec\u003ci32\u003e = Vec::with_capacity(arr.len());\r\n    arr.iter().for_each(|num| res.push(if num % 2 == 0 { -1 } else { *num }));\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej13","main.rs"],"content":"/*\r\n    Definir una función llamada ordenar_nombres que recibe un arreglo de String\r\n    y los ordena en orden alfabético.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn ordenar_nombres(arr: Vec\u003cString\u003e) -\u003e Vec\u003cString\u003e {\r\n    let mut res = arr.clone();\r\n    res.sort();\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej14","main.rs"],"content":"/*\r\n    Definir una función llamada incrementar que\r\n    recibe como parámetro un número flotante e incrementa en 1 su valor.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn incrementar(arr: Vec\u003cf32\u003e) -\u003e Vec\u003cf32\u003e {\r\n    let mut res: Vec\u003cf32\u003e = Vec::with_capacity(arr.len());\r\n    for num in arr {\r\n        res.push(num+1.0);\r\n    }\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej2","main.rs"],"content":"/*\r\n    2- Definir la función llamada es_primo que recibe un número entero positivo mayor a 1\r\n        y retorna true si es primo, false caso contrario.\r\n */\r\n\r\nfn main() {\r\n    for num in 1..100 {\r\n        println!(\"{num}: {}\", es_primo(num));\r\n    }\r\n\r\n}\r\n\r\nfn es_primo(num: u32) -\u003e bool {\r\n    for i in 2..num  {\r\n        if num % i == 0 {\r\n            return false\r\n        }\r\n    }\r\n\r\n    true\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej3","main.rs"],"content":"/*\r\n    Definir la función llamada suma_pares que recibe como parámetro un arreglo de números enteros\r\n        y retorna la suma de los números pares.\r\n */\r\n\r\nfn main() {\r\n    println!(\"{}\", suma_pares(Vec::from([1, 2, 3, 4, 5])));\r\n}\r\n\r\nfn suma_pares(arr: Vec\u003ci32\u003e) -\u003e i32 {\r\n    let mut suma: i32 = 0;\r\n\r\n    for num in arr {\r\n        if num % 2 == 0 { suma+= num }\r\n    }\r\n\r\n    suma\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej4","main.rs"],"content":"/*\r\n    Definir la función llamada cantidad_impares que recibe como parámetro\r\n        un arreglo de números enteros y retorna la cantidad de números impares.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn cantidad_pares(arr: Vec\u003ci32\u003e) -\u003e u32 {\r\n    let mut cant: u32 = 0;\r\n    for num in arr {\r\n        if num % 2 == 0 { cant+= 1 }\r\n    }\r\n    cant\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::cantidad_pares;\r\n\r\n    #[test]\r\n    fn test() {\r\n        assert_eq!(cantidad_pares(Vec::new()), 0, \"Se esperan 0 números\");\r\n    }\r\n    \r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej5","main.rs"],"content":"/*\r\n    Defina la función llamada duplicar_valores que recibe un arreglo de números flotantes\r\n        y retorna un arreglo nuevo con los valores duplicados del parámetro.\r\n */\r\n\r\nfn main() {\r\n    println!(\"{:?}\", duplicar_valores(Vec::from([1.0, 2.0, 3.0, 4.0])))\r\n}\r\n\r\nfn duplicar_valores(arr: Vec\u003cf32\u003e) -\u003e Vec\u003cf32\u003e {\r\n    let mut new_arr: Vec\u003cf32\u003e = Vec::with_capacity(arr.len());\r\n    arr.iter().for_each(|num| new_arr.push(*num * 2.0));\r\n    new_arr\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej6","main.rs"],"content":"/*\r\n    Definir la función llamada longitud_de_cadenas que recibe un arreglo de String\r\n        y retorna un arreglo con la longitud de las cadenas del parámetro,\r\n            correspondiéndose en posición del arreglo.\r\n */\r\n\r\nfn main() {\r\n    println!(\"{:?}\", longitud_de_cadenas([\"hola!\".to_string(), \"soy\".to_string(), \"pedro\".to_string()].to_vec()))\r\n}\r\n\r\nfn longitud_de_cadenas(arr: Vec\u003cString\u003e) -\u003e Vec\u003cu32\u003e {\r\n    let mut res: Vec\u003cu32\u003e = Vec::with_capacity(arr.len());\r\n    for txt in arr {\r\n        res.push(txt.len() as u32);\r\n    }\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej7","main.rs"],"content":"/*\r\n    Definir la función llamada cantidad_de_mayores que recibe como parámetro\r\n        un arreglo de números enteros y un número entero llamado límite.\r\n            Esta función retorna la cantidad de números mayores al límite que tiene el arreglo.\r\n */\r\n\r\nfn main() {\r\n    \r\n}\r\n\r\nfn cantidad_de_mayores(arr: Vec\u003ci32\u003e, limite: i32) -\u003e u32 {\r\n    let mut res: u32 = 0;\r\n    for num in arr {\r\n        if num \u003e limite { res+= 1 }\r\n    }\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej8","main.rs"],"content":"/*\r\n    Definir la función llamada sumar_arreglos que recibe 2 arreglos del mismo tamaño\r\n        de números flotantes y retorna un nuevo arreglo\r\n        que contiene la suma de los elementos de los arreglos\r\n        pasados por parámetro, correspondiendose el resultado con cada posición\r\n        de los arreglos pasados por parámetro.\r\n */\r\n\r\nfn main() {\r\n    \r\n}\r\n\r\nfn sumar_arreglos(arr1: Vec\u003cf32\u003e, arr2: Vec\u003cf32\u003e) -\u003e Vec\u003cf32\u003e {\r\n    let mut res: Vec\u003cf32\u003e = Vec::with_capacity(arr1.len());\r\n\r\n    for i in 0..arr1.len() {\r\n        res.push(arr1[i] + arr2[i]);\r\n    }\r\n    \r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","ej9","main.rs"],"content":"/*\r\n    Definir la función llamada cantidad_en_rango que recibe 3 parámetros:\r\n        1 arreglo de enteros\r\n        un número entero llamado inferior\r\n        y otro número entero llamado superior.\r\n        Esta función retorna la cantidad de números del arreglo que están\r\n        entre el rango de los parámetros inferior y superior inclusive.\r\n */\r\n\r\nfn main() {\r\n\r\n}\r\n\r\nfn cantidad_en_rango(arr: Vec\u003ci32\u003e, inf: i32, sup: i32) -\u003e u32 {\r\n    let mut res: u32 = 0;\r\n\r\n    for num in arr {\r\n       if num \u003c= sup \u0026\u0026 num \u003e= inf { res+= 1 }\r\n    }\r\n\r\n    res\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac2","src","main.rs"],"content":"fn main() {\r\n    println!(\"Hello, world!\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej1","main.rs"],"content":"\r\n/*\r\n    1- Escribir un programa que defina una estructura Persona que tenga campos para:\r\n        - nombre\r\n        - edad\r\n        - dirección (que puede ser nulo al momento de la creación de una persona).\r\n        Para dicha estructura implemente los siguientes métodos:\r\n        ➢ new: que pasando los parámetros correspondientes, crea una Persona y la retorna.\r\n        ➢ imprimir: que imprime los datos de la persona sobre el mensaje ejecutado por ej: person.imprimir(),\r\n            donde person es una variable del tipo Persona.\r\n        ➢ obtener_edad: retorna la edad de la persona.\r\n        ➢ actualizar_direccion(nueva_direccion)\r\n */\r\n\r\nstruct Persona {\r\n    nombre:  String,\r\n    edad: u16,\r\n    direccion: Option\u003cString\u003e\r\n}\r\n\r\nimpl Persona {\r\n    fn new(nombre: String, edad: u16) -\u003e Persona {\r\n        Persona {nombre, edad, direccion: None}\r\n    }\r\n\r\n    fn actualizar_direccion(\u0026mut self, direccion: String) {\r\n        self.direccion = Some(direccion);\r\n    }\r\n\r\n    fn obtener_edad(\u0026self) -\u003e u16 {\r\n        self.edad\r\n    }\r\n\r\n    fn imprimir(\u0026self) {\r\n        println!(\"Nombre: {}, Edad: {}\", self.nombre, self.edad);\r\n        if let Some(val) = \u0026self.direccion { println!(\"Dirección: {}\", val) }\r\n    }\r\n}\r\n\r\nfn main() {\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","main.rs"],"content":"mod structs;\r\n\r\n/// # Ej. 10\r\n///\r\n/// ##### Para una biblioteca se desea implementar un sistema de préstamos de libros.\r\n/// De la biblioteca se conoce:\r\n///     el nombre,\r\n///     la dirección,\r\n///     las copias de los libros a disposición para prestar\r\n///     y los préstamos efectuados.\r\n/// \u003cbr\u003e\u003cbr\u003e\r\n/// Los \"libros a disposición\" es un registro donde se indica la cantidad de ejemplares\r\n/// que tiene a disposición para prestar de determinado libro.\r\n/// De cada libro se conoce:\r\n///     el título,\r\n///     autor,\r\n///     número de páginas,\r\n///     género (novela, infantil, técnico, otros).\r\n/// \u003cbr\u003e\u003cbr\u003e\r\n/// Para registrar un préstamo se requiere:\r\n///     el libro,\r\n///     el cliente,\r\n///     la fecha de vencimiento del préstamo,\r\n///     la fecha de devolución\r\n///     y el estado (devuelto o en préstamo)\r\n/// \u003cbr\u003e\u003cbr\u003e\r\n/// Del cliente se conoce:\r\n///     el nombre,\r\n///     teléfono\r\n///     y dirección de correo electrónico.\r\n///\r\n/// #### Implemente los métodos necesarios para realizar las siguientes acciones:\r\n///\r\n/// \u003cp\u003e➔ obtener cantidad de copias:\r\n///     dado un determinado libro retorna el retorna la cantidad de copias a disposición\r\n///     que hay para prestar de dicho libro.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ decrementar cantidad de copias a disposición:\r\n///     dado un libro decrementa en 1 la cantidad de copias de libros a disposición para prestar.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ incrementar cantidad de copias a disposición:\r\n///     dado un libro incremente en 1 la cantidad de copias del libro a disposición para ser prestado.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ contar préstamos de un cliente:\r\n///     devuelve la cantidad de préstamos en estado “en préstamo” de un determinado cliente.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ ver la cantidad disponible de un determinado libro:\r\n///     retorna la cantidad de libros disponibles del registro de “copias a disposición” de un determinado libro.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ realizar un préstamo de un libro para un cliente:\r\n///     crea un préstamo de un libro para un determinado cliente cumpliendo con lo siguiente\r\n///         ◆ el cliente no tenga más de 5 préstamos en el estado “en préstamo”\r\n///         ◆ haya al menos una copia disponible en el registro de copias a disposición.\r\n///             De ser así descuenta 1 en el registro de “copias a disposición” y retorna true,\r\n///                 si no cumple con alguna de las condiciones retorna false.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ ver préstamos a vencer el los próximos días:\r\n///     retorna una lista de préstamos a vencer el los próximos días, el valor de días es pasado por parámetro.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ ver los préstamos vencidos:\r\n///     retorna una lista de préstamos en el estado “en préstamos”\r\n///     donde la fecha de vencimiento es menor a la fecha actual.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ buscar préstamo:\r\n///     dado un libro y un cliente busca un préstamo y lo retorna si existe.\u003c/p\u003e\r\n///\r\n/// \u003cp\u003e➔ devolver libro:\r\n///     dado un libro y un cliente se busca el préstamo y se cambia al estado “devuelto”,\r\n///     se registra la fecha de devolución y se incrementa la cantidad de libros en 1\r\n///     del libro devuelto en el registro de copias a disposición.\u003c/p\u003e\r\nfn main() {\r\n\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","biblioteca.rs"],"content":"use std::collections::BTreeMap;\r\nuse crate::structs::cliente::Cliente;\r\nuse crate::structs::fecha::Fecha;\r\nuse crate::structs::prestamo::{EstadoPrestamo, Prestamo};\r\nuse super::libro::Libro;\r\n\r\n/// # Biblioteca\r\n///\r\n/// `nombre: String` - Nombre de la biblioteca\u003cbr\u003e\r\n/// `direccion: String` - Dirección física de la biblioteca\u003cbr\u003e\r\n/// `libros: BTreeMap\u003cu64, Libro\u003e` - Libros de la biblioteca\u003cbr\u003e\r\n/// `prestamos: BTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e` - \u003cb\u003e BTreeMap\u003cID del cliente, (Cliente, Vec\u003cPrestamo\u003e)\u003e\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Biblioteca {\r\n    pub nombre: String,\r\n    pub direccion: String,\r\n    pub libros: BTreeMap\u003cu64, Libro\u003e,\r\n    pub prestamos: BTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e // \u003cID cliente, (Cliente, Vec\u003cPréstamo\u003e)\u003e\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorDecrementarStock {\r\n    StockEsCero, LibroNoExiste\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorIncrementarStock {\r\n    LibroNoExiste, Overflow\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorRealizarPrestamo {\r\n    PrestamosMaximosAlcanzados, StockInsuficiente, LibroNoExiste\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorBuscarPrestamo {\r\n    PrestamoInexistente, ClienteInexistente\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorDevolverLibro {\r\n    PrestamoInexistente, ClienteInexistente, LibroYaDevuelto\r\n}\r\n\r\nimpl Biblioteca {\r\n\r\n    /// ### fn new() -\u003e Biblioteca\r\n    /// Crea una nueva instancia de biblioteca\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `nombre` - Nombre de la biblioteca\u003cbr\u003e\r\n    /// `direccion` - Dirección de la biblioteca\u003cbr\u003e\r\n    /// `libros` - Opcional: Lista de libros de la biblioteca\u003cbr\u003e\r\n    /// `prestamos` - Opcional: Lista de préstamos de la biblioteca\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Biblioteca` - Nueva instancia de Biblioteca\r\n    fn new(nombre: String, direccion: String, libros: Option\u003cBTreeMap\u003cu64, Libro\u003e\u003e, prestamos: Option\u003cBTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e\u003e) -\u003e Biblioteca {\r\n        Biblioteca {\r\n            nombre,\r\n            direccion,\r\n            libros: libros.unwrap_or_default(),\r\n            prestamos: prestamos.unwrap_or_default()\r\n        }\r\n    }\r\n\r\n    /// ### fn cantidad_de_copias_en_stock(isbn) -\u003e Option\u003cu32\u003e\r\n    /// Devuelve la cantidad de copias disponibles de un libro\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(u32)` - Cantidad (u32) de libros en stock\u003cbr\u003e\r\n    /// `None` - No existe el libro consultado\r\n    fn cantidad_de_copias_en_stock(\u0026self, isbn: u64) -\u003e Option\u003cu32\u003e {\r\n        self.libros.get(\u0026isbn).map(|libro| libro.stock)\r\n    }\r\n\r\n    /// ### fn decrementar_stock_libro(isbn) -\u003e Result\u003cu32, ErrorDecrementarStock\u003e\r\n    /// Devuelve la cantidad de libros en stock después de decrementarla en 1\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `u32` - Cantidad de libros después de decrementar\u003cbr\u003e\r\n    /// `ErrorDecrementarStock` - El stock es cero o el libro no existe\r\n    fn decrementar_stock_libro(\u0026mut self, isbn: u64) -\u003e Result\u003cu32, ErrorDecrementarStock\u003e {\r\n        match self.libros.get_mut(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == 0 {\r\n                    Err(ErrorDecrementarStock::StockEsCero)\r\n                } else {\r\n                    libro.stock-= 1;\r\n                    Ok(libro.stock)\r\n                }\r\n            },\r\n            None =\u003e Err(ErrorDecrementarStock::LibroNoExiste)\r\n        }\r\n    }\r\n\r\n\r\n    /// ### fn incrementar_stock_libro(isbn) -\u003e Result\u003cu32, ErrorIncrementarStock\u003e\r\n    /// Devuelve la cantidad de libros en stock después de incrementarla en 1\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `u32` - Cantidad de libros después de decrementar\u003cbr\u003e\r\n    /// `ErrorIncrementarStock` - El stock es `u32::MAX` o el libro no existe\r\n    fn incrementar_stock_libro(\u0026mut self, isbn: u64) -\u003e Result\u003cu32, ErrorIncrementarStock\u003e {\r\n        match self.libros.get_mut(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == u32::MAX {\r\n                    Err(ErrorIncrementarStock::Overflow)\r\n                } else {\r\n                    libro.stock+= 1;\r\n                    Ok(libro.stock)\r\n                }\r\n            },\r\n            None =\u003e Err(ErrorIncrementarStock::LibroNoExiste)\r\n        }\r\n    }\r\n\r\n    /// ### fn cantidad_prestamos_cliente(cliente) -\u003e Option\u003cusize\u003e\r\n    /// Devuelve la cantidad de préstamos efectuados a un cliente\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `cliente` - ID del cliente a consultar\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(usize)` - Cantidad de préstamos efectuados al cliente\u003cbr\u003e\r\n    /// `None` - El cliente no existe\r\n    fn cantidad_prestamos_cliente(\u0026self, cliente: u32) -\u003e Option\u003cusize\u003e {\r\n        // match self.prestamos.get(cliente) {\r\n        //     Some(cliente) =\u003e {\r\n        //         Some(cliente.len())\r\n        //     },\r\n        //     None =\u003e None\r\n        // }\r\n\r\n        self.prestamos.get(\u0026cliente).map(|cliente| cliente.1.len()) // compiler suggestion\r\n    }\r\n\r\n    /// ### fn cantidad_stock_libro(isbn) -\u003e Option\u003cu32\u003e\r\n    /// Devuelve la cantidad de libros en stock del libro consultado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(u32)` - Cantidad de libros en stock\u003cbr\u003e\r\n    /// `None` - El libro no existe\r\n    fn cantidad_stock_libro(\u0026self, isbn: u64) -\u003e Option\u003cu32\u003e {\r\n        self.libros.get(\u0026isbn).map(|libro| libro.stock) // compiler suggestion\r\n    }\r\n\r\n    /// ### fn realizar_prestamo(cliente, isbn, vencimiento) -\u003e Result(usize, ErrorRealizarPrestamo)\r\n    /// Realiza un préstamo del libro en nombre del cliente con el vencimiento especificado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `cliente` - Cliente a efectuar el préstamo\u003cbr\u003e\r\n    /// `isbn` - ID del libro a prestar\u003cbr\u003e\r\n    /// `vencimiento` - Fecha de vencimiento del préstamo\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `usize` - Cantidad de préstamos del cliente, incluyendo el recién realizado\r\n    fn realizar_prestamo(\u0026mut self, cliente: Cliente, isbn: u64, vencimiento: Fecha) -\u003e Result\u003cusize, ErrorRealizarPrestamo\u003e /* \u003cCant. préstamos del cliente, Error\u003e */ {\r\n        match self.libros.get(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == 0 {\r\n                    return Err(ErrorRealizarPrestamo::StockInsuficiente)\r\n                }\r\n            },\r\n            None =\u003e return Err(ErrorRealizarPrestamo::LibroNoExiste)\r\n        }\r\n\r\n        let prestamo = Prestamo::new(isbn, cliente.id, vencimiento, None, EstadoPrestamo::Prestando);\r\n\r\n        match self.prestamos.get_mut(\u0026cliente.id) {\r\n            Some(dato) =\u003e {\r\n                let cant_libros_no_devueltos = dato.1.iter().filter(|p| p.devolucion.is_none() \u0026\u0026 p.estado == EstadoPrestamo::Prestando).count();\r\n                if cant_libros_no_devueltos \u003e= 5 {\r\n                    return Err(ErrorRealizarPrestamo::PrestamosMaximosAlcanzados);\r\n                }\r\n\r\n                // si el préstamo alguna vez se realizó, eliminar el antiguo préstamo\r\n                dato.1.retain(|p| p.isbn != isbn);\r\n\r\n                // quitar stock al libro a prestar\r\n                // no puedo usar self.decrementar_stock_libro() porque tendría 2 borrows mutables en simultáneo\r\n                if let Some(libro) = self.libros.get_mut(\u0026isbn) { libro.stock-= 1 } // compiler suggestion\r\n\r\n                dato.1.push(prestamo);\r\n                Ok(cant_libros_no_devueltos)\r\n            },\r\n            None =\u003e {\r\n                // insertar cliente\r\n                self.prestamos.insert(cliente.id, (cliente, vec![prestamo]));\r\n                self.decrementar_stock_libro(isbn);\r\n                Ok(1)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// ### fn prestamos_a_vencer(feca_hoy, dias) -\u003e Vec\u003c\u0026Prestamo\u003e\r\n    /// Devuelve un Vec\u003c\u0026Prestamo\u003e con los préstamos a vencer en los próximos `dias` días\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `fecha_hoy` - Fecha del día de hoy\u003cbr\u003e\r\n    /// `dias` - Días en los que vencerán los préstamos devueltos\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Vec\u003c\u0026Prestamo\u003e` - Los préstamos que vencerán en los próximos `dias` días\r\n    fn prestamos_por_vencer(\u0026self, fecha_hoy: Fecha, dias: u32) -\u003e Vec\u003c\u0026Prestamo\u003e {\r\n        let mut prestamos_por_vencer: Vec\u003c\u0026Prestamo\u003e = Vec::new();\r\n\r\n        let mut fecha_limte = fecha_hoy;\r\n        fecha_limte.sumar_dias(dias);\r\n        let fecha_limite = fecha_limte; // quitar mutabilidad\r\n\r\n        for prestamos_cliente in self.prestamos.values() {\r\n            for prestamo in \u0026prestamos_cliente.1 {\r\n\r\n                match \u0026prestamo.devolucion {\r\n                    Some(_) =\u003e continue, // ya fue devuelto, no contabilizar\r\n                    None =\u003e {\r\n                        if prestamo.devolucion.is_none() \u0026\u0026 prestamo.estado == EstadoPrestamo::Prestando \u0026\u0026 prestamo.vencimiento \u003c= fecha_limite {\r\n                            prestamos_por_vencer.push(prestamo);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        prestamos_por_vencer\r\n    }\r\n\r\n    /// ### fn prestamos_vencidos(fecha_hoy) -\u003e Vec\u003c\u0026Prestamo\u003e\r\n    /// Devuelve los prestamos que hayan vencido\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `fecha_hoy` - La fecha de hoy\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Vec\u003c\u0026Prestamo\u003e` - Los préstamos que han vencido\r\n    fn prestamos_vencidos(\u0026self, fecha_hoy: Fecha) -\u003e Vec\u003c\u0026Prestamo\u003e {\r\n        let mut prestamos_vencidos: Vec\u003c\u0026Prestamo\u003e = Vec::new();\r\n\r\n        for prestamos_cliente in self.prestamos.values() {\r\n            for prestamo in \u0026prestamos_cliente.1 {\r\n                if prestamo.estado == EstadoPrestamo::Prestando \u0026\u0026 prestamo.vencimiento \u003c fecha_hoy {\r\n                    prestamos_vencidos.push(prestamo);\r\n                }\r\n            }\r\n        }\r\n\r\n        prestamos_vencidos\r\n    }\r\n\r\n    /// ### fn buscar_prestamo(isbn, id_cliente) -\u003e Result\u003c\u0026Prestamo, ErrorBuscarPrestamo\u003e\r\n    /// Devuelve un préstamo en específico\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro prestado\u003cbr\u003e\r\n    /// `id_cliente` - ID del cliente del préstamo\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `\u0026Prestamo` - El préstamo buscado\u003cbr\u003e\r\n    /// `ErrorBuscarPrestamo` - El préstamo o el cliente no existen\r\n    fn buscar_prestamo(\u0026self, isbn: u64, id_cliente: u32) -\u003e Result\u003c\u0026Prestamo, ErrorBuscarPrestamo\u003e {\r\n        match self.prestamos.get(\u0026id_cliente) {\r\n            Some(dato) =\u003e {\r\n                for prestamo in \u0026dato.1 {\r\n                    if prestamo.isbn == isbn { return Ok(prestamo) }\r\n                }\r\n                    Err(ErrorBuscarPrestamo::PrestamoInexistente)\r\n            },\r\n            None =\u003e Err(ErrorBuscarPrestamo::ClienteInexistente)\r\n        }\r\n    }\r\n\r\n    /// ### fn devolver_libro(isbn, id_cliente, fecha_hoy) -\u003e Result\u003c\u0026Prestamo, ErrorDevolverLibro\u003e\r\n    /// Realiza la devolución del libro especificado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a devolver\u003cbr\u003e\r\n    /// `id_cliente` - ID del cliente que devuelve\u003cbr\u003e\r\n    /// `fecha_hoy` - La fecha de hoy\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `\u0026Prestamo` - El préstamo del libro que se ha devuelto\u003cbr\u003e\r\n    /// `ErrorDevolverLibro` - El cliente o el préstamo no existen o ya fue devuelto\r\n    fn devolver_libro(\u0026mut self, isbn: u64, id_cliente: u32, fecha_hoy: Fecha) -\u003e Result\u003c\u0026Prestamo, ErrorDevolverLibro\u003e {\r\n        match self.prestamos.get_mut(\u0026id_cliente) {\r\n            Some(dato) =\u003e {\r\n                for prestamo in dato.1.iter_mut() {\r\n                    if prestamo.isbn == isbn {\r\n                        if prestamo.estado == EstadoPrestamo::Devuelto {\r\n                            return Err(ErrorDevolverLibro::LibroYaDevuelto)\r\n                        }\r\n\r\n                        prestamo.devolucion = Some(fecha_hoy);\r\n                        prestamo.estado = EstadoPrestamo::Devuelto;\r\n\r\n                        // no puedo usar self.incrementar_stock_libro() porque tendría 2 borrows mutables en simultáneo\r\n                        if let Some(libro) = self.libros.get_mut(\u0026isbn) { libro.stock-= 1 }\r\n\r\n                        return Ok(prestamo)\r\n                    }\r\n                }\r\n                Err(ErrorDevolverLibro::PrestamoInexistente)\r\n            },\r\n            None =\u003e Err(ErrorDevolverLibro::ClienteInexistente)\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::collections::BTreeMap;\r\n    use crate::structs::biblioteca::{Biblioteca, ErrorDecrementarStock, ErrorIncrementarStock, ErrorRealizarPrestamo};\r\n    use crate::structs::cliente::Cliente;\r\n    use crate::structs::fecha::Fecha;\r\n    use crate::structs::libro::Libro;\r\n    use crate::structs::prestamo::EstadoPrestamo;\r\n\r\n    fn biblioteca_de_pepe() -\u003e Biblioteca {\r\n        Biblioteca::new(\r\n            \"biblio de pepe\".to_string(),\r\n            \"donde queda\".to_string(),\r\n            Some(BTreeMap::from(\r\n                [(1, libro_economia_1()),\r\n                    (2, libro_xd_2()),\r\n                    (3, libro_harrypotter_3()),\r\n                    (4, libro_asd_4()),\r\n                    (5, libro_estadistica_5()),\r\n                    (u32::MAX as u64, libro_algo_u32max())])),\r\n            None)\r\n    }\r\n    fn cliente_pepe() -\u003e Cliente {\r\n        Cliente::new(\r\n            1,\r\n            \"pepe\".to_string(),\r\n            \"123\".to_string(),\r\n            \"pepe@gmail.com\".to_string()\r\n        )\r\n    }\r\n    fn cliente_manuel() -\u003e Cliente {\r\n        Cliente::new(\r\n            3,\r\n            \"manuel\".to_string(),\r\n            \"123\".to_string(),\r\n            \"manuel@gmail.com\".to_string()\r\n        )\r\n    }\r\n    fn libro_economia_1() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 1;\r\n        libro.titulo = \"Economía en una lección\".to_string();\r\n        libro.stock = 1;\r\n        libro\r\n    }\r\n    fn libro_xd_2() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 2;\r\n        libro.titulo = \"xd\".to_string();\r\n        libro.stock = 2;\r\n        libro\r\n    }\r\n    fn libro_harrypotter_3() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 3;\r\n        libro.titulo = \"Harry Potter y qsy q mas\".to_string();\r\n        libro.stock = 3;\r\n        libro\r\n    }\r\n    fn libro_asd_4() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 4;\r\n        libro.titulo = \"asd\".to_string();\r\n        libro.stock = 4;\r\n        libro\r\n    }\r\n    fn libro_estadistica_5() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 5;\r\n        libro.titulo = \"Estadística\".to_string();\r\n        libro.stock = 5;\r\n        libro\r\n    }\r\n    fn libro_algo_u32max() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = u32::MAX as u64;\r\n        libro.titulo = \"algo\".to_string();\r\n        libro.stock = u32::MAX;\r\n        libro\r\n    }\r\n\r\n    #[test]\r\n    fn test_cant_copias() {\r\n        let mut biblioteca = biblioteca_de_pepe();\r\n\r\n        // test dec\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 5, \"ISBN 5 tiene 5 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 3, \"ISBN 3 tiene 3 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 1, \"ISBN 1 tiene 1 copias\");\r\n\r\n        biblioteca.decrementar_stock_libro(5);\r\n        biblioteca.decrementar_stock_libro(3);\r\n        biblioteca.decrementar_stock_libro(1);\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 4, \"ISBN 5 tiene 4 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 2, \"ISBN 3 tiene 2 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 0, \"ISBN 1 tiene 0 copias\");\r\n\r\n        // test inc\r\n\r\n        biblioteca.incrementar_stock_libro(5);\r\n        biblioteca.incrementar_stock_libro(3);\r\n        biblioteca.incrementar_stock_libro(1);\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 5, \"ISBN 5 tiene 5 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 3, \"ISBN 3 tiene 3 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 1, \"ISBN 1 tiene 1 copias\");\r\n\r\n        // test 0\r\n\r\n        biblioteca.decrementar_stock_libro(1);\r\n\r\n        biblioteca.decrementar_stock_libro(5);\r\n        biblioteca.decrementar_stock_libro(3);\r\n        let dec = biblioteca.decrementar_stock_libro(1);\r\n\r\n        assert_eq!(dec.unwrap_err(), ErrorDecrementarStock::StockEsCero, \"stock debería ser cero\");\r\n\r\n        // test overflow\r\n\r\n        let inc = biblioteca.incrementar_stock_libro(u32::MAX as u64);\r\n        assert_eq!(inc.unwrap_err(), ErrorIncrementarStock::Overflow, \"stock debería ser u32::MAX\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_prestamos() {\r\n        let mut biblioteca = biblioteca_de_pepe();\r\n\r\n        // init realizar prestamos\r\n\r\n        let fecha5 = Fecha{ dia: 1, mes: 1, ano: 1 };\r\n        let fecha3 = Fecha{ dia: 2, mes: 1, ano: 1 };\r\n\r\n        let p5 = biblioteca.realizar_prestamo(cliente_pepe(), 5, fecha5.clone());\r\n        let p3 = biblioteca.realizar_prestamo(cliente_manuel(), 3, fecha3.clone());\r\n\r\n        // check\r\n\r\n        if p5.is_err() { panic!(\"Error inesperado realizando préstamo: {:?}\", p5.unwrap_err()) }\r\n        if p3.is_err() { panic!(\"Error inesperado realizando préstamo: {:?}\", p3.unwrap_err()) }\r\n\r\n        assert_eq!(p5.unwrap(), 1, \"Debería tener 1 préstamo\");\r\n        assert_eq!(p3.unwrap(), 1, \"Debería tener 1 préstamo\");\r\n\r\n        // init cant copias\r\n\r\n        let stock5 = biblioteca.cantidad_de_copias_en_stock(5);\r\n        let stock3 = biblioteca.cantidad_de_copias_en_stock(3);\r\n\r\n        // check\r\n\r\n        if stock5.is_none() { panic!(\"cantidad_de_copias_en_strock(): None\") }\r\n        if stock3.is_none() { panic!(\"cantidad_de_copias_en_strock(): None\") }\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 4, \"Deberían haber 4 copias en stock\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 2, \"Deberían haber 2 copias en stock\");\r\n\r\n        // init prestamos por vencer\r\n\r\n        let prestamos_a_vencer0 = biblioteca.prestamos_por_vencer(Fecha { dia: 1, mes: 1, ano: -1 }, 0);\r\n        let prestamos_a_vencer1 = biblioteca.prestamos_por_vencer(fecha5.clone(), 0);\r\n        let prestamos_a_vencer2 = biblioteca.prestamos_por_vencer(fecha5.clone(), 1);\r\n        let prestamos_a_vencer2_2 = biblioteca.prestamos_por_vencer(Fecha { dia: 22, mes: 08, ano: 2002 }, 0);\r\n\r\n        // check\r\n\r\n        assert_eq!(prestamos_a_vencer0.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer1.len(), 1, \"Debería haber 1 préstamo a vencer\");\r\n        assert_eq!(prestamos_a_vencer2.len(), 2, \"Deberían haber 2 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2_2.len(), 2, \"Deberían haber 0 préstamos a vencer\");\r\n\r\n        // init buscar prestamos\r\n\r\n        let buscar_prestamo5 = biblioteca.buscar_prestamo(5, cliente_pepe().id);\r\n        let buscar_prestamo3 = biblioteca.buscar_prestamo(3, cliente_manuel().id);\r\n\r\n        // check\r\n\r\n        if buscar_prestamo5.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo5.unwrap_err()) }\r\n        if buscar_prestamo3.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo3.unwrap_err()) }\r\n\r\n        assert_eq!(buscar_prestamo5.unwrap().isbn, 5, \"El préstamo encontrado debería ser sobre el libro #5\");\r\n        assert_eq!(buscar_prestamo3.unwrap().isbn, 3, \"El préstamo encontrado debería ser sobre el libro #3\");\r\n\r\n        // init-check devolver prestamos\r\n\r\n        let devolucion_prestamo5 = biblioteca.devolver_libro(5, cliente_pepe().id, fecha5.clone());\r\n        if devolucion_prestamo5.is_err() { panic!(\"\") }\r\n\r\n        let devolucion_prestamo3 = biblioteca.devolver_libro(3, cliente_manuel().id, fecha3.clone());\r\n        if devolucion_prestamo3.is_err() { panic!(\"\") }\r\n\r\n        // init prestamos por vencer post-devolver\r\n\r\n        let prestamos_a_vencer0 = biblioteca.prestamos_por_vencer(Fecha { dia: 1, mes: 1, ano: -1 }, 0);\r\n        let prestamos_a_vencer1 = biblioteca.prestamos_por_vencer(fecha5.clone(), 0);\r\n        let prestamos_a_vencer2 = biblioteca.prestamos_por_vencer(fecha5.clone(), 1);\r\n        let prestamos_a_vencer2_2 = biblioteca.prestamos_por_vencer(Fecha { dia: 22, mes: 08, ano: 2002 }, 0);\r\n\r\n        // check\r\n\r\n        assert_eq!(prestamos_a_vencer0.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer1.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2_2.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n\r\n        // init buscar prestamos post-devolver\r\n\r\n        let buscar_prestamo5 = biblioteca.buscar_prestamo(5, cliente_pepe().id);\r\n        let buscar_prestamo3 = biblioteca.buscar_prestamo(3, cliente_manuel().id);\r\n\r\n        // check\r\n\r\n        if buscar_prestamo5.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo5.unwrap_err()) }\r\n        if buscar_prestamo3.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo3.unwrap_err()) }\r\n\r\n        assert_eq!(buscar_prestamo5.clone().unwrap().isbn, 5, \"El préstamo encontrado debería ser sobre el libro #5\");\r\n        assert_eq!(buscar_prestamo3.clone().unwrap().isbn, 3, \"El préstamo encontrado debería ser sobre el libro #3\");\r\n\r\n        assert_eq!(buscar_prestamo5.clone().unwrap().estado, EstadoPrestamo::Devuelto, \"El préstamo encontrado debería haber sido devuelto\");\r\n        assert_eq!(buscar_prestamo3.clone().unwrap().estado, EstadoPrestamo::Devuelto, \"El préstamo encontrado debería haber sido devuelto\");\r\n\r\n        assert!(buscar_prestamo5.unwrap().devolucion.is_some(), \"El préstamo encontrado debería haber sido devuelto\");\r\n        assert!(buscar_prestamo3.unwrap().devolucion.is_some(), \"El préstamo encontrado debería haber sido devuelto\");\r\n\r\n        // init max prestamos (5)\r\n\r\n        let p1 = biblioteca.realizar_prestamo(cliente_pepe(), 1, fecha5.clone());\r\n        let p2 = biblioteca.realizar_prestamo(cliente_pepe(), 2, fecha5.clone());\r\n        let p3 = biblioteca.realizar_prestamo(cliente_pepe(), 3, fecha5.clone());\r\n        let p4 = biblioteca.realizar_prestamo(cliente_pepe(), 4, fecha5.clone());\r\n        let p5 = biblioteca.realizar_prestamo(cliente_pepe(), 5, fecha5.clone());\r\n\r\n        let p6 = biblioteca.realizar_prestamo(cliente_pepe(), u32::MAX as u64, fecha3.clone());\r\n\r\n        // check\r\n\r\n        assert!(p1.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p2.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p3.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p4.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p5.is_ok(), \"El préstamo debería ser exitoso\");\r\n\r\n        assert!(p6.is_err(), \"El préstamo no debería ser exitoso\");\r\n        assert_eq!(p6.unwrap_err(), ErrorRealizarPrestamo::PrestamosMaximosAlcanzados, \"Debería haberse alcanzado el límite máximo de préstamos\");\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","cliente.rs"],"content":"/// Del cliente se conoce:\r\n///     el nombre,\r\n///     teléfono\r\n///     y dirección de correo electrónico.\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Cliente {\r\n    pub id: u32,\r\n    pub nombre: String,\r\n    pub telefono: String,\r\n    pub email: String,\r\n}\r\n\r\nimpl Cliente {\r\n    pub fn new(id: u32, nombre: String, telefono: String, email: String) -\u003e Cliente {\r\n        Cliente { id, nombre, telefono, email }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","fecha.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct Fecha {\r\n    pub(crate) dia: u8,\r\n    pub(crate) mes: u8,\r\n    pub(crate) ano: i64\r\n}\r\n\r\nimpl Default for Fecha {\r\n    fn default() -\u003e Self {\r\n        Fecha { dia: 1, mes: 1, ano: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Fecha {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.dia == other.dia\r\n            \u0026\u0026 self.mes == other.mes\r\n            \u0026\u0026 self.ano == other.ano\r\n        { return Some(Equal) }\r\n\r\n        if self.ano \u003e other.ano { return Some(Greater) }\r\n        if self.mes \u003e other.mes { return Some(Greater) }\r\n        if self.dia \u003e other.dia { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cFecha\u003e {\r\n        let fecha = Fecha { dia, mes, ano };\r\n        if fecha.es_fecha_valida() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia == 0\r\n            || self.dia \u003e self.dias_mes_actual()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n\r\n    pub fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n\r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","libro.rs"],"content":"/// De cada libro se conoce:\r\n///     el título,\r\n///     autor,\r\n///     número de páginas,\r\n///     género (novela, infantil, técnico, otros).\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub(crate) struct Libro {\r\n    pub isbn: u64,\r\n    pub titulo: String,\r\n    pub autor: String,\r\n    pub paginas: u16,\r\n    pub genero: Genero,\r\n    pub stock: u32\r\n}\r\n\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub enum Genero {\r\n    Novela, Infantil, Tecnico, #[default] Otros\r\n}\r\n\r\nimpl Libro {\r\n    pub fn new(isbn: u64, titulo: String, autor: String, paginas: u16, genero: Genero, stock: u32) -\u003e Libro {\r\n        Libro { isbn, titulo, autor, paginas, genero, stock }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","mod.rs"],"content":"pub mod prestamo;\r\npub mod biblioteca;\r\npub mod cliente;\r\npub mod libro;\r\npub mod fecha;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej10","structs","prestamo.rs"],"content":"use super::fecha::Fecha;\r\n\r\n/// Para registrar un préstamo se requiere:\r\n///     el libro,\r\n///     el cliente,\r\n///     la fecha de vencimiento del préstamo,\r\n///     la fecha de devolución\r\n///     y el estado (devuelto o en préstamo)\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Prestamo {\r\n    pub isbn: u64, // isbn\r\n    pub cliente: u32, // id\r\n    pub vencimiento: Fecha,\r\n    pub devolucion: Option\u003cFecha\u003e,\r\n    pub estado: EstadoPrestamo\r\n}\r\n\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub enum EstadoPrestamo {\r\n    Devuelto, #[default] Prestando\r\n}\r\n\r\nimpl Prestamo {\r\n    \r\n    pub fn new(isbn: u64, cliente: u32, vencimiento: Fecha, devolucion: Option\u003cFecha\u003e, estado: EstadoPrestamo) -\u003e Prestamo {\r\n        Prestamo { isbn, cliente, vencimiento, devolucion, estado }\r\n    }\r\n    \r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej2","main.rs"],"content":"\r\n/*\r\n    2- Escribir un programa que defina la estructura Rectángulo que tenga campos para la\r\n        longitud y el ancho. Para dicha estructura implemente los siguientes métodos:\r\n        ➢ new: que pasando los parámetros correspondientes, crea un Rectángulo y lo\r\n        retorna.\r\n        ➢ calcular_area: calcular el área y la retorna.\r\n        ➢ calcular_perimetro: calcula el perímetro y lo retorna.\r\n        ➢ es_cuadrado: retorna true si es cuadrado, false caso contrario\r\n */\r\n\r\nstruct Rectangulo {\r\n    longitud: u16,\r\n    ancho: u16\r\n}\r\n\r\nimpl Rectangulo {\r\n    fn new(longitud: u16, ancho: u16) -\u003e Rectangulo {\r\n        if longitud == 0 || ancho == 0 { panic!(\"Una longitud medible no puede ser 0\") }\r\n        Rectangulo { longitud, ancho }\r\n    }\r\n    \r\n    fn calcular_area(\u0026self) -\u003e u32 {\r\n        self.longitud as u32 * self.ancho as u32\r\n    }\r\n    \r\n    fn calcular_perimetro(\u0026self) -\u003e u32 {\r\n        self.longitud as u32*2 + self.ancho as u32*2\r\n    }\r\n    \r\n    fn es_cuadrado(\u0026self) -\u003e bool {\r\n        self.longitud == self.ancho\r\n    }\r\n}\r\n\r\nfn main() { }\r\n\r\n#[cfg(test)]\r\nmod tests_rectangulo {\r\n    use crate::Rectangulo;\r\n\r\n    #[test]\r\n    fn test_limites() {\r\n        let mi_rectangulo = Rectangulo::new(u16::MAX, u16::MAX);\r\n        let mi_rectangulo_neg = Rectangulo::new(u16::MIN, u16::MIN);\r\n        let mi_rectangulo_0 = Rectangulo::new(0, 0);\r\n\r\n        // shouldn't panic\r\n        let area = mi_rectangulo.calcular_area();\r\n        let perimetro = mi_rectangulo.calcular_perimetro();\r\n        let cuadrado = mi_rectangulo.es_cuadrado();\r\n\r\n        let area = mi_rectangulo_neg.calcular_area();\r\n        let perimetro = mi_rectangulo_neg.calcular_perimetro();\r\n        let cuadrado = mi_rectangulo_neg.es_cuadrado();\r\n\r\n        let area = mi_rectangulo_0.calcular_area();\r\n        let perimetro = mi_rectangulo_0.calcular_perimetro();\r\n        let cuadrado = mi_rectangulo_0.es_cuadrado();\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej3","main.rs"],"content":"\r\n/*\r\n    3- Escribir un programa que defina una estructura Fecha que tenga campos para:\r\n        - día\r\n        - mes\r\n        - año\r\n        Para dicha estructura implemente los siguientes métodos:\r\n        ➢ new: que pasando los parámetros correspondientes, crea una Fecha y la retorna.\r\n        ➢ es_fecha_valida: retorna true si es una fecha valida, false caso contrario.//tenga en\r\n        cuenta los años bisiestos también.\r\n        ➢ es_bisiesto: retorna true si el año de la fecha pertenece a un año bisiesto.\r\n        ➢ sumar_dias(dias): suma la cantidad de días a la fecha, modificándose\r\n        ➢ restar_dias(dias): resta la cantidad de días a la fecha, modificándose\r\n        ➢ es_mayor(una_fecha): que retorna true si la fecha que recibe el mensaje es mayor a\r\n        la fecha pasada por parámetro..\r\n */\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n                                  \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n                                  \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Debug, PartialEq)]\r\nstruct Fecha {\r\n    dia: u8,\r\n    mes: u8,\r\n    ano: i64\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    fn new(dia: u8, mes: u8, ano: i64) -\u003e Fecha {\r\n        Fecha { dia, mes, ano }\r\n    }\r\n\r\n    fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia \u003c 1 \r\n        || self.dia \u003e self.dias_mes_actual()\r\n            { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n    \r\n    fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n        \r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n            \r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n                \r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n                \r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n                \r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut fecha = Fecha::new(22, 08, 2002);\r\n    println!(\"{}\", fecha);\r\n    fecha.sumar_dias(5000);\r\n    println!(\"{}\", fecha);\r\n    fecha.restar_dias(5000);\r\n    println!(\"{}\", fecha);\r\n\r\n    println!();\r\n\r\n    let mut fecha2 = Fecha::new(31, 12, 2025);\r\n    fecha2.sumar_dias(1);\r\n    println!(\"{}\", fecha2);\r\n    fecha2.restar_dias(1);\r\n    println!(\"{}\", fecha2);\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::Fecha;\r\n\r\n    #[test]\r\n    fn test_bisiestos() {\r\n        let fecha = Fecha::new(22, 8, 2002);\r\n        assert!(!fecha.es_bisiesto(), \"2002 no es un año bisiesto\");\r\n        \r\n        let fecha_2 = Fecha::new(22, 8, 2020);\r\n        assert!(fecha_2.es_bisiesto(), \"2020 es bisiesto\");\r\n        \r\n        let fecha_3 = Fecha::new(1, 1, 0);\r\n        assert!(fecha_3.es_bisiesto(), \"0 es bisiesto\");\r\n    }\r\n    \r\n    #[test]\r\n    fn test_suma_resta() {\r\n        let mut fecha_1 = Fecha::new(22, 8, 2002);\r\n        let fecha_2 = Fecha::new(22, 8, 2002);\r\n        \r\n        fecha_1.sumar_dias(5000);\r\n        \r\n        assert_eq!(fecha_1, Fecha::new(30, 4, 2016), \"22/08/2002 + 5000 días = 30/04/2016\");\r\n        \r\n        fecha_1.restar_dias(5000);\r\n        \r\n        assert_eq!(fecha_1, fecha_2, \"22/08/2002 + 5000 - 5000 == 22/08/2002\");\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej4","main.rs"],"content":"/*\r\n    4- Escribir un programa que defina la estructura Triángulo que tenga campos para las\r\n    longitudes de sus tres lados. Para dicha estructura implemente los siguientes métodos:\r\n        ➢ new: que pasando los parámetros correspondientes, crea un Triángulo y lo retorna.\r\n        ➢ determinar_tipo: retorna el tipo del triángulo, los tipos pueden ser equilátero, isósceles o escaleno.\r\n        ➢ calcular_area: calcular el área y la retorna.\r\n        ➢ calcular_perimetro: calcula el perímetro y lo retorna.\r\n*/\r\n\r\n#[derive(Debug)]\r\n#[derive(PartialEq)]\r\nenum TrianguloTypes {\r\n    Equilatero, Isosceles, Escaleno\r\n}\r\n\r\nstruct Triangulo {\r\n    a: f32,\r\n    b: f32,\r\n    c: f32\r\n}\r\n\r\nimpl Triangulo {\r\n    fn new(a: f32, b: f32, c: f32) -\u003e Result\u003cTriangulo, String\u003e {\r\n        if a == 0.0\r\n            || b == 0.0\r\n            || c == 0.0\r\n        { return Err(\"Una longitud medible no puede ser 0\".to_string()) }\r\n        \r\n        if (a + b) \u003c c\r\n            || (a + c) \u003c b\r\n            || (b + c) \u003c a\r\n        { return Err(\"La suma de dos catetos debe ser mayor al tercer cateto\".to_string()) }\r\n        \r\n        Ok(Triangulo {a, b, c})\r\n    }\r\n\r\n    fn determinar_tipo(\u0026self) -\u003e TrianguloTypes {\r\n        if self.a == self.b \u0026\u0026 self.b == self.c {\r\n            return TrianguloTypes::Equilatero\r\n        }\r\n\r\n        if self.a == self.b\r\n        || self.a == self.c\r\n        || self.b == self.c { return TrianguloTypes::Isosceles }\r\n        \r\n        TrianguloTypes::Escaleno\r\n    }\r\n\r\n    fn calcular_area(\u0026self) -\u003e f32 {\r\n        let s = (self.a + self.b + self.c) / 2.0;\r\n        // √[s(s - a)(s - b)(s - c)],\r\n        (s * ((s-self.a)*(s-self.b)*(s-self.c))).sqrt()\r\n    }\r\n\r\n    fn calcular_perimetro(\u0026self) -\u003e f32 {\r\n        self.a + self.b + self.c\r\n    }\r\n\r\n}\r\n\r\nfn main() {\r\n    \r\n}\r\n\r\n#[cfg(test)]\r\nmod test_triangulo {\r\n    use crate::{Triangulo, TrianguloTypes};\r\n    \r\n    #[test]\r\n    fn test_triangulo_invalido_1() {\r\n        let triangulo_invalido = Triangulo::new(1.0, 1.0, 1000.0);\r\n        assert!(triangulo_invalido.is_err());\r\n    }\r\n    \r\n    #[test]\r\n    fn test_triangulo_invalido_2() {\r\n        let triangulo_invalido = Triangulo::new(0.0, 1.0, 1.0);\r\n        assert!(triangulo_invalido.is_err());\r\n    }\r\n    \r\n    #[test]\r\n    fn test_triangulo_types() {\r\n        if let Ok(triangulo) = Triangulo::new(1.0, 1.0, 1.0) { assert_eq!(triangulo.determinar_tipo(), TrianguloTypes::Equilatero, \"Debería ser equilátero\"); }\r\n        if let Ok(triangulo) = Triangulo::new(1.0, 1.0, 2.0) { assert_eq!(triangulo.determinar_tipo(), TrianguloTypes::Isosceles, \"Debería ser isósceles\"); };\r\n        if let Ok(triangulo) = Triangulo::new(1.0, 2.0, 3.0) { assert_eq!(triangulo.determinar_tipo(), TrianguloTypes::Escaleno, \"Debería ser escaleno\"); }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej5","main.rs"],"content":"/*\r\n    5- Escribir un programa que defina una estructura Producto que tenga campos para el\r\n        nombre, el precio bruto y un número identificatorio. Para dicha estructura implemente los\r\n        siguientes métodos:\r\n        ➢ new: que pasando los parámetros correspondientes, crea un Producto y lo retorna.\r\n        ➢ calcular_impuestos(porcentaje_de_impuestos): retorna el valor de impuestos sobre\r\n        el precio bruto\r\n        ➢ aplicar_descuento(porcentaje_de_descuento): retorna el valor del porcentaje de\r\n        descuento sobre el precio bruto\r\n        ➢ calcular_precio_total(porcentaje_de_impuestos, porcentaje_descuento): retorna el\r\n        precio total a pagar aplicando impuesto y descuento. Tenga en cuenta que los\r\n        parámetros son opcionales.\r\n*/\r\n\r\nstruct Producto {\r\n    nombre: String,\r\n    precio: f32,\r\n    id: i32\r\n}\r\n\r\nimpl Producto {\r\n    fn new(nombre: String, precio: f32, id: i32) -\u003e Result\u003cProducto, String\u003e {\r\n        if precio \u003c 0.0 { return Err(\"Un precio no puede ser negativo.\".to_string()) }\r\n        Ok(Producto { nombre, precio, id })\r\n    }\r\n\r\n    fn calcular_impuestos(\u0026self, porc: f32) -\u003e f64 {\r\n        self.precio as f64 * porc as f64 / 100.0\r\n    }\r\n\r\n    fn aplicar_descuento(\u0026self, porc: f32) -\u003e f64 {\r\n        self.precio as f64 * (1.0 - porc as f64 / 100.0)\r\n    }\r\n\r\n    fn calcular_precio_total(\u0026self, porc_imp: Option\u003cf32\u003e, porc_desc: Option\u003cf32\u003e) -\u003e f64 {\r\n        let mut precio: f64 = self.precio as f64;\r\n\r\n        if porc_desc.is_some() { precio-= self.aplicar_descuento(porc_desc.unwrap()) }\r\n        if porc_imp.is_some() { precio+= self.calcular_impuestos(porc_imp.unwrap()) }\r\n        \r\n        precio\r\n    }\r\n}\r\n\r\nfn main() {\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::Producto;\r\n\r\n    #[test]\r\n    fn test_limites() {\r\n        let producto = Producto::new(\"asd\".to_string(), f32::MAX, i32::MAX).unwrap();\r\n\r\n        // should not panic\r\n        let precio_total_1 = producto.calcular_precio_total(Some(f32::MAX), Some(f32::MAX));\r\n        let precio_total_2 = producto.calcular_precio_total(Some(f32::MIN), Some(f32::MIN));\r\n    }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej6","Fermin_Franco_v1.rs"],"content":"\r\n/*\r\n    6- Escribir un programa que defina una estructura Estudiante que tenga campos para:\r\n            nombre,\r\n            número de identificación,\r\n            las calificaciones de exámenes.\r\n        De cada Examen se conoce:\r\n            nombre de la materia,\r\n            la nota.\r\n        Para dichas estructuras implemente los siguientes métodos:\r\n            ❖ Examen:\r\n                ➢ new: que pasando los parámetros correspondientes, crea un Examen y lo retorna.\r\n            ❖ Estudiante:\r\n                ➢ new: que pasando los parámetros correspondientes, crea un Estudiante y lo retorna.\r\n                ➢ obtener_promedio: retorna el promedio de las notas.\r\n                ➢ obtener_calificacion_mas_alta: retorna la nota más alta.\r\n                ➢ obtener_calificacion_mas_baja: retorna la nota más baja.\r\n        Nota: Tenga en cuenta que el Estudiante puede tener entre 0 y n notas de examen.\r\n */\r\nuse std::cmp::min;\r\n\r\n#[derive(Debug, Default, PartialEq, Clone, PartialOrd)]\r\nstruct Examen {\r\n    materia: String,\r\n    nota: f32\r\n}\r\n\r\n#[derive(Debug, Default, PartialEq, Clone, PartialOrd)]\r\nstruct Estudiante {\r\n    nombre: String,\r\n    id: u32,\r\n    notas: Vec\u003cExamen\u003e\r\n}\r\n\r\nimpl Examen {\r\n    fn new(materia: String, nota: f32) -\u003e Option\u003cExamen\u003e {\r\n        if nota \u003e= 0.0 { return Some(Examen { materia, nota }) }\r\n        None\r\n    }\r\n\r\n}\r\n\r\n/*\r\n        Este informe debe incluir:\r\n        Nombre e identificación del estudiante.,\r\n        Cantidad total de exámenes rendidos.,\r\n        Promedio general de notas.,\r\n        Nota más alta y la materia correspondiente.,\r\n        Nota más baja y la materia correspondiente.\r\n */\r\nstruct InformeAcademico {\r\n    nombre: String,\r\n    examenes_rendidos: u16,\r\n    promedio_notas: Option\u003cf32\u003e,\r\n    max_nota: Option\u003cExamen\u003e,\r\n    min_nota: Option\u003cExamen\u003e\r\n}\r\n\r\nimpl InformeAcademico {\r\n    fn new(nombre: String, examenes_rendidos: u16, promedio_notas: Option\u003cf32\u003e, max_nota: Option\u003cExamen\u003e, min_nota: Option\u003cExamen\u003e) -\u003e Option\u003cInformeAcademico\u003e {\r\n        if examenes_rendidos != 0 \u0026\u0026 ( // si hay un examen rendido, todos los campos deben estar rellenos\r\n            promedio_notas.is_none()\r\n            || max_nota.is_none()\r\n            || min_nota.is_none()) {\r\n            return None;\r\n        }\r\n\r\n        Some(InformeAcademico { nombre, examenes_rendidos, promedio_notas, max_nota, min_nota })\r\n    }\r\n}\r\n\r\n\r\nimpl Estudiante {\r\n    fn new(nombre: String, id: u32, notas: Vec\u003cExamen\u003e) -\u003e Estudiante {\r\n        Estudiante { nombre, id, notas }\r\n    }\r\n\r\n    // ➢ obtener_promedio: retorna el promedio de las notas.\r\n    fn obtener_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        let cant_notas = self.notas.len();\r\n        let mut suma_notas: u16 = 0;\r\n\r\n        for examen in \u0026self.notas {\r\n            suma_notas+= examen.nota as u16;\r\n        }\r\n\r\n        if cant_notas != 0 { return Some(suma_notas as f32 / cant_notas as f32) }\r\n        None\r\n    }\r\n\r\n    // ➢ obtener_calificacion_mas_alta: retorna la nota más alta.\r\n    fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| a.nota.total_cmp(\u0026b.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    // ➢ obtener_calificacion_mas_baja: retorna la nota más baja.\r\n    fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| b.nota.total_cmp(\u0026a.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    /*\r\n        Deberán agregar una funcionalidad al ejercicio que permita retornar un informe detallado del rendimiento académico de un estudiante.\r\n\r\n        Este informe debe incluir:\r\n        Nombre e identificación del estudiante.,\r\n        Cantidad total de exámenes rendidos.,\r\n        Promedio general de notas.,\r\n        Nota más alta y la materia correspondiente.,\r\n        Nota más baja y la materia correspondiente.\r\n     */\r\n\r\n    /*\r\n        struct InformeAcademico {\r\n            nombre: String,\r\n            examenes_rendidos: u16,\r\n            promedio_notas: Option\u003cf32\u003e,\r\n            max_nota: Option\u003cExamen\u003e,\r\n            min_nota: Option\u003cExamen\u003e\r\n        }\r\n     */\r\n    fn generar_informe(\u0026self) -\u003e Option\u003cInformeAcademico\u003e {\r\n        let mut suma_total_notas: f32 = 0.0;\r\n        let mut min_nota: Option\u003c\u0026Examen\u003e = None;\r\n        let mut max_nota: Option\u003c\u0026Examen\u003e = None;\r\n\r\n        for examen in \u0026self.notas {\r\n            if min_nota.is_none() { min_nota = Some(examen) }\r\n            if max_nota.is_none() { max_nota = Some(examen) }\r\n\r\n            if examen.nota \u003c min_nota.unwrap().nota { min_nota = Some(examen); }\r\n            if examen.nota \u003c max_nota.unwrap().nota { max_nota = Some(examen); }\r\n\r\n            suma_total_notas+= examen.nota;\r\n        }\r\n\r\n        let promedio_notas: Option\u003cf32\u003e = match self.notas.len() {\r\n            0 =\u003e None,\r\n            cant_notas =\u003e Some(suma_total_notas / (cant_notas as f32))\r\n        };\r\n\r\n        InformeAcademico::new(\r\n            self.nombre.clone(),\r\n            self.notas.len() as u16,\r\n            promedio_notas,\r\n            max_nota.cloned(),\r\n            min_nota.cloned()\r\n        )\r\n    }\r\n\r\n}\r\n\r\nfn main() {\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{Estudiante, Examen};\r\n\r\n    #[test]\r\n    fn test() {\r\n        let examen1 = Examen::new(\"OC\".to_string(), 4.0);\r\n        let examen2 = Examen::new(\"Matematica 2\".to_string(), 7.0);\r\n\r\n        assert!(examen1.is_some(), \"Examen1 debería ser algo\");\r\n        assert!(examen2.is_some(), \"Examen2 debería ser algo\");\r\n\r\n        let nuevo_estudiante = Estudiante::new(\"jorgito\".to_string(), 29, vec![examen1.unwrap(), examen2.unwrap()]);\r\n\r\n        assert_eq!(nuevo_estudiante.nombre, \"jorgito\");\r\n        assert_eq!(nuevo_estudiante.id, 29);\r\n        assert_eq!(nuevo_estudiante.obtener_calificacion_mas_alta(), Some(7.0));\r\n        assert_eq!(nuevo_estudiante.obtener_calificacion_mas_baja(), Some(4.0));\r\n        assert_eq!(nuevo_estudiante.obtener_promedio(), Some(5.5));\r\n    }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej6","Fermin_Franco_v2.rs"],"content":"const CALIFICACION_MAXIMA: f32 = 10.0;\r\n\r\n/// ### Examen\r\n/// `materia: String` - Nombre de la materia del examen\u003cbr\u003e\r\n/// `nota: f32` - Calificación de un Estudiante en dicho examen\r\n#[derive(Debug, Default, PartialEq, Clone, PartialOrd)]\r\nstruct Examen {\r\n    materia: String,\r\n    nota: f32\r\n}\r\n\r\n/// ### Estudiante\r\n/// `nombre: String` - Nombre del estudiante\u003cbr\u003e\r\n/// `id: u32` - ID del estudiante\u003cbr\u003e\r\n/// `notas: Vec\u003cExamen\u003e` - Vector de exámenes que rindió el estudiante\r\n#[derive(Debug, Default, PartialEq, Clone, PartialOrd)]\r\nstruct Estudiante {\r\n    nombre: String,\r\n    id: u32,\r\n    notas: Vec\u003cExamen\u003e\r\n}\r\n\r\n/// ### InformeAcademico\u003cbr\u003e\r\n/// `nombre: String` - Nombre e identificación del estudiante\u003cbr\u003e\r\n/// `examenes_rendidos: u16` - Cantidad total de exámenes rendidos\u003cbr\u003e\r\n/// `promedio_notas: Option\u003cf32\u003e` - Promedio general de notas\u003cbr\u003e\r\n/// `max_nota: Option\u003c\u0026Examen\u003e` - Nota mas alta y la materia correspondiente\u003cbr\u003e\r\n/// `min_nota: Option\u003c\u0026Examen\u003e` - Nota más baja y la materia correspondiente\r\nstruct InformeAcademico\u003c'a\u003e {\r\n    nombre: String,\r\n    id: u32,\r\n    examenes_rendidos: u16,\r\n    promedio_notas: Option\u003cf32\u003e,\r\n    max_nota: Option\u003c\u0026'a Examen\u003e,\r\n    min_nota: Option\u003c\u0026'a Examen\u003e\r\n}\r\n\r\nimpl Examen {\r\n    /// ### new(materia, nota) -\u003e Option\\\u003cExamen\\\u003e\r\n    /// Crea y devuelve una nueva instancia de Examen si los datos proporcionados son válidos\r\n    /// \r\n    /// #### Recibe:\r\n    /// `materia: String` - Nombre de la materia del examen\u003cbr\u003e\r\n    /// `nota: f32` - Nota del estudiante en dicho examen\r\n    /// \r\n    /// #### Devuelve:\r\n    /// `Some(Examen)` - Examen que contiene toda la información recibida\u003cbr\u003e\r\n    /// `None` - Los datos recibidos no son válidos\r\n    /// \r\n    /// #### Excepciones inválidas:\r\n    /// `nota \u003c 0.0` - La nota debe ser un número positivo\u003cbr\u003e\r\n    /// `nota \u003e CALIFICACION_MAXIMA` - La nota debe ser menor o igual a la calificación máxima permitida\r\n    fn new(materia: String, nota: f32) -\u003e Option\u003cExamen\u003e {\r\n        if (0.0..=CALIFICACION_MAXIMA).contains(\u0026nota) { return Some(Examen { materia, nota }) }\r\n        None\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e InformeAcademico\u003c'a\u003e {\r\n    \r\n    /// ### fn new(nombre, examenes_rendidos, promedio_notas, max_nota, min_nota) -\u003e Option\\\u003cInformeAcademico\\\u003e\r\n    /// Crea y devuelve una nuvea instancia de InformeAcademico si los datos proporcionados son válidos\r\n    /// \r\n    /// #### Recibe:\r\n    /// `nombre` - Nombre del estudiante\u003cbr\u003e\r\n    /// `examenes_rendidos` - Cantidad de exámenes rendidos por el estudiante\u003cbr\u003e\r\n    /// `promedio_notas` - Promedio de exámenes rendidos\u003cbr\u003e\r\n    /// `max_nota` - Examen con mayor nota del estudiante\u003cbr\u003e\r\n    /// `min_nota` - Examen con menor nota del estudiante\r\n    /// \r\n    /// #### Devuelve:\r\n    /// `Some(InformeAcademico)` - Informe académico que contiene toda la información recibida\u003cbr\u003e\r\n    /// `None` - Hubo una incongruencia en los datos recibidos\r\n    /// \r\n    /// #### Incongruencias\r\n    /// `examenes_rendidos == 0` - Pero alguno de los datos (promedio, max_nota, min_nota) presenta información\u003cbr\u003e\r\n    /// `examenes_rendidos != 0` - Pero alguno de los datos (promedio, max_not, min_nota) no presenta información\r\n    fn new(nombre: String,\r\n           id: u32,\r\n           examenes_rendidos: u16,\r\n           promedio_notas: Option\u003cf32\u003e,\r\n           max_nota: Option\u003c\u0026'a Examen\u003e,\r\n           min_nota: Option\u003c\u0026'a Examen\u003e\r\n    ) -\u003e Option\u003cInformeAcademico\u003c'a\u003e\u003e {\r\n        \r\n        // Si hay al menos un examen rendido todos los campos deben ser Some()\r\n        if examenes_rendidos != 0 \u0026\u0026 (\r\n            promedio_notas.is_none()\r\n            || max_nota.is_none()\r\n            || min_nota.is_none()) {\r\n            return None;\r\n        }\r\n\r\n        // Caso opuesto. Si no hay exámenes rendidos todos los campos deben ser None\r\n        if examenes_rendidos == 0 \u0026\u0026 (\r\n            promedio_notas.is_some()\r\n            || max_nota.is_some()\r\n            || min_nota.is_some()) {\r\n            return None;\r\n        }\r\n\r\n        Some(InformeAcademico { nombre, id, examenes_rendidos, promedio_notas, max_nota, min_nota })\r\n    }\r\n}\r\n\r\nimpl Estudiante {\r\n    /// ### new(nombre, id, notas) -\u003e Estudiante\r\n    /// Crea una nueva instancia de Estudiante\r\n    fn new(nombre: String, id: u32, notas: Vec\u003cExamen\u003e) -\u003e Estudiante {\r\n        Estudiante { nombre, id, notas }\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_promedio() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la mayor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La calificación promedio del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        let cant_notas = self.notas.len();\r\n        let mut suma_notas: u16 = 0;\r\n\r\n        for examen in \u0026self.notas {\r\n            suma_notas+= examen.nota as u16;\r\n        }\r\n\r\n        if cant_notas != 0 { return Some(suma_notas as f32 / cant_notas as f32) }\r\n        None\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_mas_alta() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la mayor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La mayor calificación del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| a.nota.total_cmp(\u0026b.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_mas_baja() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la menor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La menor calificación del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| b.nota.total_cmp(\u0026a.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    /// ### fn generar_informe() -\u003e Option\u003cInformeAcademico\u003e\r\n    /// Procesa los datos del estudiante y devuelve un informe acorde.\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(InformeAcademico)` - Informe académico del alumno\u003cbr\u003e\r\n    /// `None` - Incongruencias no permitieron fabricar el informe académico\r\n    fn generar_informe(\u0026self) -\u003e Option\u003cInformeAcademico\u003e {\r\n        let mut suma_total_notas: f32 = 0.0;\r\n        let mut min_nota: Option\u003c\u0026Examen\u003e = None;\r\n        let mut max_nota: Option\u003c\u0026Examen\u003e = None;\r\n\r\n        /*\r\n            Sería posible utilizar las funciones ya existentes de la struct Estudiante:\r\n                fn obtener_calificacion_promedio() -\u003e Option\u003cf32\u003e\r\n                fn obtener_calificacion_mas_alta() -\u003e Option\u003cf32\u003e\r\n                fn obtener_calificacion_mas_baja() -\u003e Option\u003cf32\u003e\r\n            Pero en cada una se realiza una consulta individual al vector de exámenes del estudiante,\r\n            por lo que estaría recorrieno la misma información 3 veces, lo cual es absolutamente innecesario\r\n            entonces me resulta una mucho mejor idea prescindir de todas estas funciones.\r\n         */\r\n\r\n        for examen in \u0026self.notas {\r\n            match min_nota {\r\n                Some(val) =\u003e if examen.nota \u003c val.nota { min_nota = Some(examen) }\r\n                None =\u003e min_nota = Some(examen)\r\n            }\r\n\r\n            match max_nota {\r\n                Some(val) =\u003e if examen.nota \u003e val.nota { max_nota = Some(examen) }\r\n                None =\u003e max_nota = Some(examen)\r\n            }\r\n\r\n            suma_total_notas+= examen.nota;\r\n        }\r\n\r\n        let promedio_notas: Option\u003cf32\u003e = match self.notas.len() {\r\n            0 =\u003e None,\r\n            cant_notas =\u003e Some(suma_total_notas / (cant_notas as f32))\r\n        };\r\n\r\n        // Sólo puede \"fallar\" (devolver None) si:\r\n        //      self.notas != 0 \u0026\u0026 (promedio_notas != Some(f32) || max_nota != Some(Examen) || min_nota != Some(Examen))\r\n        //   || self.notas == 0 \u0026\u0026 (promedio_notas == Some(f32) || max_nota == Some(Examen) || min_nota == Some(Examen))\r\n        // lo cual, creo, es imposible.\r\n        InformeAcademico::new(\r\n            self.nombre.clone(),\r\n            self.id,\r\n            self.notas.len() as u16,\r\n            promedio_notas,\r\n            max_nota,\r\n            min_nota\r\n        )\r\n    }\r\n}\r\n\r\nfn main() { }\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{Estudiante, Examen};\r\n\r\n    fn estudiante() -\u003e Estudiante {\r\n        let examen1 = Examen::new(\"SdL Rust\".to_string(), 4.0);\r\n        let examen2 = Examen::new(\"AyED\".to_string(), 5.0);\r\n        let examen3 = Examen::new(\"FOD\".to_string(), 6.0);\r\n        let examen4 = Examen::new(\"Matematica 3\".to_string(), 7.0);\r\n\r\n        assert!(examen1.is_some(), \"Examen1 debería brindar Some(Examen)\");\r\n        assert!(examen2.is_some(), \"Examen2 debería brindar Some(Examen)\");\r\n        assert!(examen3.is_some(), \"Examen3 debería brindar Some(Examen)\");\r\n        assert!(examen4.is_some(), \"Examen4 debería brindar Some(Examen)\");\r\n\r\n        Estudiante::new(\"jorgito\".to_string(), 13548, vec![\r\n            examen1.unwrap(),\r\n            examen2.unwrap(),\r\n            examen3.unwrap(),\r\n            examen4.unwrap()])\r\n    }\r\n\r\n    #[test]\r\n    fn test_max_min_prom() {\r\n        let estudiante = estudiante();\r\n\r\n        assert_eq!(estudiante.obtener_calificacion_mas_alta(), Some(7.0));\r\n        assert_eq!(estudiante.obtener_calificacion_mas_baja(), Some(4.0));\r\n        assert_eq!(estudiante.obtener_calificacion_promedio(), Some(5.5));\r\n    }\r\n\r\n    #[test]\r\n    fn test_informe_academico_some() {\r\n        let estudiante = estudiante();\r\n        let informe = estudiante.generar_informe();\r\n\r\n        assert!(informe.is_some(), \"Informe debería brindar Some(InformeAcademico)\");\r\n\r\n        let informe = informe.unwrap();\r\n\r\n        let nombre_estudiante = informe.nombre;\r\n        let id_estudiante = informe.id;\r\n        let examenes_rendidos = informe.examenes_rendidos;\r\n\r\n        let min_nota = informe.min_nota;\r\n        let max_nota = informe.max_nota;\r\n        let promedio = informe.promedio_notas;\r\n\r\n        assert_eq!(nombre_estudiante, \"jorgito\".to_string(), \"El nombre se debe preservar\");\r\n        assert_eq!(id_estudiante, 13548, \"El nombre se debe preservar\");\r\n        assert_eq!(examenes_rendidos, 4, \"Se rindieron 4 exámenes\");\r\n\r\n        assert!(min_nota.is_some(), \"Debería existir nota mínima\");\r\n        assert!(max_nota.is_some(), \"Debería existir nota máxima\");\r\n        assert!(promedio.is_some(), \"Debería existir promedio\");\r\n\r\n        assert_eq!(min_nota.unwrap().nota, 4.0, \"La nota mínima debería ser 4.0\");\r\n        assert_eq!(max_nota.unwrap().nota, 7.0, \"La nota máxima debería ser 7.0\");\r\n        assert_eq!(promedio.unwrap(), 5.5, \"La nota promedio debería ser 5.5\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_informe_academico_none() {\r\n        let estudiante = Estudiante::new(\"jorgito\".to_string(), 29, Vec::new());\r\n        let informe = estudiante.generar_informe();\r\n\r\n        assert!(informe.is_some(), \"Informe debería brindar Some(InformeAcademico)\");\r\n\r\n        let informe = informe.unwrap();\r\n\r\n        assert_eq!(informe.examenes_rendidos, 0, \"No deberían existir exámenes rendidos\");\r\n        assert_eq!(informe.max_nota, None, \"No debería existir nota mínima\");\r\n        assert_eq!(informe.min_nota, None, \"No debería existir nota máxima\");\r\n        assert_eq!(informe.promedio_notas, None, \"No debería existir nota promedio\");\r\n    }\r\n}","traces":[{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej6","main.rs"],"content":"const CALIFICACION_MAXIMA: f32 = 10.0;\r\n\r\n/// ### Examen\r\n/// `materia: String` - Nombre de la materia del examen\u003cbr\u003e\r\n/// `nota: f32` - Calificación de un Estudiante en dicho examen\r\n#[derive(Debug, PartialEq)]\r\nstruct Examen\u003c'e\u003e {\r\n    materia: \u0026'e str,\r\n    nota: f32\r\n}\r\n\r\n/// ### Estudiante\r\n/// `nombre: String` - Nombre del estudiante\u003cbr\u003e\r\n/// `id: u32` - ID del estudiante\u003cbr\u003e\r\n/// `notas: Vec\u003cExamen\u003e` - Vector de exámenes que rindió el estudiante\r\nstruct Estudiante\u003c'a, 'e\u003e {\r\n    nombre: \u0026'a str,\r\n    id: u32,\r\n    notas: Vec\u003cExamen\u003c'e\u003e\u003e\r\n}\r\n\r\n/// ### InformeAcademico\u003cbr\u003e\r\n/// `nombre: String` - Nombre e identificación del estudiante\u003cbr\u003e\r\n/// `examenes_rendidos: u16` - Cantidad total de exámenes rendidos\u003cbr\u003e\r\n/// `promedio_notas: Option\u003cf32\u003e` - Promedio general de notas\u003cbr\u003e\r\n/// `max_nota: Option\u003c\u0026Examen\u003e` - Nota mas alta y la materia correspondiente\u003cbr\u003e\r\n/// `min_nota: Option\u003c\u0026Examen\u003e` - Nota más baja y la materia correspondiente\r\nstruct InformeAcademico\u003c'a, 'e\u003e {\r\n    nombre: \u0026'a str,\r\n    id: u32,\r\n    examenes_rendidos: u16,\r\n    promedio_notas: Option\u003cf32\u003e,\r\n    max_nota: Option\u003c\u0026'a Examen\u003c'e\u003e\u003e,\r\n    min_nota: Option\u003c\u0026'a Examen\u003c'e\u003e\u003e\r\n}\r\n\r\nimpl\u003c'e\u003e Examen\u003c'e\u003e {\r\n    /// ### new(materia, nota) -\u003e Option\\\u003cExamen\\\u003e\r\n    /// Crea y devuelve una nueva instancia de Examen si los datos proporcionados son válidos\r\n    /// \r\n    /// #### Recibe:\r\n    /// `materia: String` - Nombre de la materia del examen\u003cbr\u003e\r\n    /// `nota: f32` - Nota del estudiante en dicho examen\r\n    /// \r\n    /// #### Devuelve:\r\n    /// `Some(Examen)` - Examen que contiene toda la información recibida\u003cbr\u003e\r\n    /// `None` - Los datos recibidos no son válidos\r\n    /// \r\n    /// #### Excepciones inválidas:\r\n    /// `nota \u003c 0.0` - La nota debe ser un número positivo\u003cbr\u003e\r\n    /// `nota \u003e CALIFICACION_MAXIMA` - La nota debe ser menor o igual a la calificación máxima permitida\r\n    fn new(materia: \u0026str, nota: f32) -\u003e Option\u003cExamen\u003e {\r\n        if (0.0..=CALIFICACION_MAXIMA).contains(\u0026nota) { return Some(Examen { materia, nota }) }\r\n        None\r\n    }\r\n}\r\n\r\nimpl\u003c'a, 'e\u003e InformeAcademico\u003c'a, 'e\u003e {\r\n    \r\n    /// ### fn new(nombre, examenes_rendidos, promedio_notas, max_nota, min_nota) -\u003e Option\\\u003cInformeAcademico\\\u003e\r\n    /// Crea y devuelve una nuvea instancia de InformeAcademico si los datos proporcionados son válidos\r\n    /// \r\n    /// #### Recibe:\r\n    /// `nombre` - Nombre del estudiante\u003cbr\u003e\r\n    /// `examenes_rendidos` - Cantidad de exámenes rendidos por el estudiante\u003cbr\u003e\r\n    /// `promedio_notas` - Promedio de exámenes rendidos\u003cbr\u003e\r\n    /// `max_nota` - Examen con mayor nota del estudiante\u003cbr\u003e\r\n    /// `min_nota` - Examen con menor nota del estudiante\r\n    /// \r\n    /// #### Devuelve:\r\n    /// `Some(InformeAcademico)` - Informe académico que contiene toda la información recibida\u003cbr\u003e\r\n    /// `None` - Hubo una incongruencia en los datos recibidos\r\n    /// \r\n    /// #### Incongruencias\r\n    /// `examenes_rendidos == 0` - Pero alguno de los datos (promedio, max_nota, min_nota) presenta información\u003cbr\u003e\r\n    /// `examenes_rendidos != 0` - Pero alguno de los datos (promedio, max_not, min_nota) no presenta información\r\n    fn new(nombre: \u0026'a str,\r\n           id: u32,\r\n           examenes_rendidos: u16,\r\n           promedio_notas: Option\u003cf32\u003e,\r\n           max_nota: Option\u003c\u0026'e Examen\u003e,\r\n           min_nota: Option\u003c\u0026'e Examen\u003e\r\n    ) -\u003e Option\u003cInformeAcademico\u003c'a, 'e\u003e\u003e {\r\n        \r\n        // Si hay al menos un examen rendido todos los campos deben ser Some()\r\n        if examenes_rendidos != 0 \u0026\u0026 (\r\n            promedio_notas.is_none()\r\n            || max_nota.is_none()\r\n            || min_nota.is_none()) {\r\n            return None;\r\n        }\r\n\r\n        // Caso opuesto. Si no hay exámenes rendidos todos los campos deben ser None\r\n        if examenes_rendidos == 0 \u0026\u0026 (\r\n            promedio_notas.is_some()\r\n            || max_nota.is_some()\r\n            || min_nota.is_some()) {\r\n            return None;\r\n        }\r\n\r\n        Some(InformeAcademico { nombre, id, examenes_rendidos, promedio_notas, max_nota, min_nota })\r\n    }\r\n}\r\n\r\nimpl\u003c'a, 'e\u003e Estudiante\u003c'a, 'e\u003e {\r\n    /// ### new(nombre, id, notas) -\u003e Estudiante\r\n    /// Crea una nueva instancia de Estudiante\r\n    fn new(nombre: \u0026'a str, id: u32, notas: Vec\u003cExamen\u003c'e\u003e\u003e) -\u003e Estudiante\u003c'a, 'e\u003e {\r\n        Estudiante { nombre, id, notas }\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_promedio() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la mayor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La calificación promedio del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        let cant_notas = self.notas.len();\r\n        let mut suma_notas: u16 = 0;\r\n\r\n        for examen in \u0026self.notas {\r\n            suma_notas+= examen.nota as u16;\r\n        }\r\n\r\n        if cant_notas != 0 { return Some(suma_notas as f32 / cant_notas as f32) }\r\n        None\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_mas_alta() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la mayor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La mayor calificación del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| a.nota.total_cmp(\u0026b.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    /// ### fn obtener_calificacion_mas_baja() -\u003e Option\\\u003cf32\\\u003e\r\n    /// Devuelve la menor calificacion del estudiante\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(f32)` - La menor calificación del estudiante\u003cbr\u003e\r\n    /// `None` - El estudiante no tiene calificaciones\r\n    fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n        self.notas.iter().max_by(|a, b| b.nota.total_cmp(\u0026a.nota)).map(|val| val.nota)\r\n    }\r\n\r\n    /// ### fn generar_informe() -\u003e Option\u003cInformeAcademico\u003e\r\n    /// Procesa los datos del estudiante y devuelve un informe acorde.\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Some(InformeAcademico)` - Informe académico del alumno\u003cbr\u003e\r\n    /// `None` - Incongruencias no permitieron fabricar el informe académico\r\n    fn generar_informe(\u0026self) -\u003e Option\u003cInformeAcademico\u003e {\r\n        let mut suma_total_notas: f32 = 0.0;\r\n        let mut min_nota: Option\u003c\u0026Examen\u003e = None;\r\n        let mut max_nota: Option\u003c\u0026Examen\u003e = None;\r\n\r\n        /*\r\n            Sería posible utilizar las funciones ya existentes de la struct Estudiante:\r\n                fn obtener_calificacion_promedio() -\u003e Option\u003cf32\u003e\r\n                fn obtener_calificacion_mas_alta() -\u003e Option\u003cf32\u003e\r\n                fn obtener_calificacion_mas_baja() -\u003e Option\u003cf32\u003e\r\n            Pero en cada una se realiza una consulta individual al vector de exámenes del estudiante,\r\n            por lo que estaría recorrieno la misma información 3 veces, lo cual es absolutamente innecesario\r\n            entonces me resulta una mucho mejor idea prescindir de todas estas funciones.\r\n         */\r\n\r\n        for examen in \u0026self.notas {\r\n            match min_nota {\r\n                Some(val) =\u003e if examen.nota \u003c val.nota { min_nota = Some(examen) }\r\n                None =\u003e min_nota = Some(examen)\r\n            }\r\n\r\n            match max_nota {\r\n                Some(val) =\u003e if examen.nota \u003e val.nota { max_nota = Some(examen) }\r\n                None =\u003e max_nota = Some(examen)\r\n            }\r\n\r\n            suma_total_notas+= examen.nota;\r\n        }\r\n\r\n        let promedio_notas: Option\u003cf32\u003e = match self.notas.len() {\r\n            0 =\u003e None,\r\n            cant_notas =\u003e Some(suma_total_notas / (cant_notas as f32))\r\n        };\r\n\r\n        // Sólo puede \"fallar\" (devolver None) si:\r\n        //      self.notas != 0 \u0026\u0026 (promedio_notas != Some(f32) || max_nota != Some(Examen) || min_nota != Some(Examen))\r\n        //   || self.notas == 0 \u0026\u0026 (promedio_notas == Some(f32) || max_nota == Some(Examen) || min_nota == Some(Examen))\r\n        // lo cual, creo, es imposible.\r\n        InformeAcademico::new(\r\n            self.nombre,\r\n            self.id,\r\n            self.notas.len() as u16,\r\n            promedio_notas,\r\n            max_nota,\r\n            min_nota\r\n        )\r\n    }\r\n}\r\n\r\nfn main() { }\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{Estudiante, Examen};\r\n\r\n    fn estudiante\u003c'a, 'e\u003e() -\u003e Estudiante\u003c'a, 'e\u003e {\r\n        let examen1 = Examen::new(\"SdL Rust\", 4.0);\r\n        let examen2 = Examen::new(\"AyED\", 5.0);\r\n        let examen3 = Examen::new(\"FOD\", 6.0);\r\n        let examen4 = Examen::new(\"Matematica 3\", 7.0);\r\n\r\n        assert!(examen1.is_some(), \"Examen1 debería brindar Some(Examen)\");\r\n        assert!(examen2.is_some(), \"Examen2 debería brindar Some(Examen)\");\r\n        assert!(examen3.is_some(), \"Examen3 debería brindar Some(Examen)\");\r\n        assert!(examen4.is_some(), \"Examen4 debería brindar Some(Examen)\");\r\n\r\n        Estudiante::new(\"jorgito\", 13548, vec![\r\n            examen1.unwrap(),\r\n            examen2.unwrap(),\r\n            examen3.unwrap(),\r\n            examen4.unwrap()])\r\n    }\r\n\r\n    #[test]\r\n    fn test_max_min_prom() {\r\n        let estudiante = estudiante();\r\n\r\n        assert_eq!(estudiante.obtener_calificacion_mas_alta(), Some(7.0));\r\n        assert_eq!(estudiante.obtener_calificacion_mas_baja(), Some(4.0));\r\n        assert_eq!(estudiante.obtener_calificacion_promedio(), Some(5.5));\r\n    }\r\n\r\n    #[test]\r\n    fn test_informe_academico_some() {\r\n        let estudiante = estudiante();\r\n        let informe = estudiante.generar_informe();\r\n\r\n        assert!(informe.is_some(), \"Informe debería brindar Some(InformeAcademico)\");\r\n\r\n        let informe = informe.unwrap();\r\n\r\n        let nombre_estudiante = informe.nombre;\r\n        let id_estudiante = informe.id;\r\n        let examenes_rendidos = informe.examenes_rendidos;\r\n\r\n        let min_nota = informe.min_nota;\r\n        let max_nota = informe.max_nota;\r\n        let promedio = informe.promedio_notas;\r\n\r\n        assert_eq!(nombre_estudiante, \"jorgito\".to_string(), \"El nombre se debe preservar\");\r\n        assert_eq!(id_estudiante, 13548, \"El nombre se debe preservar\");\r\n        assert_eq!(examenes_rendidos, 4, \"Se rindieron 4 exámenes\");\r\n\r\n        assert!(min_nota.is_some(), \"Debería existir nota mínima\");\r\n        assert!(max_nota.is_some(), \"Debería existir nota máxima\");\r\n        assert!(promedio.is_some(), \"Debería existir promedio\");\r\n\r\n        assert_eq!(min_nota.unwrap().nota, 4.0, \"La nota mínima debería ser 4.0\");\r\n        assert_eq!(max_nota.unwrap().nota, 7.0, \"La nota máxima debería ser 7.0\");\r\n        assert_eq!(promedio.unwrap(), 5.5, \"La nota promedio debería ser 5.5\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_informe_academico_none() {\r\n        let estudiante = Estudiante::new(\"jorgito\", 29, Vec::new());\r\n        let informe = estudiante.generar_informe();\r\n\r\n        assert!(informe.is_some(), \"Informe debería brindar Some(InformeAcademico)\");\r\n\r\n        let informe = informe.unwrap();\r\n\r\n        assert_eq!(informe.examenes_rendidos, 0, \"No deberían existir exámenes rendidos\");\r\n        assert_eq!(informe.max_nota, None, \"No debería existir nota mínima\");\r\n        assert_eq!(informe.min_nota, None, \"No debería existir nota máxima\");\r\n        assert_eq!(informe.promedio_notas, None, \"No debería existir nota promedio\");\r\n    }\r\n}","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej7","main.rs"],"content":"\r\n/*\r\n    7- Defina una estructura llamada ConcesionarioAuto donde se conoce\r\n            nombre,\r\n            dirección\r\n            y tiene una capacidad máxima para albergar X cantidad de autos.\r\n        De los autos se conocen los campos de\r\n            marca,\r\n            modelo,\r\n            año,\r\n            precio bruto\r\n            y color que pueden ser:\r\n                rojo,\r\n                verde,\r\n                azul,\r\n                amarillo,\r\n                blanco,\r\n                negro.\r\n        Para dichas estructuras implemente los siguientes métodos:\r\n        ❖ ConcesionarioAuto:\r\n            ➢ new: que pasando los parámetros correspondientes, crea un ConcesionarioAuto y lo retorna.\r\n            ➢ agregar_auto(auto): agrega un auto a la lista de autos que tiene\r\n                sin superar la máxima cantidad para albergarlos\r\n                y retorna true, en caso de que lo supere no lo agrega y retorna false.\r\n            ➢ eliminar_auto(auto): elimina un auto de la lista de autos.\r\n            ➢ buscar_auto(auto): busca un auto y si lo encuentra lo retorna.\r\n        ❖ Auto:\r\n            ➢ new: que pasando los parámetros correspondientes, crea un Auto y lo retorna.\r\n            ➢ calcular_precio: retorna el precio del auto aplicando los siguientes criterios:\r\n                ■ si es de color primario le aplica un recargo del 25%, sino le aplica un descuento del 10%.\r\n                ■ si la marca es BMW le aplica un recargo del 15%-\r\n                ■ si el año es menor a 2000 le aplica un descuento del 5%.\r\n */\r\n\r\nstruct ConcesionarioAuto {\r\n    nombre: String,\r\n    direccion: String,\r\n    autos: Vec\u003cAuto\u003e\r\n}\r\n\r\n#[derive(PartialEq)]\r\nstruct Auto {\r\n    marca: String,\r\n    modelo: String,\r\n    ano: u16,\r\n    precio: f32,\r\n    color: Color\r\n}\r\n\r\n#[derive(PartialEq)]\r\nenum Color {\r\n    Rojo, Verde, Azul, Amarillo, Blanco, Negro\r\n}\r\n\r\nimpl ConcesionarioAuto {\r\n    // ➢ new: que pasando los parámetros correspondientes, crea un ConcesionarioAuto y lo retorna.\r\n    fn new(nombre: String, direccion: String, autos: Vec\u003cAuto\u003e) -\u003e ConcesionarioAuto {\r\n        ConcesionarioAuto { nombre, direccion, autos }\r\n    }\r\n\r\n    // ➢ agregar_auto(auto): agrega un auto a la lista de autos que tiene\r\n    //     sin superar la máxima cantidad para albergarlos\r\n    //     y retorna true, en caso de que lo supere no lo agrega y retorna false.\r\n    fn agregar_auto(\u0026mut self, auto: Auto) -\u003e bool {\r\n        if self.autos.len() == self.autos.capacity() { return false }\r\n        self.autos.push(auto);\r\n        true\r\n    }\r\n\r\n    // ➢ eliminar_auto(auto): elimina un auto de la lista de autos.\r\n    fn eliminar_auto(\u0026mut self, auto: Auto) {\r\n        self.autos.retain(|a| *a != auto);\r\n    }\r\n\r\n    // ➢ buscar_auto(auto): busca un auto y si lo encuentra lo retorna.\r\n    fn buscar_auto(\u0026self, auto: Auto) -\u003e Option\u003cAuto\u003e {\r\n        if self.autos.contains(\u0026auto) {\r\n            return Some(auto)\r\n        }\r\n        None\r\n    }\r\n}\r\n\r\nimpl Auto {\r\n    // ➢ new: que pasando los parámetros correspondientes, crea un Auto y lo retorna.\r\n    fn new(marca: String, modelo: String, ano: u16, precio: f32, color: Color) -\u003e Auto {\r\n        Auto { marca, modelo, ano, precio, color }\r\n    }\r\n\r\n    // ➢ calcular_precio: retorna el precio del auto aplicando los siguientes criterios:\r\n    fn calcular_precio(\u0026self) -\u003e f32 {\r\n        let mut precio = self.precio;\r\n\r\n        // ■ si es de color primario le aplica un recargo del 25%, sino le aplica un descuento del 10%.\r\n        match self.color {\r\n            Color::Rojo | Color::Azul | Color::Amarillo =\u003e precio*= 1.25,\r\n            _ =\u003e precio/= 0.9\r\n        }\r\n\r\n        // ■ si la marca es BMW le aplica un recargo del 15%\r\n        if self.marca == \"BMW\" { precio*= 1.15 }\r\n\r\n        // ■ si el año es menor a 2000 le aplica un descuento del 5%.\r\n        if self.ano \u003c 2000 { precio*= 0.95 }\r\n\r\n        precio\r\n    }\r\n}\r\n\r\n\r\n\r\nfn main() {\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej8","main.rs"],"content":"\r\n/*\r\n    8- Defina la estructura Cancion con campos para\r\n        - título\r\n        - artista\r\n        - el género.\r\n    El género puede ser:\r\n        - rock\r\n        - pop\r\n        - rap\r\n        - jazz\r\n        - otros.\r\n    Luego modele una playlist.\r\n    La playlist está compuesta por una lista de canciones y un nombre\r\n    y se permiten hacer las siguientes acciones sobre ella:\r\n        ➔ agregar canción.\r\n        ➔ eliminar canción.\r\n        ➔ mover canción // mueve la canción a una determinada posición de la playlist.\r\n        ➔ buscar canción por nombre.\r\n        ➔ obtener las canciones de un determinado género.\r\n        ➔ obtener las canciones de un determinado artista.\r\n        ➔ modificar título de la playlist.\r\n        ➔ eliminar todas las canciones.\r\n */\r\nuse std::cmp::PartialEq;\r\n\r\n#[derive(PartialEq, Clone, Debug)]\r\nenum Genero {\r\n    Rock, Pop, Rap, Jazz, Otros\r\n}\r\n\r\n#[derive(PartialEq, Clone, Debug)]\r\nstruct Cancion {\r\n    titulo: String,\r\n    artista: String,\r\n    genero: Genero,\r\n}\r\n\r\nstruct Playlist {\r\n    nombre: String,\r\n    canciones: Vec\u003cCancion\u003e\r\n}\r\n\r\nimpl Cancion {\r\n    fn new(titulo: String, artista: String, genero: Genero) -\u003e Cancion {\r\n        Cancion { titulo, artista, genero }\r\n    }\r\n}\r\n\r\nimpl Playlist {\r\n\r\n    fn new(nombre: String) -\u003e Playlist {\r\n        Playlist { nombre, canciones: Vec::new() }\r\n    }\r\n\r\n    // ➔ agregar canción.\r\n    fn agregar_cancion(\u0026mut self, cancion: Cancion) {\r\n        self.canciones.push(cancion);\r\n    }\r\n\r\n    // ➔ eliminar canción.\r\n    fn eliminar_cancion(\u0026mut self, cancion: \u0026Cancion) {\r\n        self.canciones.retain_mut(|c| *c != *cancion);\r\n    }\r\n\r\n    // ➔ mover canción: mueve la canción a una determinada posición de la playlist.\r\n    fn mover_cancion(\u0026mut self, cancion: Cancion, posicion: usize) {\r\n        if posicion \u003e self.canciones.len()  { return; }\r\n        self.eliminar_cancion(\u0026cancion);\r\n        self.canciones.insert(posicion - 1,  cancion);\r\n    }\r\n\r\n    // ➔ buscar canción por nombre.\r\n    fn buscar_cancion(\u0026self, nombre_cancion: \u0026str) -\u003e Option\u003c\u0026Cancion\u003e {\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.titulo == nombre_cancion {\r\n                return Some(cancion)\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    // ➔ obtener las canciones de un determinado género.\r\n    fn listar_canciones_genero(\u0026self, genero: \u0026Genero) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n        let mut vec: Vec\u003c\u0026Cancion\u003e = Vec::new();\r\n\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.genero == *genero {\r\n                vec.push(cancion);\r\n            }\r\n        }\r\n\r\n        vec\r\n    }\r\n\r\n    // ➔ obtener las canciones de un determinado artista.\r\n    fn listar_canciones_artista(\u0026self, artista: \u0026str) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n        let mut vec: Vec\u003c\u0026Cancion\u003e = Vec::new();\r\n\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.artista == artista {\r\n                vec.push(cancion);\r\n            }\r\n        }\r\n\r\n        vec\r\n    }\r\n\r\n    // ➔ modificar título de la playlist.\r\n    fn modificar_titulo(\u0026mut self, titulo: String) {\r\n        self.nombre = titulo;\r\n    }\r\n\r\n    // ➔ eliminar todas las canciones.\r\n    fn clear(\u0026mut self) {\r\n        self.canciones.clear();\r\n    }\r\n\r\n}\r\n\r\nfn main() {\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::cmp::PartialEq;\r\n    use crate::{Cancion, Genero, Playlist};\r\n\r\n    impl PartialEq\u003cCancion\u003e for \u0026Cancion {\r\n        fn eq(\u0026self, cancion: \u0026Cancion) -\u003e bool {\r\n            cancion.titulo == self.titulo\r\n            \u0026\u0026 cancion.artista == self.artista\r\n            \u0026\u0026 cancion.genero == self.genero\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test() {\r\n        let mut mi_playlist = Playlist::new(\"platuka\".to_string());\r\n\r\n        let mi_cancion_1 = Cancion::new(\"Un siglo sin tí\".to_string(), \"Chayanne\".to_string(), Genero::Pop);\r\n        let mi_cancion_2 = Cancion::new(\"Mi abuela\".to_string(), \"Molotov\".to_string(), Genero::Rap);\r\n        let mi_cancion_3 = Cancion::new(\"Te odio y te quiero\".to_string(), \"Julio Jaramillo\".to_string(), Genero::Otros);\r\n        let mi_cancion_4 = Cancion::new(\"Fatalidad\".to_string(), \"Julio Jaramillo\".to_string(), Genero::Otros);\r\n\r\n        mi_playlist.agregar_cancion(mi_cancion_1.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_2.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_3.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_4.clone());\r\n\r\n        // test agregado\r\n        assert_eq!(mi_playlist.listar_canciones_genero(\u0026Genero::Otros).len(), 2, \"Deberían haber 2 canciones de género \\\"otros\\\"\");\r\n\r\n        // test mover\r\n        mi_playlist.mover_cancion(mi_cancion_1.clone(), 4);\r\n        assert_eq!(mi_playlist.canciones.get(3).unwrap(), mi_cancion_1, \"La canción no parece haberse movido...\");\r\n\r\n        // test buscar genero\r\n        assert_eq!(mi_playlist.listar_canciones_genero(\u0026Genero::Otros).len(), 2, \"Deberían haber 2 canciones en género Otros\");\r\n\r\n        // test clear\r\n        mi_playlist.clear();\r\n        assert_eq!(mi_playlist.canciones.len(), 0, \"La playlist debería estar vacía\");\r\n    }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej9","impls.rs"],"content":"/*\r\nDado todo lo mencionado anteriormente implemente los métodos para realizar las siguientes acciones:\r\n    ➔ crear una veterinaria.\r\n    ➔ agregar una nueva mascota a la cola de atención de la veterinaria.\r\n    ➔ agregar una nueva mascota a la cola de atención pero que sea la siguiente en atender porque tiene la máxima prioridad.\r\n    ➔ atender la próxima mascota de la cola.\r\n    ➔ eliminar una mascota específica de la cola de atención dado que se retira.\r\n    ➔ registrar una atención.\r\n    ➔ buscar una atención dado el nombre de la mascota, el nombre del dueño y el teléfono.\r\n    ➔ modificar el diagnóstico de una determinada atención.\r\n    ➔ modificar la fecha de la próxima visita de una determinada atención.\r\n    ➔ eliminar una determinada atención.\r\n */\r\nuse std::collections::VecDeque;\r\npub(crate) use crate::structs::{Atencion, Fecha, Mascota, Veterinaria};\r\n\r\nimpl Veterinaria {\r\n\r\n    // ➔ crear una veterinaria.\r\n    pub fn new(nombre: String, direccion: String, id: i32, cola: Option\u003cVecDeque\u003cMascota\u003e\u003e, atenciones: Option\u003cVec\u003cAtencion\u003e\u003e) -\u003e Veterinaria {\r\n        Veterinaria { nombre, direccion, id, cola: cola.unwrap_or_default(), atenciones: atenciones.unwrap_or_default() }\r\n    }\r\n\r\n    // ➔ agregar una nueva mascota a la cola de atención de la veterinaria.\r\n    pub fn agregar_mascota(\u0026mut self, mascota: Mascota) {\r\n        self.cola.push_back(mascota);\r\n    }\r\n\r\n    // ➔ agregar una nueva mascota a la cola de atención pero que sea la siguiente en atender porque tiene la máxima prioridad.\r\n    pub fn agregar_mascota_prioridad(\u0026mut self, mascota: Mascota) {\r\n        self.cola.push_front(mascota);\r\n    }\r\n\r\n    // ➔ atender la próxima mascota de la cola.\r\n    pub fn atender_proxima_mascota(\u0026mut self) -\u003e Option\u003cMascota\u003e {\r\n        self.cola.pop_front()\r\n    }\r\n\r\n    // ➔ eliminar una mascota específica de la cola de atención dado que se retira.\r\n    pub fn eliminar_mascota(\u0026mut self, mascota: Mascota) {\r\n        self.cola.retain(|m| *m != mascota);\r\n    }\r\n    \r\n    // ➔ registrar una atención.\r\n    pub fn registrar_atencion(\u0026mut self, atencion: Atencion) {\r\n        self.atenciones.push(atencion);\r\n    }\r\n\r\n    /// Searches for an Atencion by Mascota's name and Dueno's details.\r\n    ///\r\n    /// # Arguments\r\n    /// * `mascota_nombre` - The name of the Mascota.\r\n    /// * `dueno_nombre` - The name of the Dueno.\r\n    /// * `telefono` - The Dueno's phone number.\r\n    ///\r\n    /// # Returns\r\n    /// * `Some(\u0026Atencion)` - If an Atencion is found.\r\n    /// * `None` - If no match is found.\r\n    pub fn buscar_atencion(\r\n        \u0026self,\r\n        mascota_nombre: String,\r\n        dueno_nombre: String,\r\n        telefono: u64,\r\n    ) -\u003e Option\u003c\u0026Atencion\u003e {\r\n        self.atenciones.iter().find(|atencion| {\r\n            atencion.mascota.nombre == mascota_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.nombre == dueno_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.telefono == telefono\r\n        })\r\n    }\r\n\r\n    /// Searches for an Atencion by Mascota's name and Dueno's details.\r\n    ///\r\n    /// # Arguments\r\n    /// * `mascota_nombre` - The name of the Mascota.\r\n    /// * `dueno_nombre` - The name of the Dueno.\r\n    /// * `telefono` - The Dueno's phone number.\r\n    ///\r\n    /// # Returns\r\n    /// * `Some(\u0026mut Atencion)` - If an Atencion is found.\r\n    /// * `None` - If no match is found.\r\n    pub fn buscar_atencion_mut(\r\n        \u0026mut self,\r\n        mascota_nombre: String,\r\n        dueno_nombre: String,\r\n        telefono: u64,\r\n    ) -\u003e Option\u003c\u0026mut Atencion\u003e {\r\n        self.atenciones.iter_mut().find(|atencion| {\r\n            atencion.mascota.nombre == mascota_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.nombre == dueno_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.telefono == telefono\r\n        })\r\n    }\r\n    \r\n    /// Deletes an Atencion record from the Veterinaria records\r\n    ///\r\n    /// # Arguments\r\n    /// * `atencion` - A reference to the Atencion to delete\r\n    ///\r\n    /// # Returns\r\n    /// `Some(Atencion)` - The deleted Atencion\r\n    /// `None` - If no match is found\r\n    ///\r\n    /// # Notes\r\n    /// Requires `PartialEq` on Atencion for comparison\r\n    pub fn eliminar_atencion(\r\n        \u0026mut self,\r\n        atencion: \u0026Atencion\r\n    ) -\u003e Option\u003cAtencion\u003e {\r\n        if let Some(index) = self.atenciones.iter().position(|a| a == atencion) {\r\n            return Some(self.atenciones.remove(index));\r\n        }\r\n        None\r\n    }\r\n}\r\n\r\nimpl Atencion {\r\n\r\n    // ➔ modificar el diagnóstico de una determinada atención.\r\n    pub fn modificar_diagnostico_atencion(\u0026mut self, nuevo_diagnostico: String) {\r\n        self.diagnostico = nuevo_diagnostico;\r\n    }\r\n\r\n    // ➔ modificar la fecha de la próxima visita de una determinada atención.\r\n    pub fn modificar_fecha_atencion(\u0026mut self, nueva_fecha: Fecha) {\r\n        self.proxima_visita = nueva_fecha;\r\n    }\r\n    \r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::collections::VecDeque;\r\n    use crate::structs::{Animal, Atencion, Dueno, Fecha, Mascota, Veterinaria};\r\n\r\n    fn veterinaria_de_pepe() -\u003e Veterinaria {\r\n        // Crear dueños\r\n        let dueno1 = Dueno {\r\n            nombre: String::from(\"Juan Pérez\"),\r\n            direccion: String::from(\"Calle 123\"),\r\n            telefono: 1234567890,\r\n        };\r\n        let dueno2 = Dueno {\r\n            nombre: String::from(\"María Gómez\"),\r\n            direccion: String::from(\"Avenida 456\"),\r\n            telefono: 9876543210,\r\n        };\r\n        let dueno3 = Dueno {\r\n            nombre: String::from(\"Carlos López\"),\r\n            direccion: String::from(\"Carrera 789\"),\r\n            telefono: 5555555555,\r\n        };\r\n\r\n        // Crear mascotas para la cola\r\n        let mascota1 = Mascota {\r\n            nombre: String::from(\"Max\"),\r\n            edad: 3,\r\n            animal: Animal::Perro,\r\n            dueno: dueno1,\r\n        };\r\n        let mascota2 = Mascota {\r\n            nombre: String::from(\"Luna\"),\r\n            edad: 2,\r\n            animal: Animal::Gato,\r\n            dueno: dueno2,\r\n        };\r\n        let mascota3 = Mascota {\r\n            nombre: String::from(\"Tormenta\"),\r\n            edad: 5,\r\n            animal: Animal::Caballo,\r\n            dueno: dueno3,\r\n        };\r\n\r\n        // Crear fechas para atenciones\r\n        let fecha1 = Fecha { dia: 15, mes: 10, ano: 2023 };\r\n        let fecha2 = Fecha { dia: 20, mes: 10, ano: 2023 };\r\n        let fecha3 = Fecha { dia: 25, mes: 10, ano: 2023 };\r\n\r\n        // Crear atenciones\r\n        let atencion1 = Atencion {\r\n            mascota: mascota1.clone(),\r\n            diagnostico: String::from(\"Resfriado leve\"),\r\n            tratamiento: String::from(\"Antibióticos\"),\r\n            proxima_visita: fecha1,\r\n        };\r\n        let atencion2 = Atencion {\r\n            mascota: mascota2.clone(),\r\n            diagnostico: String::from(\"Infección ocular\"),\r\n            tratamiento: String::from(\"Gotas\"),\r\n            proxima_visita: fecha2,\r\n        };\r\n        let atencion3 = Atencion {\r\n            mascota: mascota3.clone(),\r\n            diagnostico: String::from(\"Cojeo\"),\r\n            tratamiento: String::from(\"Reposo\"),\r\n            proxima_visita: fecha3,\r\n        };\r\n\r\n        // Crear la veterinaria con cola y atenciones\r\n        Veterinaria {\r\n            nombre: String::from(\"Pepe's Pet Shop\"),\r\n            direccion: String::from(\"Calle Principal 100\"),\r\n            id: 1,\r\n            cola: VecDeque::from([mascota1, mascota2, mascota3]),\r\n            atenciones: vec![atencion1, atencion2, atencion3],\r\n        }\r\n    }\r\n\r\n    /*\r\n        let dueno1 = Dueno {\r\n            nombre: String::from(\"Juan Pérez\"),\r\n            direccion: String::from(\"Calle 123\"),\r\n            telefono: 1234567890,\r\n        };\r\n\r\n        let mascota1 = Mascota {\r\n            nombre: String::from(\"Max\"),\r\n            edad: 3,\r\n            animal: Animal::Perro,\r\n            dueno: dueno1,\r\n        };\r\n\r\n        let fecha1 = Fecha { dia: 15, mes: 10, ano: 2023 };\r\n\r\n        let atencion1 = Atencion {\r\n            mascota: mascota1.clone(),\r\n            diagnostico: String::from(\"Resfriado leve\"),\r\n            tratamiento: String::from(\"Antibióticos\"),\r\n            proxima_visita: fecha1,\r\n        };\r\n\r\n        Veterinaria {\r\n            nombre: String::from(\"Pepe's Pet Shop\"),\r\n            direccion: String::from(\"Calle Principal 100\"),\r\n            id: 1,\r\n            cola: VecDeque::from([mascota1, mascota2, mascota3]),\r\n            atenciones: vec![atencion1, atencion2, atencion3],\r\n        }\r\n     */\r\n\r\n    #[test]\r\n    fn test_atencion() {\r\n        let mut veterinaria = veterinaria_de_pepe();\r\n\r\n        // Verificar contenido\r\n        println!(\"Veterinaria: {}\", veterinaria.nombre);\r\n        println!(\"Cola: {:?}\", veterinaria.cola);\r\n        println!(\"Atenciones: {:?}\", veterinaria.atenciones);\r\n\r\n        // Buscar\r\n\r\n        let atencion = veterinaria.buscar_atencion_mut(\"Max\".to_string(), \"Juan Pérez\".to_string(), 1234567890);\r\n        assert!(atencion.is_some(), \"La atención no puede no existir\");\r\n        let atencion = atencion.unwrap();\r\n\r\n        atencion.modificar_diagnostico_atencion(\"jijodebu en los jijolines jijox\".to_string());\r\n\r\n        println!(\"Atenciones: {:?}\", veterinaria.atenciones);\r\n    }\r\n\r\n    #[test]\r\n    fn test_agregar_eliminar() {\r\n        let mut veterinaria = veterinaria_de_pepe();\r\n\r\n        let dueno1 = Dueno {\r\n            nombre: String::from(\"Enrique Ibañez\"),\r\n            direccion: String::from(\"Calle 437\"),\r\n            telefono: 1234567890,\r\n        };\r\n\r\n        let mascota1 = Mascota {\r\n            nombre: String::from(\"Rodolfo\"),\r\n            edad: 7,\r\n            animal: Animal::Caballo,\r\n            dueno: dueno1,\r\n        };\r\n\r\n        veterinaria.agregar_mascota(mascota1.clone());\r\n\r\n        println!(\"{:?}\", veterinaria.cola);\r\n        assert_eq!(veterinaria.cola.len(), 4, \"Deberían haber 4 mascotas en total.\");\r\n\r\n        veterinaria.agregar_mascota_prioridad(mascota1.clone());\r\n        let prox_mascota = veterinaria.atender_proxima_mascota();\r\n        assert!(prox_mascota.is_some(), \"Debe existir una próxima mascota\");\r\n        assert_eq!(prox_mascota.unwrap(), mascota1, \"La primer mascota en la fila debería ser la misma mascota que se agregó con prioridad\");\r\n\r\n        println!(\"{:?}\", veterinaria.eliminar_mascota(mascota1));\r\n\r\n        assert_eq!(veterinaria.cola.len(), 3, \"La lista de mascotas debería haber vuelto a su estado original (3 items).\");\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej9","main.rs"],"content":"/*\r\n    9.-Dada una cadena de veterinarias se desea implementar un sistema de atención de pacientes para cada veterinaria.\r\n        De la veterinaria se conoce \r\n            - nombre\r\n            - la dirección\r\n            - un id.\r\n        Para la atención de mascotas se requiere administrar una cola de atención.\r\n        De la mascota se conoce\r\n            - nombre\r\n            - edad\r\n            - tipo de animal (perro, gato, caballo, otros)\r\n            - su dueño.\r\n        Del dueño se conoce\r\n            - nombre\r\n            - direccion\r\n            - teléfono de contacto.\r\n        Luego de la atención se desea tener un registro de las atenciones realizadas guardando:\r\n            - datos de la mascota\r\n            - el diagnóstico final\r\n            - tratamiento\r\n            - fecha de la próxima visita si es que se requiere.\r\n        Dado todo lo mencionado anteriormente implemente los métodos para realizar las siguientes acciones:\r\n            ➔ crear una veterinaria.\r\n            ➔ agregar una nueva mascota a la cola de atención de la veterinaria.\r\n            ➔ agregar una nueva mascota a la cola de atención pero que sea la siguiente en atender porque tiene la máxima prioridad.\r\n            ➔ atender la próxima mascota de la cola.\r\n            ➔ eliminar una mascota específica de la cola de atención dado que se retira.\r\n            ➔ registrar una atención.\r\n            ➔ buscar una atención dado el nombre de la mascota, el nombre del dueño y el teléfono.\r\n            ➔ modificar el diagnóstico de una determinada atención.\r\n            ➔ modificar la fecha de la próxima visita de una determinada atención.\r\n            ➔ eliminar una determinada atención.\r\n        Nota: para la fecha utilice lo implementado en el punto 3.\r\n */\r\n\r\nmod structs;\r\nmod impls;\r\n\r\nfn main() {\r\n    \r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","ej9","structs.rs"],"content":"/*\r\n    9.-Dada una cadena de veterinarias se desea implementar un sistema de atención de pacientes para cada veterinaria.\r\n        De la veterinaria se conoce\r\n            - nombre\r\n            - la dirección\r\n            - un id.\r\n        Para la atención de mascotas se requiere administrar una cola de atención.\r\n        De la mascota se conoce\r\n            - nombre\r\n            - edad\r\n            - tipo de animal (perro, gato, caballo, otros)\r\n            - su dueño.\r\n        Del dueño se conoce\r\n            - nombre\r\n            - direccion\r\n            - teléfono de contacto.\r\n        Luego de la atención se desea tener un registro de las atenciones realizadas guardando:\r\n            - datos de la mascota\r\n            - el diagnóstico final\r\n            - tratamiento\r\n            - fecha de la próxima visita si es que se requiere.\r\n        Dado todo lo mencionado anteriormente implemente los métodos para realizar las siguientes acciones:\r\n            ➔ crear una veterinaria.\r\n            ➔ agregar una nueva mascota a la cola de atención de la veterinaria.\r\n            ➔ agregar una nueva mascota a la cola de atención pero que sea la siguiente en atender porque tiene la máxima prioridad.\r\n            ➔ atender la próxima mascota de la cola.\r\n            ➔ eliminar una mascota específica de la cola de atención dado que se retira.\r\n            ➔ registrar una atención.\r\n            ➔ buscar una atención dado el nombre de la mascota, el nombre del dueño y el teléfono.\r\n            ➔ modificar el diagnóstico de una determinada atención.\r\n            ➔ modificar la fecha de la próxima visita de una determinada atención.\r\n            ➔ eliminar una determinada atención.\r\n        Nota: para la fecha utilice lo implementado en el punto 3.\r\n */\r\nuse std::collections::VecDeque;\r\n\r\n// De la veterinaria se conoce\r\n// - nombre\r\n// - la dirección\r\n// - un id.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Veterinaria {\r\n    pub nombre: String,\r\n    pub direccion: String,\r\n    pub id: i32,\r\n    pub cola: VecDeque\u003cMascota\u003e,\r\n    pub atenciones: Vec\u003cAtencion\u003e\r\n}\r\n\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub enum Animal {\r\n    Perro, Gato, Caballo,\r\n    #[default] Otros\r\n}\r\n\r\n// De la mascota se conoce\r\n// - nombre\r\n// - edad\r\n// - tipo de animal (perro, gato, caballo, otros)\r\n// - su dueño.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Mascota {\r\n    pub nombre: String,\r\n    pub edad: u16,\r\n    pub animal: Animal,\r\n    pub dueno: Dueno,\r\n}\r\n\r\n// Del dueño se conoce\r\n// - nombre\r\n// - direccion\r\n// - teléfono de contacto.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Dueno {\r\n    pub nombre: String,\r\n    pub direccion: String,\r\n    pub telefono: u64,\r\n}\r\n\r\n// Luego de la atención se desea tener un registro de las atenciones realizadas guardando:\r\n// - datos de la mascota\r\n// - el diagnóstico final\r\n// - tratamiento\r\n// - fecha de la próxima visita si es que se requiere.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Atencion {\r\n    pub mascota: Mascota,\r\n    pub diagnostico: String,\r\n    pub tratamiento: String,\r\n    pub proxima_visita: Fecha,\r\n}\r\n\r\n// Nota: para la fecha utilice lo implementado en el punto 3.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Fecha {\r\n    pub dia: u8,\r\n    pub mes: u8,\r\n    pub ano: i64\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac3","src","main.rs"],"content":"\r\nfn main() {\r\n    println!(\"Hello, world!\");\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    \r\n    \r\n    \r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej1","main.rs"],"content":"/*\r\n    1- Escriba una función que reciba un vector de números enteros y retorna la cantidad de números primos.\r\n        Cree un trait para la determinación del número primo e impleméntelo según corresponda.\r\n        Utilice la función iter sobre el vector y aplique un closure para resolverlo.\r\n */\r\n\r\npub trait VerificadorPrimos {\r\n    fn contar_primos(\u0026self) -\u003e usize;\r\n}\r\n\r\npub trait VerificarPrimo {\r\n    fn es_primo(\u0026self) -\u003e bool;\r\n}\r\n\r\nimpl\u003cT\u003e VerificadorPrimos for Vec\u003cT\u003e where T: Copy + Into\u003ci128\u003e\r\n{\r\n    fn contar_primos(\u0026self) -\u003e usize {\r\n        self.iter().filter(\r\n            |\u0026\u0026n| { // closure\r\n                let n_i64: i128 = n.into();\r\n                n_i64.es_primo()\r\n            }\r\n        ).count()\r\n    }\r\n}\r\n\r\nimpl\u003cT\u003e VerificarPrimo for T where T: Copy + Into\u003ci128\u003e {\r\n    fn es_primo(\u0026self) -\u003e bool {\r\n        let num: i128 = (*self).into();\r\n        if num % 2 == 0 { return false }\r\n        \r\n        // no me interesa si es divisible por 1\r\n        // sé que no es divisible por 2\r\n        // por eso el primer número es 3\r\n        for n in 3..num.abs() {\r\n            if num % n == 0 { return false }\r\n        }\r\n\r\n        true\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let numero = 503213131.es_primo();\r\n    let vec_numero: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5];\r\n    \r\n    println!(\"{}\", numero.es_primo());\r\n    println!(\"{:?}\", vec_numero.contar_primos());\r\n    \r\n    let mut string_comun = String::from(\"asdasdas\");\r\n    let mi_str = \"esto es un \u0026str\";\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::VerificadorPrimos;\r\n\r\n    #[test]\r\n    fn test() {\r\n        let i_vec: Vec\u003ci32\u003e = vec![-5, -10, 5, 10];\r\n        let u_vec: Vec\u003cu32\u003e = vec![5, 10, 5, 10];\r\n        let p_vec: Vec\u003cu32\u003e = vec![0, 2, 4, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30];\r\n\r\n        assert_eq!(i_vec.contar_primos(), 2, \"Deberían haber 2 primos en el vector\");\r\n        assert_eq!(u_vec.contar_primos(), 2, \"Deberian haber 2 primos en el vector\");\r\n        assert_eq!(p_vec.contar_primos(), 0, \"No deberían haber primos en el vector\");\r\n    }\r\n\r\n}","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej2","main.rs"],"content":"\r\n/*\r\n\r\n2- Dado el siguiente struct:\r\n    struct Persona\u003c'a\u003e {\r\n        nombre:\u0026'a str,\r\n        apellido:\u0026'a str,\r\n        direccion:\u0026'a str,\r\n        ciudad:\u0026'a str,\r\n        salario:f64,\r\n        edad:u8,\r\n    }\r\na- Escriba una función que reciba un vector de personas y otro parámetro que indica un salario y retorna un listado de personas donde el salario es mayor al parámetro recibido.\r\nb- Escriba una función que reciba un vector de personas, edad y el nombre de una ciudad, y retorna las personas mayores al parámetro edad y que viven en el valor del parámetro ciudad.\r\nc- Escriba una función que reciba un vector de personas y un nombre de una ciudad y retorna true si todas las personas viven en la ciudad pasada por parámetro, false caso contrario.\r\nd- Escriba una función que reciba un vector de personas y un nombre de una ciudad y retorna true si al menos vive una persona en la ciudad pasada por parámetro,, false caso contrario.\r\ne- Escriba una función que reciba un arreglo de personas y una persona y retorna true si la persona existe en el arreglo, false caso contrarioUNLP. Facultad de Informática.\r\nSeminario de Lenguajes opción Rust Cursada 2023\r\nf -Escriba una función que reciba un arreglo de personas y retorna un arreglo con las edades de las personas.\r\ng - Escriba una función que reciba un arreglo de personas y retorna la persona con el menor salario y la persona con el mayor salario, en caso de que haya más de una persona en cada categoría desempatar por la edad más grande.\r\n\r\nNota: Implemente todos los métodos y traits que considere para resolver los ejercicios.\r\n    Todos los ejercicios deben resolverse con iterator y closure.\r\n\r\n */\r\n\r\n#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]\r\nstruct Persona\u003c'a\u003e {\r\n    nombre:\u0026'a str,\r\n    apellido:\u0026'a str,\r\n    direccion:\u0026'a str,\r\n    ciudad:\u0026'a str,\r\n    salario:f64,\r\n    edad:u8,\r\n}\r\n\r\ntrait VecPersona\u003c'a\u003e {\r\n    fn a_personas_salario_mayor(\u0026'a self, num: f64) -\u003e Option\u003cVec\u003c\u0026'a Persona\u003c'a\u003e\u003e\u003e;\r\n    fn b_personas_mayores_edad_en_ciudad(\u0026'a self, ciudad: \u0026'a str, edad: u8) -\u003e Vec\u003c\u0026'a Persona\u003c'a\u003e\u003e;\r\n    fn c_todos_viven_en_ciudad(\u0026'a self, ciudad: \u0026'a str) -\u003e bool;\r\n    fn d_alguien_vive_en_ciudad(\u0026'a self, ciudad: \u0026'a str) -\u003e bool;\r\n    fn e_persona_existe(\u0026'a self, persona: \u0026Persona) -\u003e bool;\r\n    fn f_listar_edades(\u0026'a self) -\u003e Vec\u003cu8\u003e;\r\n    fn g_mayor_menor_salario(\u0026'a self) -\u003e Option\u003c(\u0026'a Persona\u003c'a\u003e, \u0026'a Persona\u003c'a\u003e)\u003e;\r\n}\r\n\r\nimpl\u003c'a\u003e VecPersona\u003c'a\u003e for Vec\u003cPersona\u003c'a\u003e\u003e {\r\n    fn a_personas_salario_mayor(\u0026'a self, num: f64) -\u003e Option\u003cVec\u003c\u0026'a Persona\u003c'a\u003e\u003e\u003e {\r\n        if num \u003c 0.0 { return None } // num debe ser un número positivo\r\n\r\n        Some(\r\n            self.iter().filter(\r\n                |p|\r\n                    p.salario \u003e num\r\n            ).collect()\r\n        )\r\n    }\r\n\r\n    fn b_personas_mayores_edad_en_ciudad(\u0026'a self, ciudad: \u0026'a str, edad: u8) -\u003e Vec\u003c\u0026'a Persona\u003c'a\u003e\u003e {\r\n        self.iter().filter(|p|\r\n            p.ciudad == ciudad \u0026\u0026 p.edad \u003e edad\r\n        ).collect()\r\n    }\r\n\r\n    fn c_todos_viven_en_ciudad(\u0026'a self, ciudad: \u0026'a str) -\u003e bool {\r\n        self.iter().all(|p| p.ciudad == ciudad)\r\n    }\r\n\r\n    fn d_alguien_vive_en_ciudad(\u0026'a self, ciudad: \u0026'a str) -\u003e bool {\r\n        self.iter().any(|p| p.ciudad == ciudad)\r\n    }\r\n\r\n    fn e_persona_existe(\u0026'a self, persona: \u0026Persona) -\u003e bool {\r\n        self.iter().any(|p| p == persona)\r\n    }\r\n\r\n    fn f_listar_edades(\u0026'a self) -\u003e Vec\u003cu8\u003e {\r\n        self.iter().map(|p| {\r\n            p.edad\r\n        }).collect()\r\n    }\r\n\r\n    fn g_mayor_menor_salario(\u0026'a self) -\u003e Option\u003c(\u0026'a Persona\u003c'a\u003e, \u0026'a Persona\u003c'a\u003e)\u003e {\r\n        if self.len() \u003c 2 { return None } // no min/max can be calculated with 1 or 0 elements\r\n\r\n        let first_person = self.first();\r\n        let first_person = first_person?;\r\n\r\n        let mut res_index: (usize, usize) = (0, 0);\r\n        let mut res: (\u0026Persona, \u0026Persona) = (first_person, first_person);\r\n\r\n        self.iter().enumerate().for_each(\r\n            | (i, p) | {\r\n                if p.salario \u003c res.0.salario {\r\n                    res_index.0 = i;\r\n                    res.0 = p;\r\n                } else if p.salario \u003e res.1.salario {\r\n                    res_index.1 = i;\r\n                    res.1 = p;\r\n                } else if p.salario == res.0.salario \u0026\u0026 p.edad \u003e res.0.edad {\r\n                    res_index.0 = i;\r\n                    res.0 = p;\r\n                } else if p.salario == res.1.salario \u0026\u0026 p.edad \u003e res.1.edad {\r\n                    res_index.1 = i;\r\n                    res.0 = p;\r\n                }\r\n            }\r\n        );\r\n\r\n        Some(res)\r\n    }\r\n}\r\n\r\nfn main() { }","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","main.rs"],"content":"/*\r\n\r\n3 -La plataforma de streaming \"StreamingRust\" ofrece distintos tipos de suscripciones (Basic, Clasic, Super) a sus usuarios.\r\n    Cada suscripción tiene un costo mensual, una duración en meses y una fecha de inicio.\r\n    Además, los usuarios pueden pagar por sus suscripciones con distintos medios de pago\r\n        que son Efectivo, MercadoPago, Tarjeta de Crédito, Transferencia Bancaria, o Cripto.\r\n    Cada medio de pago tiene sus datos correspondientes a excepción de Efectivo.\r\n    Los usuarios solo pueden tener una suscripción activa a la vez.\r\n    Implemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear un usuario con una determinada suscripción y medio de pago.\r\n➢ Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic pasa a Clasic y si está en Clasic pasa a Super.\r\n➢ Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la suscripción es del tipo Basic al hacerlo se cancelará la suscripción.\r\n➢ Dado un usuario cancelar la suscripción.\r\n➢ Saber el medio de pago que es más utilizado por los usuarios sobre las suscripciones activas\r\n➢ Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones activas.\r\n➢ Saber cuál fue el medio de pago más utilizado.\r\n➢ Saber cuál fue la suscripción más contratada.\r\n\r\n*/\r\nmod structs;\r\n\r\nfn main() {}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","errores.rs"],"content":"use std::error::Error;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug)]\r\npub enum ErrorNewSuscripcion {\r\n    FechaInvalida, MedioDePagoInvalido\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ErrorMejorarSuscripcion {\r\n    SuscripcionMaxima, MedioDePagoInvalido, FechaInvalida\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ErrorDegradarSuscripcion {\r\n    SuscripcionMinima, MedioDePagoInvalido, FechaInvalida,\r\n}\r\n\r\nimpl fmt::Display for ErrorNewSuscripcion {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        match self {\r\n            ErrorNewSuscripcion::FechaInvalida =\u003e write!(f, \"La fecha ingresada es inválida\"),\r\n            ErrorNewSuscripcion::MedioDePagoInvalido =\u003e write!(f, \"El medio de pago ingresado es inválido\")\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for ErrorMejorarSuscripcion {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        match self {\r\n            ErrorMejorarSuscripcion::SuscripcionMaxima =\u003e write!(f, \"La suscripción no puede mejorarse porque ya es la más alta posible\"),\r\n            ErrorMejorarSuscripcion::MedioDePagoInvalido =\u003e write!(f, \"El medio de pago ingresado es inválido\"),\r\n            ErrorMejorarSuscripcion::FechaInvalida =\u003e write!(f, \"La fecha ingresada es inválida\")\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for ErrorDegradarSuscripcion {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        match self {\r\n            ErrorDegradarSuscripcion::SuscripcionMinima =\u003e write!(f, \"La suscripción no puede mejorarse porque ya es la más alta posible\"),\r\n            ErrorDegradarSuscripcion::MedioDePagoInvalido =\u003e write!(f, \"El medio de pago ingresado es inválido\"),\r\n            ErrorDegradarSuscripcion::FechaInvalida =\u003e write!(f, \"La fecha ingresada es inválida\")\r\n        }\r\n    }\r\n}\r\n\r\nimpl Error for ErrorNewSuscripcion { }\r\nimpl Error for ErrorMejorarSuscripcion { }\r\nimpl Error for ErrorDegradarSuscripcion { }","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","fecha.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct Fecha {\r\n    pub(crate) dia: u8,\r\n    pub(crate) mes: u8,\r\n    pub(crate) ano: i64\r\n}\r\n\r\nimpl Default for Fecha {\r\n    fn default() -\u003e Self {\r\n        Fecha { dia: 1, mes: 1, ano: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Fecha {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.dia == other.dia\r\n            \u0026\u0026 self.mes == other.mes\r\n            \u0026\u0026 self.ano == other.ano\r\n        { return Some(Equal) }\r\n\r\n        if self.ano \u003e other.ano { return Some(Greater) }\r\n        if self.mes \u003e other.mes { return Some(Greater) }\r\n        if self.dia \u003e other.dia { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cFecha\u003e {\r\n        let fecha = Fecha { dia, mes, ano };\r\n        if fecha.es_fecha_valida() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia == 0\r\n            || self.dia \u003e self.dias_mes_actual()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n\r\n    pub fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n\r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","mod.rs"],"content":"mod usuario;\r\nmod suscripcion;\r\nmod fecha;\r\nmod streamingrust;\r\nmod errores;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","streamingrust.rs"],"content":"/*\r\n\r\n3 -La plataforma de streaming \"StreamingRust\" ofrece distintos tipos de suscripciones (Basic, Clasic, Super) a sus usuarios.\r\n    Cada suscripción tiene un costo mensual, una duración en meses y una fecha de inicio.\r\n    Además, los usuarios pueden pagar por sus suscripciones con distintos medios de pago\r\n        que son Efectivo, MercadoPago, Tarjeta de Crédito, Transferencia Bancaria, o Cripto.\r\n    Cada medio de pago tiene sus datos correspondientes a excepción de Efectivo.\r\n    Los usuarios solo pueden tener una suscripción activa a la vez.\r\n    Implemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear un usuario con una determinada suscripción y medio de pago.\r\n➢ Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic pasa a Clasic y si está en Clasic pasa a Super.\r\n➢ Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la suscripción es del tipo Basic al hacerlo se cancelará la suscripción.\r\n➢ Dado un usuario cancelar la suscripción.\r\n➢ Saber el medio de pago que es más utilizado por los usuarios sobre las suscripciones activas\r\n➢ Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones activas.\r\n➢ Saber cuál fue el medio de pago más utilizado.\r\n➢ Saber cuál fue la suscripción más contratada.\r\n\r\n*/\r\nuse std::collections::{BTreeMap, HashMap, HashSet};\r\nuse crate::structs::suscripcion::TipoSuscripcion;\r\nuse crate::structs::usuario::Usuario;\r\n\r\n// contienen la información necesaria para identificar la compra\r\n//         mercadopago: cvu\r\n//         credito: cbu, cuotas\r\n//         debito: cbu\r\n//         transferencia: cbu\r\n//         cripto: public key/wallet address\r\n//         combinación: set de cualquiera de las anteriores\r\n#[derive(Debug, PartialEq, Eq, Hash, Clone)]\r\npub enum MedioDePago {\r\n    Efectivo,\r\n    MercadoPago(u128),\r\n    Credito(u128, u8),\r\n    Debito(u128),\r\n    Transferencia(u128),\r\n    Cripto([u8; 65])\r\n}\r\n\r\nimpl MedioDePago {\r\n    fn id(\u0026self) -\u003e u8 {\r\n        match self {\r\n            MedioDePago::Efectivo =\u003e 0,\r\n            MedioDePago::MercadoPago(_) =\u003e 1,\r\n            MedioDePago::Credito(_, _) =\u003e 2,\r\n            MedioDePago::Debito(_) =\u003e 3,\r\n            MedioDePago::Transferencia(_) =\u003e 4,\r\n            MedioDePago::Cripto(_) =\u003e 5,\r\n        }\r\n    }\r\n\r\n    fn from_id(id: u8) -\u003e MedioDePago {\r\n        match id {\r\n            0 | 6..=u8::MAX =\u003e MedioDePago::Efectivo,\r\n            1 =\u003e MedioDePago::MercadoPago(0),\r\n            2 =\u003e MedioDePago::Credito(0, 0),\r\n            3 =\u003e MedioDePago::Debito(0),\r\n            4 =\u003e MedioDePago::Transferencia(0),\r\n            5 =\u003e MedioDePago::Cripto([0; 65])\r\n        }\r\n    }\r\n}\r\n\r\nstruct StreamingRust\u003c'a\u003e {\r\n    usuarios: BTreeMap\u003cu64, Usuario\u003c'a\u003e\u003e\r\n}\r\n\r\nimpl\u003c'a\u003e StreamingRust\u003c'a\u003e {\r\n    \r\n    fn new(usuarios: Option\u003cBTreeMap\u003cu64, Usuario\u003e\u003e) -\u003e StreamingRust {\r\n        StreamingRust { usuarios: usuarios.unwrap_or_default() }\r\n    }\r\n\r\n    fn contabilizar_medios_de_pago(\u0026self, contabilizar_inactivos: bool) -\u003e HashMap\u003cMedioDePago, u32\u003e {\r\n        let mut contabilizador_mdp: HashMap\u003cMedioDePago, u32\u003e = HashMap::new();\r\n\r\n        self.usuarios.iter().for_each(|(_, usuario)| {\r\n            if contabilizar_inactivos || usuario.suscripcion.activo {\r\n                if let Some(medio) = \u0026usuario.suscripcion.medio_de_pago {\r\n                    *contabilizador_mdp.entry(medio.clone()).or_insert(0)+= 1;\r\n                }\r\n            }\r\n        });\r\n\r\n        contabilizador_mdp\r\n    }\r\n\r\n    fn contabilizar_tipos_de_suscripcion(\u0026self, contabilizar_inactivos: bool) -\u003e HashMap\u003cTipoSuscripcion, u32\u003e {\r\n        let mut contabilizador_ts: HashMap\u003cTipoSuscripcion, u32\u003e = HashMap::new();\r\n\r\n        self.usuarios.iter().for_each(|(_, usuario)| {\r\n            if contabilizar_inactivos || usuario.suscripcion.activo {\r\n                *contabilizador_ts.entry(usuario.suscripcion.tipo_suscripcion.clone()).or_insert(0)+= 1;\r\n            }\r\n        });\r\n\r\n        contabilizador_ts\r\n    }\r\n\r\n    // ➢ Saber el medio de pago que es más utilizado por los usuarios sobre las suscripciones activas\r\n    fn medio_de_pago_mas_utilizado_activos(\u0026self) -\u003e Option\u003cMedioDePago\u003e {\r\n        if self.usuarios.is_empty() { return None }\r\n\r\n        let contabilizador_mdp = self.contabilizar_medios_de_pago(false);\r\n\r\n        contabilizador_mdp.iter()\r\n            .max_by_key(|(_, c)| *c)\r\n            .map(|(mdp, _)| mdp.clone())\r\n    }\r\n\r\n    // ➢ Saber cuál fue el medio de pago más utilizado.\r\n    fn medio_de_pago_mas_utilizado_general(\u0026self) -\u003e Option\u003cMedioDePago\u003e {\r\n        if self.usuarios.is_empty() { return None }\r\n\r\n        let contabilizador_mdp = self.contabilizar_medios_de_pago(true);\r\n\r\n        contabilizador_mdp.iter()\r\n            .max_by_key(|(_, c)| *c)\r\n            .map(|(mdp, _)| mdp.clone())\r\n    }\r\n\r\n    // ➢ Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones activas.\r\n    fn suscripcion_activa_mas_contratada(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\r\n        if self.usuarios.is_empty() { return None }\r\n\r\n        let contabilizador_ts = self.contabilizar_tipos_de_suscripcion(false);\r\n\r\n        contabilizador_ts.iter()\r\n            .max_by_key(|(_, c)| *c)\r\n            .map(|(ts, _)| ts.clone())\r\n    }\r\n\r\n    // ➢ Saber cuál fue la suscripción más contratada.\r\n    fn suscripcion_mas_contratada_general(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\r\n        if self.usuarios.is_empty() { return None }\r\n\r\n        let contabilizador_ts = self.contabilizar_tipos_de_suscripcion(true);\r\n\r\n        contabilizador_ts.iter()\r\n            .max_by_key(|(_, c)| *c)\r\n            .map(|(ts, _)| ts.clone())\r\n    }\r\n}","traces":[{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","suscripcion.rs"],"content":"/*\r\n\r\n3 -La plataforma de streaming \"StreamingRust\" ofrece distintos tipos de suscripciones (Basic, Clasic, Super) a sus usuarios.\r\n    Cada suscripción tiene un costo mensual, una duración en meses y una fecha de inicio.\r\n    Además, los usuarios pueden pagar por sus suscripciones con distintos medios de pago\r\n        que son Efectivo, MercadoPago, Tarjeta de Crédito, Transferencia Bancaria, o Cripto.\r\n    Cada medio de pago tiene sus datos correspondientes a excepción de Efectivo.\r\n    Los usuarios solo pueden tener una suscripción activa a la vez.\r\n    Implemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear un usuario con una determinada suscripción y medio de pago.\r\n➢ Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic pasa a Clasic y si está en Clasic pasa a Super.\r\n➢ Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la suscripción es del tipo Basic al hacerlo se cancelará la suscripción.\r\n➢ Dado un usuario cancelar la suscripción.\r\n➢ Saber el medio de pago que es más utilizado por los usuarios sobre las suscripciones activas\r\n➢ Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones activas.\r\n➢ Saber cuál fue el medio de pago más utilizado.\r\n➢ Saber cuál fue la suscripción más contratada.\r\n\r\n*/\r\nuse std::cmp::PartialEq;\r\nuse crate::structs::errores::{ErrorDegradarSuscripcion, ErrorMejorarSuscripcion, ErrorNewSuscripcion};\r\nuse crate::structs::fecha::Fecha;\r\nuse crate::structs::streamingrust::MedioDePago;\r\n\r\n#[derive(Debug, PartialEq, Eq, Hash, Clone)]\r\npub enum TipoSuscripcion {\r\n    Basic, Classic, Super\r\n}\r\n\r\npub struct Suscripcion {\r\n    pub activo: bool,\r\n    pub tipo_suscripcion: TipoSuscripcion,\r\n    pub medio_de_pago: Option\u003cMedioDePago\u003e,\r\n    pub costo_mensual: f64,\r\n    pub fecha_inicio: Option\u003cFecha\u003e\r\n}\r\n\r\nimpl From\u003cErrorNewSuscripcion\u003e for ErrorMejorarSuscripcion {\r\n    fn from(value: ErrorNewSuscripcion) -\u003e Self {\r\n        match value {\r\n            ErrorNewSuscripcion::FechaInvalida =\u003e ErrorMejorarSuscripcion::FechaInvalida,\r\n            ErrorNewSuscripcion::MedioDePagoInvalido =\u003e ErrorMejorarSuscripcion::MedioDePagoInvalido\r\n        }\r\n    }\r\n}\r\n\r\nimpl From\u003cErrorNewSuscripcion\u003e for ErrorDegradarSuscripcion {\r\n    fn from(value: ErrorNewSuscripcion) -\u003e Self {\r\n        match value {\r\n            ErrorNewSuscripcion::FechaInvalida =\u003e ErrorDegradarSuscripcion::FechaInvalida,\r\n            ErrorNewSuscripcion::MedioDePagoInvalido =\u003e ErrorDegradarSuscripcion::MedioDePagoInvalido\r\n        }\r\n    }\r\n}\r\n\r\nimpl TipoSuscripcion {\r\n    fn costo_mensual(\u0026self) -\u003e f64 {\r\n        match self {\r\n            TipoSuscripcion::Basic =\u003e 1200.0,\r\n            TipoSuscripcion::Classic =\u003e 2200.0,\r\n            TipoSuscripcion::Super =\u003e 5800.0\r\n        }\r\n    }\r\n}\r\n\r\nimpl Suscripcion {\r\n\r\n    pub(crate) fn new(tipo_suscripcion: TipoSuscripcion, activo: bool, medio_de_pago: Option\u003cMedioDePago\u003e, fecha_inicio: Option\u003cFecha\u003e) -\u003e Result\u003cSelf, ErrorNewSuscripcion\u003e {\r\n        if activo {\r\n            if let None = medio_de_pago { return Err(ErrorNewSuscripcion::MedioDePagoInvalido) }\r\n            if let None = fecha_inicio { return Err(ErrorNewSuscripcion::FechaInvalida) }\r\n            if let Some(fecha) = \u0026fecha_inicio { if !fecha.es_fecha_valida() { return Err(ErrorNewSuscripcion::FechaInvalida) } }\r\n        }\r\n\r\n        // el costo mensual no debería darse como argumento de la función\r\n        // sino tener un costo predefinido para cada tipo de suscripción\r\n        let costo_mensual = tipo_suscripcion.costo_mensual();\r\n\r\n        Ok(Suscripcion { tipo_suscripcion, activo, medio_de_pago, costo_mensual, fecha_inicio })\r\n    }\r\n\r\n    pub fn mejorar(\u0026mut self) -\u003e Result\u003c\u0026TipoSuscripcion, ErrorMejorarSuscripcion\u003e {\r\n        let sig_suscripcion = match \u0026self.tipo_suscripcion {\r\n            TipoSuscripcion::Basic =\u003e TipoSuscripcion::Classic,\r\n            TipoSuscripcion::Classic =\u003e TipoSuscripcion::Super,\r\n            TipoSuscripcion::Super =\u003e return Err(ErrorMejorarSuscripcion::SuscripcionMaxima)\r\n        };\r\n\r\n        self.costo_mensual = sig_suscripcion.costo_mensual();\r\n        self.tipo_suscripcion = sig_suscripcion;\r\n\r\n        Ok(\u0026self.tipo_suscripcion)\r\n    }\r\n\r\n    // reduce el rango de la suscripcion\r\n    // opcionalmente puede cambiar el medio de pago y la fecha actual\r\n    pub fn degradar(\u0026mut self) -\u003e Result\u003c\u0026TipoSuscripcion, ErrorDegradarSuscripcion\u003e {\r\n        let prev_suscripcion = match \u0026self.tipo_suscripcion {\r\n            TipoSuscripcion::Basic =\u003e return Err(ErrorDegradarSuscripcion::SuscripcionMinima),\r\n            TipoSuscripcion::Classic =\u003e TipoSuscripcion::Basic,\r\n            TipoSuscripcion::Super =\u003e TipoSuscripcion::Classic\r\n        };\r\n\r\n        self.costo_mensual = prev_suscripcion.costo_mensual();\r\n        self.tipo_suscripcion = prev_suscripcion;\r\n\r\n        Ok(\u0026self.tipo_suscripcion)\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej3","structs","usuario.rs"],"content":"/*\r\n\r\n3 -La plataforma de streaming \"StreamingRust\" ofrece distintos tipos de suscripciones (Basic, Clasic, Super) a sus usuarios.\r\n    Cada suscripción tiene un costo mensual, una duración en meses y una fecha de inicio.\r\n    Además, los usuarios pueden pagar por sus suscripciones con distintos medios de pago\r\n        que son Efectivo, MercadoPago, Tarjeta de Crédito, Transferencia Bancaria, o Cripto.\r\n    Cada medio de pago tiene sus datos correspondientes a excepción de Efectivo.\r\n    Los usuarios solo pueden tener una suscripción activa a la vez.\r\n    Implemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear un usuario con una determinada suscripción y medio de pago.\r\n➢ Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic pasa a Clasic y si está en Clasic pasa a Super.\r\n➢ Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la suscripción es del tipo Basic al hacerlo se cancelará la suscripción.\r\n➢ Dado un usuario cancelar la suscripción.\r\n➢ Saber el medio de pago que es más utilizado por los usuarios sobre las suscripciones activas\r\n➢ Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones activas.\r\n➢ Saber cuál fue el medio de pago más utilizado.\r\n➢ Saber cuál fue la suscripción más contratada.\r\n\r\n*/\r\nuse crate::structs::errores::{ErrorDegradarSuscripcion, ErrorMejorarSuscripcion};\r\nuse crate::structs::suscripcion::{Suscripcion, TipoSuscripcion};\r\n\r\npub struct Usuario\u003c'a\u003e {\r\n    pub id: u64,\r\n    pub email: \u0026'a str,\r\n    pub suscripcion: Suscripcion,\r\n}\r\n\r\nimpl\u003c'a\u003e Usuario\u003c'a\u003e {\r\n    // ➢ Crear un usuario con una determinada suscripción y medio de pago.\r\n    fn new(id: u64, email: \u0026'a str, suscripcion: Suscripcion) -\u003e Self {\r\n        Usuario { id, email, suscripcion }\r\n    }\r\n\r\n    // ➢ Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic pasa a Clasic y si está en Clasic pasa a Super.\r\n    fn mejorar_suscripcion(\u0026mut self) -\u003e Result\u003c\u0026TipoSuscripcion, ErrorMejorarSuscripcion\u003e {\r\n        self.suscripcion.mejorar()\r\n    }\r\n\r\n    // ➢ Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la suscripción es del tipo Basic al hacerlo se cancelará la suscripción.\r\n    fn degradar_suscripcion(\u0026mut self) -\u003e Result\u003c\u0026TipoSuscripcion, ErrorDegradarSuscripcion\u003e {\r\n        self.suscripcion.degradar()\r\n    }\r\n\r\n    // ➢ Dado un usuario cancelar la suscripción.\r\n    fn cancelar_suscripcion(\u0026mut self) -\u003e bool {\r\n        let estaba_activa = self.suscripcion.activo;\r\n        self.suscripcion.activo = false;\r\n        estaba_activa\r\n    }\r\n\r\n}","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","main.rs"],"content":"/*\r\n\r\n4 - Se requiere implementar un sistema de ventas de productos.\r\n    De cada producto se conoce\r\n        el nombre,\r\n        una categoría\r\n        y un precio base,\r\n        y algunos productos pueden tener descuentos aplicables dependiendo de la categoría.\r\n    Además, se debe registrar al vendedor que realizó la venta y al cliente.\r\n    De ellos se conoce\r\n        nombre,\r\n        apellido,\r\n        dirección,\r\n        dni\r\n    y del vendedor\r\n        nro de legajo,\r\n        antigüedad\r\n        y salario.\r\n    Los clientes pueden tener un beneficio de descuento si tienen suscripción al newsletter,\r\n    de ser así se tiene el correo electrónico del mismo.\r\n\r\nEl sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\nLos medios de pago aceptados son:\r\n    tarjeta de crédito,\r\n    tarjeta de débito,\r\n    transferencia bancaria\r\n    y efectivo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n\r\n➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n        donde debería aplicarse un descuento.\r\n    Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n➢ Para llevar un control de ventas realizadas se debe implementar un reporte que permita visualizar las ventas totales\r\n    por categoría de producto y otro por vendedor.\r\n\r\n */\r\nmod structs;\r\n\r\nfn main() {\r\n    let asd = u32::MAX;\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","comercio.rs"],"content":"/*\r\n\r\n4 - Se requiere implementar un sistema de ventas de productos.\r\n    De cada producto se conoce\r\n        el nombre,\r\n        una categoría\r\n        y un precio base,\r\n        y algunos productos pueden tener descuentos aplicables dependiendo de la categoría.\r\n    Además, se debe registrar al vendedor que realizó la venta y al cliente.\r\n    De ellos se conoce\r\n        nombre,\r\n        apellido,\r\n        dirección,\r\n        dni\r\n    y del vendedor\r\n        nro de legajo,\r\n        antigüedad\r\n        y salario.\r\n    Los clientes pueden tener un beneficio de descuento si tienen suscripción al newsletter,\r\n    de ser así se tiene el correo electrónico del mismo.\r\n\r\nEl sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\nLos medios de pago aceptados son:\r\n    tarjeta de crédito,\r\n    tarjeta de débito,\r\n    transferencia bancaria\r\n    y efectivo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n\r\n➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n        donde debería aplicarse un descuento.\r\n    Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n➢ Para llevar un control de ventas realizadas se debe implementar un reporte que permita visualizar las ventas totales\r\n    por categoría de producto y otro por vendedor.\r\n\r\n */\r\n\r\nuse std::collections::HashMap;\r\nuse crate::structs::producto::CategoriaProducto;\r\nuse crate::structs::vendedor_cliente::Vendedor;\r\nuse crate::structs::venta::Venta;\r\n\r\nstruct Comercio\u003c'a\u003e {\r\n    vendedores: HashMap\u003cu16, Vendedor\u003e,\r\n    descuentos: HashMap\u003cCategoriaProducto, f32\u003e,\r\n    ventas: Vec\u003cVenta\u003c'a\u003e\u003e\r\n}\r\n\r\nstruct ReporteTotal {\r\n    reporte_categorias: HashMap\u003cCategoriaProducto, u16\u003e,\r\n    reporte_vendedores: HashMap\u003cu16, u16\u003e // \u003clegajo, ventas\u003e\r\n}\r\n\r\nimpl\u003c'a\u003e Comercio\u003c'a\u003e {\r\n\r\n    // ➢ Para llevar un control de ventas realizadas se debe implementar\r\n    //      un reporte que permita visualizar las ventas totales por categoría de producto y otro por vendedor.\r\n    \r\n    fn generar_reporte_total(\u0026self) -\u003e ReporteTotal {\r\n        let mut reporte_categorias: HashMap\u003cCategoriaProducto, u16\u003e = Default::default();\r\n        let mut reporte_vendedores: HashMap\u003cu16, u16\u003e = Default::default();\r\n        \r\n        for venta in \u0026self.ventas {\r\n            for (producto, cant) in \u0026venta.productos {\r\n                *reporte_categorias.entry(producto.categoria).or_insert(0)+= cant;\r\n                *reporte_vendedores.entry(venta.vendedor.legajo).or_insert(0)+= cant;\r\n            }\r\n        }\r\n        \r\n        ReporteTotal {\r\n            reporte_categorias,\r\n            reporte_vendedores\r\n        }\r\n    }\r\n    \r\n}","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","fecha.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct Fecha {\r\n    pub(crate) dia: u8,\r\n    pub(crate) mes: u8,\r\n    pub(crate) ano: i64\r\n}\r\n\r\nimpl Default for Fecha {\r\n    fn default() -\u003e Self {\r\n        Fecha { dia: 1, mes: 1, ano: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Fecha {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.dia == other.dia\r\n            \u0026\u0026 self.mes == other.mes\r\n            \u0026\u0026 self.ano == other.ano\r\n        { return Some(Equal) }\r\n\r\n        if self.ano \u003e other.ano { return Some(Greater) }\r\n        if self.mes \u003e other.mes { return Some(Greater) }\r\n        if self.dia \u003e other.dia { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cFecha\u003e {\r\n        let fecha = Fecha { dia, mes, ano };\r\n        if fecha.es_fecha_valida() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia == 0\r\n            || self.dia \u003e self.dias_mes_actual()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n\r\n    pub fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n\r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","mod.rs"],"content":"mod fecha;\r\nmod producto;\r\nmod vendedor_cliente;\r\nmod venta;\r\nmod comercio;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","producto.rs"],"content":"/*\r\n\r\n4 - Se requiere implementar un sistema de ventas de productos.\r\n    De cada producto se conoce\r\n        el nombre,\r\n        una categoría\r\n        y un precio base,\r\n        y algunos productos pueden tener descuentos aplicables dependiendo de la categoría.\r\n    Además, se debe registrar al vendedor que realizó la venta y al cliente.\r\n    De ellos se conoce\r\n        nombre,\r\n        apellido,\r\n        dirección,\r\n        dni\r\n    y del vendedor\r\n        nro de legajo,\r\n        antigüedad\r\n        y salario.\r\n    Los clientes pueden tener un beneficio de descuento si tienen suscripción al newsletter,\r\n    de ser así se tiene el correo electrónico del mismo.\r\n\r\nEl sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\nLos medios de pago aceptados son:\r\n    tarjeta de crédito,\r\n    tarjeta de débito,\r\n    transferencia bancaria\r\n    y efectivo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n\r\n➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n        donde debería aplicarse un descuento.\r\n    Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n➢ Para llevar un control de ventas realizadas se debe implementar un reporte que permita visualizar las ventas totales\r\n    por categoría de producto y otro por vendedor.\r\n    \r\n */\r\n\r\n#[derive(Hash, Copy, Clone, PartialEq, Eq)]\r\npub enum CategoriaProducto {\r\n    Cosmetico, Tecnologia, HomeDeco, Almacen, Ferreteria, Drogueria, Textil\r\n}\r\n\r\npub struct Producto\u003c'a\u003e {\r\n    pub nombre: \u0026'a str,\r\n    pub apellido: \u0026'a str,\r\n    pub categoria: CategoriaProducto,\r\n    pub precio: f32,\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","vendedor_cliente.rs"],"content":"/*\r\n\r\n4 - Se requiere implementar un sistema de ventas de productos.\r\n    De cada producto se conoce\r\n        el nombre,\r\n        una categoría\r\n        y un precio base,\r\n        y algunos productos pueden tener descuentos aplicables dependiendo de la categoría.\r\n    Además, se debe registrar al vendedor que realizó la venta y al cliente.\r\n    De ellos se conoce\r\n        nombre,\r\n        apellido,\r\n        dirección,\r\n        dni\r\n    y del vendedor\r\n        nro de legajo,\r\n        antigüedad\r\n        y salario.\r\n    Los clientes pueden tener un beneficio de descuento si tienen suscripción al newsletter,\r\n    de ser así se tiene el correo electrónico del mismo.\r\n\r\nEl sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\nLos medios de pago aceptados son:\r\n    tarjeta de crédito,\r\n    tarjeta de débito,\r\n    transferencia bancaria\r\n    y efectivo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n\r\n➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n        donde debería aplicarse un descuento.\r\n    Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n➢ Para llevar un control de ventas realizadas se debe implementar un reporte que permita visualizar las ventas totales\r\n    por categoría de producto y otro por vendedor.\r\n\r\n */\r\n\r\n//     y del vendedor\r\n//         nro de legajo,\r\n//         antigüedad\r\n//         y salario.\r\npub struct Vendedor {\r\n    pub legajo: u16,\r\n    pub antiguedad_anos: u8,\r\n    pub salario: f64,\r\n}\r\n\r\n//     De ellos se conoce\r\n//         nombre,\r\n//         apellido,\r\n//         dirección,\r\n//         dni\r\npub struct Cliente\u003c'a\u003e {\r\n    pub nombre: \u0026'a str,\r\n    pub apellido: \u0026'a str,\r\n    pub direccion: \u0026'a str,\r\n    pub dni: u32 // u32::MAX = 4.xxx.xxx.xxx\r\n}\r\n\r\nimpl Vendedor {\r\n    fn new(legajo: u16, antiguedad_anos: u8, salario: f64) -\u003e Option\u003cVendedor\u003e {\r\n        if salario \u003c 0.0 { return None }\r\n        \r\n        Some(Vendedor {\r\n            legajo, antiguedad_anos, salario\r\n        })\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e Cliente\u003c'a\u003e {\r\n    fn new(nombre: \u0026'a str, apellido: \u0026'a str, direccion: \u0026'a str, dni: u32) -\u003e Cliente\u003c'a\u003e {\r\n        Cliente {\r\n            nombre, apellido, direccion, dni\r\n        }\r\n    }\r\n}","traces":[{"line":78,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej4","structs","venta.rs"],"content":"/*\r\n\r\n4 - Se requiere implementar un sistema de ventas de productos.\r\n    De cada producto se conoce\r\n        el nombre,\r\n        una categoría\r\n        y un precio base,\r\n        y algunos productos pueden tener descuentos aplicables dependiendo de la categoría.\r\n    Además, se debe registrar al vendedor que realizó la venta y al cliente.\r\n    De ellos se conoce\r\n        nombre,\r\n        apellido,\r\n        dirección,\r\n        dni\r\n    y del vendedor\r\n        nro de legajo,\r\n        antigüedad\r\n        y salario.\r\n    Los clientes pueden tener un beneficio de descuento si tienen suscripción al newsletter,\r\n    de ser así se tiene el correo electrónico del mismo.\r\n\r\nEl sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\nLos medios de pago aceptados son:\r\n    tarjeta de crédito,\r\n    tarjeta de débito,\r\n    transferencia bancaria\r\n    y efectivo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios para resolver las siguientes acciones:\r\n\r\n➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n\r\n➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n        donde debería aplicarse un descuento.\r\n    Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n➢ Para llevar un control de ventas realizadas se debe implementar un reporte que permita visualizar las ventas totales\r\n    por categoría de producto y otro por vendedor.\r\n\r\n */\r\n\r\nuse std::collections::HashMap;\r\nuse crate::structs::fecha::Fecha;\r\nuse crate::structs::producto::{CategoriaProducto, Producto};\r\nuse crate::structs::vendedor_cliente::{Cliente, Vendedor};\r\n\r\nconst DESCUENTO_SUSCRIPCION_NEWSLETTER: f32 = 5.0;\r\n\r\npub enum MedioDePago {\r\n    Credito, Debito, Transferencia, Efectivo\r\n}\r\n\r\n// El sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado.\r\n// Los medios de pago aceptados son:\r\n//     tarjeta de crédito,\r\n//     tarjeta de débito,\r\n//     transferencia bancaria\r\n//     y efectivo.\r\n\r\npub struct Venta\u003c'a\u003e {\r\n    pub fecha: Fecha,\r\n    pub cliente: \u0026'a Cliente\u003c'a\u003e,\r\n    pub vendedor: \u0026'a Vendedor,\r\n    pub medio_de_pago: MedioDePago,\r\n    pub productos: HashMap\u003cProducto\u003c'a\u003e, u16\u003e,\r\n}\r\n\r\nimpl\u003c'a\u003e Venta\u003c'a\u003e {\r\n\r\n    // ➢ Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de productos con sus cantidades.\r\n    fn new(fecha: Fecha, cliente: \u0026'a Cliente, vendedor: \u0026'a Vendedor, medio_de_pago: MedioDePago, productos: HashMap\u003cProducto\u003c'a\u003e, u16\u003e) -\u003e Option\u003cVenta\u003c'a\u003e\u003e {\r\n        if !fecha.es_fecha_valida() { return None }\r\n\r\n        Some(Venta {\r\n            fecha, cliente, vendedor, medio_de_pago, productos\r\n        })\r\n    }\r\n\r\n    // ➢ Calcular el precio final de una venta en base a los productos que hay en ella.\r\n    //     Para calcularlo tenga en cuenta que pueden haber determinados productos de alguna categoría\r\n    //         donde debería aplicarse un descuento.\r\n    //     Tanto la categoría como el porcentaje de descuento a aplicar son datos que le brinda el sistema.\r\n    //     Es decir el sistema tiene una lista de las categorías con el descuento a aplicar.\r\n    //     Además se debe aplicar un porcentaje de descuento general si el cliente tiene suscripción al newsletter.\r\n\r\n    fn precio_final(\u0026self, descuentos_porc: \u0026HashMap\u003cCategoriaProducto, f32\u003e, suscrito_newsletter: bool) -\u003e Option\u003cf32\u003e {\r\n        for val in descuentos_porc.values() {\r\n            if *val \u003c 0.0 || *val \u003e 100.0 { return None }\r\n        }\r\n\r\n        let mut precio_final = 0.0;\r\n        // calcular precios y sumarlos\r\n        for (producto, cant) in \u0026self.productos {\r\n            if let Some(descuento) = descuentos_porc.get(\u0026producto.categoria) {\r\n                precio_final+= producto.precio * (1.0 - *descuento/100.0) * (*cant as f32)\r\n            } else {\r\n                precio_final+= producto.precio * (*cant as f32)\r\n            }\r\n        }\r\n\r\n        if suscrito_newsletter { precio_final*= 1.0 - DESCUENTO_SUSCRIPCION_NEWSLETTER/100.0 }\r\n\r\n        Some(precio_final)\r\n    }\r\n}","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","main.rs"],"content":"/*\r\n\r\n5- La empresa XYZ es una plataforma de intercambio de criptoactivos\r\n    que permite a los usuarios comprar y vender distintas criptomonedas.\r\n\r\n    La plataforma permite el registro de usuarios y la gestión de sus balances\r\n        en distintas criptomonedas y en dinero fíat.\r\n    De los usuarios se conoce:\r\n        nombre, apellido, email, dni, y si está validada su identidad o no.\r\n\r\n    Cada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\n    De las criptomonedas se conoce:\r\n        nombre, prefijo y un listado de blockchains donde se pueden enviar o recibir.\r\n    De cada blockchain se conoce el nombre, prefijo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios\r\n    para resolver las siguientes acciones relacionadas al usuario:\r\n\r\n➢ Ingresar dinero: se recibe un monto en fiat de un usuario\r\n    y se acredita al balance de fiat de dicho usuario. Además se crea una transacción del hecho donde los datos que se guardan son:fecha, tipo(ingreso de dinero), monto, usuario.\r\n\r\n➢ Comprar determinada criptomoneda: dado un monto de fiat se compra una cantidad de determinada criptomoneda,\r\n    tenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual de la criptomoneda para acreditar la correspondiente proporción en el balance de la cripto y desacreditar en el balance de fiat. Luego de ello se registra la transacción con los siguientes datos: fecha, usuario, criptomoneda, tipo: compra de cripto, monto de cripto y cotización.\r\n\r\n➢ Vender determinada criptomoneda: dado un monto de cripto se vende por fiat,\r\n    tenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual\r\n    de la criptomoneda para acreditar la correspondiente proporción en el balance de fiat\r\n    y desacreditar en el balance de la criptomoneda.\r\n        Luego de ello se registra la transacción con los siguientes datos:\r\n            fecha, usuario, criptomoneda, tipo: venta de cripto, monto de cripto y cotización.\r\n\r\n➢ Retirar criptomoneda a blockchain: dado un monto de una cripto y una blockchain\r\n    se le descuenta del balance de dicha cripto al usuario el monto,\r\n    la blockchain devuelve un hash que representa una transacción en ella\r\n    (esto hágalo retornando el nombre de la blockchain + un número random).\r\n    Luego se genera una transacción con los siguientes datos:\r\n        fecha, usuario, tipo: retiro cripto, blockchain, hash, cripto, monto, cotización.\r\n\r\n➢ Recibir criptomoneda de blockchain: dado un monto de una cripto y una blockchain se le acredita\r\n    al balancede dicha cripto al usuario el monto. Luego se genera una transacción con los siguientes datos:\r\n        fecha, usuario, tipo: recepción cripto, blockchain, cripto, monto, cotización.\r\n\r\n➢ Retirar fiat por determinado medio: dado un monto de fiat se le descuenta dicho monto del balance\r\n    al usuario y se genera una transacción con la siguiente información:\r\n        fecha, usuario, tipo: retiro fiat, monto y medio (puede ser MercadoPago o Transferencia Bancaria)\r\nN\r\n    ota:: Tanto para comprar. vender, retirar el usuario debe estar validado.\r\n        Se debe validar siempre que haya balance suficiente para realizar la operación\r\n        en los casos de compra, venta, retiro.\r\n\r\n\r\n    Además la empresa desea saber lo siguiente en base a sus operaciones:\r\n\r\n➢ Saber cual es la criptomoneda que más cantidad de ventas tiene\r\n➢ Saber cual es la criptomoneda que más cantidad de compras tiene\r\n➢ Saber cual es la criptomoneda que más volumen de ventas tiene\r\n➢ Saber cual es la criptomoneda que más volumen de compras tiene\r\n\r\n */\r\nextern crate core;\r\n\r\nmod structs;\r\n\r\nfn main() {}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","structs","date.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Clone, PartialEq, Debug, Copy, Hash)]\r\npub struct Date {\r\n    pub(crate) day: u8,\r\n    pub(crate) month: u8,\r\n    pub(crate) year: i64\r\n}\r\n\r\nimpl Default for Date {\r\n    fn default() -\u003e Self {\r\n        Date { day: 1, month: 1, year: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Date {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.day == other.day\r\n            \u0026\u0026 self.month == other.month\r\n            \u0026\u0026 self.year == other.year\r\n        { return Some(Equal) }\r\n\r\n        if self.year \u003e other.year { return Some(Greater) }\r\n        if self.month \u003e other.month { return Some(Greater) }\r\n        if self.day \u003e other.day { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Date {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.is_date_valid() {\r\n            write!(f, \"{} de {} del {}\", self.day, NOMBRE_MESES[self.month as usize - 1], self.year)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.day, self.month, self.year)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Date {\r\n    // El año podría ser negativo, indicando época antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cDate\u003e {\r\n        let fecha = Date { day: dia, month: mes, year: ano };\r\n        if fecha.is_date_valid() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn is_date_valid(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.month) { return false }\r\n\r\n        // check días del mes\r\n        if self.day == 0\r\n            || self.day \u003e self.current_month_days()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn is_leap_year(\u0026self) -\u003e bool {\r\n        self.year % 4 == 0\r\n    }\r\n\r\n    pub fn add_days(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.current_month_days();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.day + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.day = 1;\r\n                self.month += 1;\r\n\r\n                if self.month \u003e 12 {\r\n                    self.month = 1;\r\n                    self.year += 1;\r\n                }\r\n            } else {\r\n                self.day += dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn subtract_days(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.day as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.day as u32;\r\n                self.month -= 1;\r\n\r\n                if self.month \u003c 1 {\r\n                    self.month = 12;\r\n                    self.year -= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.day = self.current_month_days();\r\n            } else {\r\n                self.day -= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn current_month_days(\u0026self) -\u003e u8 {\r\n        match self.month {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.is_leap_year() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","structs","mod.rs"],"content":"pub mod xyz;\r\npub mod user;\r\npub mod date;\r\npub mod monetary_structs;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","structs","monetary_structs.rs"],"content":"//     Cada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\n//     De las criptomonedas se conoce:\r\n//         nombre, prefijo y un listado de blockchains donde se pueden enviar o recibir.\r\n//     De cada blockchain se conoce el nombre, prefijo.\r\n\r\nuse core::fmt;\r\nuse std::fmt::{Formatter};\r\nuse error_proc_macro::Error;\r\nuse crate::structs::date::Date;\r\n\r\npub struct BlockchainTransactionHash(String);\r\nimpl\u003c'a\u003e BlockchainTransactionHash {\r\n    fn new(prefix: \u0026'a str) -\u003e BlockchainTransactionHash {\r\n        BlockchainTransactionHash(format!(\"{}-{}\", prefix, rand::random::\u003cu32\u003e()))\r\n    }\r\n}\r\n\r\npub struct BlockchainTransaction\u003c'a\u003e {\r\n    pub data: CommonTransactionData,\r\n    pub blockchain: \u0026'a str,\r\n    pub hash: BlockchainTransactionHash,\r\n    pub crypto: \u0026'a str,\r\n    pub quote: Quote\r\n}\r\n\r\nimpl\u003c'a\u003e BlockchainTransaction\u003c'a\u003e {\r\n    pub fn new(data: CommonTransactionData, transaction_type: TransactionType, blockchain: \u0026'a str, hash: Option\u003cBlockchainTransactionHash\u003e, crypto: \u0026'a str, quote: Quote) -\u003e Result\u003cSelf, ErrorNewTransaction\u003c'a\u003e\u003e {\r\n        // invalid date\r\n        if !data.date.is_date_valid() { return Err(ErrorNewTransaction::InvalidDate) }\r\n\r\n        // invalid amount\r\n        if data.amount \u003c 0.0 { return Err(ErrorNewTransaction::InvalidInputAmount { amount: data.amount }) }\r\n\r\n        // invalid transaction type\r\n        if transaction_type != TransactionType::BlockchainWithdrawal\r\n        \u0026\u0026 transaction_type != TransactionType::BlockchainDeposit\r\n            { return Err(ErrorNewTransaction::InvalidTransactionType { transaction_type }) }\r\n\r\n        // unwrap or create\r\n        let hash = if let Some(val) = hash { val }\r\n                                         else { BlockchainTransactionHash::new(blockchain) };\r\n\r\n        Ok(Self {\r\n            data,\r\n            blockchain,\r\n            hash,\r\n            crypto,\r\n            quote\r\n        })\r\n    }\r\n}\r\n\r\npub struct Blockchain\u003c'a\u003e {\r\n    pub name: \u0026'a str,\r\n    pub prefix: \u0026'a str,\r\n    pub supported_cryptos: Vec\u003c\u0026'a str\u003e,\r\n}\r\n\r\nimpl\u003c'a\u003e Blockchain\u003c'a\u003e {\r\n    fn new(name: \u0026'a str, prefix: \u0026'a str, supported_cryptos: Vec\u003c\u0026'a str\u003e) -\u003e Self {\r\n        Blockchain { name, prefix, supported_cryptos }\r\n    }\r\n\r\n    // ➢ Retirar criptomoneda a blockchain: dado un monto de una cripto y una blockchain\r\n    // se le descuenta del balance de dicha cripto al usuario el monto,\r\n    // la blockchain devuelve un hash que representa una transacción en ella\r\n    // (esto hágalo retornando el nombre de la blockchain + un número random).\r\n    // Luego se genera una transacción con los siguientes datos:\r\n    // fecha, usuario, tipo: retiro cripto, blockchain, hash, cripto, monto, cotización.\r\n\r\n    fn withdraw(\u0026self, data: CommonTransactionData, transaction_type: TransactionType, crypto: \u0026'a str, quote: Quote) -\u003e Result\u003cBlockchainTransaction, ErrorNewTransaction\u003e {\r\n        if !self.supported_cryptos.contains(\u0026crypto) { return Err(ErrorNewTransaction::CryptoNotSupportedByBlockchain { crypto, blockchain: self.name }) }\r\n        \r\n        // all other checks are made by BlockchainTransaction::new()\r\n        BlockchainTransaction::new(\r\n            data,\r\n            transaction_type,\r\n            self.name,\r\n            None, // hash\r\n            crypto,\r\n            quote\r\n        )\r\n    }\r\n}\r\n\r\n//     Cada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\n//     De las criptomonedas se conoce:\r\n//         nombre, prefijo y un listado de blockchains donde se pueden enviar o recibir.\r\n//     De cada blockchain se conoce el nombre, prefijo.\r\n\r\npub enum ErrorNewCryptocurrency {\r\n    MustHaveABlockchain\r\n}\r\n\r\npub struct Cryptocurrency\u003c'a\u003e {\r\n    pub name: \u0026'a str,\r\n    pub prefix: \u0026'a str,\r\n    pub blockchains: Vec\u003c\u0026'a str\u003e // blockchains prefix\r\n}\r\n\r\nimpl\u003c'a\u003e Cryptocurrency\u003c'a\u003e {\r\n    pub fn new(name: \u0026'a str, prefix: \u0026'a str, blockchains: Vec\u003c\u0026'a str\u003e) -\u003e Result\u003cSelf, ErrorNewCryptocurrency\u003e {\r\n        if blockchains.is_empty() { return Err(ErrorNewCryptocurrency::MustHaveABlockchain) }\r\n        Ok(Cryptocurrency {\r\n            name, prefix, blockchains\r\n        })\r\n    }\r\n}\r\n\r\n// Quote\r\n// I could use a tuple instead of a whole struct,\r\n// but I want to enforce compile-time names for values\r\n// as it's not intuitive that .0 is the BUY value and .1 the SELL value\r\n// quote must be copied,\r\n#[derive(Clone)]\r\npub struct Quote {\r\n    pub buy: f64,\r\n    pub sell: f64\r\n}\r\n\r\n// CommonTransactionData\r\n// It's only purpose is to prevent having too many arguments.\r\n// It's only supposed to have data which all transactions need.\r\n// TransctionType could also be set here, but that would imply that user must set the transaction type\r\n// and I prefer transaction types to be hard-coded.\r\n#[derive(Debug, Clone, Copy, PartialEq)]\r\npub struct CommonTransactionData {\r\n    pub date: Date,\r\n    pub user: u32,\r\n    pub amount: f64,\r\n}\r\n\r\n// ➢ Ingresar dinero: se recibe un monto en fiat de un usuario\r\n//     y se acredita al balance de fiat de dicho usuario. Además se crea una transacción del hecho\r\n//      donde los datos que se guardan son:fecha, tipo(ingreso de dinero), monto, usuario.\r\n\r\n#[derive(Error)]\r\npub enum ErrorNewTransaction\u003c'a\u003e {\r\n    InvalidDate,\r\n    InvalidInputAmount{ amount: f64 },\r\n    InvalidTransactionType { transaction_type: TransactionType },\r\n    BlockchainNotDeclared,\r\n    CryptoNotSupportedByBlockchain { crypto: \u0026'a str, blockchain: \u0026'a str },\r\n    FiatWithdrawalNeedsMean\r\n}\r\n\r\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Copy)]\r\npub enum WithdrawalMean {\r\n    BankTansfer, MercadoPago\r\n}\r\n\r\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Copy)]\r\npub enum TransactionType {\r\n    FiatDeposit,\r\n    FiatWithdrawal { mean: WithdrawalMean },\r\n    BlockchainDeposit,\r\n    BlockchainWithdrawal,\r\n    CryptoBuy,\r\n    CryptoSell\r\n}\r\n\r\nimpl fmt::Display for TransactionType {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        match self {\r\n            TransactionType::FiatDeposit =\u003e write!(f, \"Fiat Deposit\"),\r\n            TransactionType::FiatWithdrawal { mean } =\u003e write!(f, \"Fiat Withdrawal via {:?}\", mean),\r\n            TransactionType::BlockchainDeposit =\u003e write!(f, \"Blockchain Deposit\"),\r\n            TransactionType::BlockchainWithdrawal =\u003e write!(f, \"Blockchain Withdrawal\"),\r\n            TransactionType::CryptoBuy =\u003e write!(f, \"Crypto Buy\"),\r\n            TransactionType::CryptoSell =\u003e write!(f, \"Crypto Sell\"),\r\n        }\r\n    }\r\n}\r\n\r\npub struct FiatTransaction {\r\n    pub data: CommonTransactionData,\r\n    pub transaction_type: TransactionType\r\n}\r\n\r\n// all FIAT transfers will be treated as Argentine Peso transfers\r\n\r\nimpl\u003c'a\u003e FiatTransaction {\r\n    pub fn new(data: CommonTransactionData, transaction_type: TransactionType) -\u003e Result\u003cSelf, ErrorNewTransaction\u003c'a\u003e\u003e {\r\n        match transaction_type {\r\n            TransactionType::FiatDeposit =\u003e (),\r\n            TransactionType::FiatWithdrawal { .. } =\u003e (),\r\n            _ =\u003e return Err(ErrorNewTransaction::InvalidTransactionType { transaction_type })\r\n        }\r\n        \r\n        if !data.date.is_date_valid() { return Err(ErrorNewTransaction::InvalidDate) }\r\n        if data.amount \u003c= 0.0 { return Err(ErrorNewTransaction::InvalidInputAmount{ amount: data.amount }) }\r\n\r\n        // user verifications must be done service-side\r\n\r\n        Ok(FiatTransaction {\r\n            data, transaction_type\r\n        })\r\n    }\r\n}\r\n\r\n//\r\n// Crypto Transaction\r\n//\r\n\r\npub struct CryptoTransaction\u003c'a\u003e {\r\n    pub data: CommonTransactionData,\r\n    pub currency: \u0026'a str,\r\n}\r\n\r\n// all FIAT transfers will all be treated as Argentine Peso transfers\r\n\r\nimpl\u003c'a\u003e CryptoTransaction\u003c'a\u003e {\r\n    pub fn new(data: CommonTransactionData, transaction_type: TransactionType, currency: \u0026'a str) -\u003e Result\u003cSelf, ErrorNewTransaction\u003e {\r\n        if !data.date.is_date_valid() { return Err(ErrorNewTransaction::InvalidDate) }\r\n        if data.amount \u003c 0.0 { return Err(ErrorNewTransaction::InvalidInputAmount{ amount: data.amount }) }\r\n\r\n        match transaction_type {\r\n            TransactionType::CryptoBuy =\u003e (),\r\n            TransactionType::CryptoSell =\u003e (),\r\n            _ =\u003e { return Err(ErrorNewTransaction::InvalidTransactionType { transaction_type }) }\r\n        }\r\n        \r\n        // blockchain, currency, user_from, user_to verifications must be done service-side\r\n\r\n\r\n        Ok(CryptoTransaction {\r\n            data, currency\r\n        })\r\n    }\r\n}","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","structs","user.rs"],"content":"/*\r\n\r\n5- La empresa XYZ es una plataforma de intercambio de criptoactivos\r\n    que permite a los usuarios comprar y vender distintas criptomonedas.\r\n\r\n    La plataforma permite el registro de usuarios y la gestión de sus balances\r\n        en distintas criptomonedas y en dinero fíat.\r\n    De los usuarios se conoce:\r\n        nombre, apellido, email, dni, y si está validada su identidad o no.\r\n\r\n    Cada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\n    De las criptomonedas se conoce:\r\n        nombre, prefijo y un listado de blockchains donde se pueden enviar o recibir.\r\n    De cada blockchain se conoce el nombre, prefijo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios\r\n    para resolver las siguientes acciones relacionadas al usuario:\r\n\r\n➢ Ingresar dinero: se recibe un monto en fiat de un usuario\r\n    y se acredita al balance de fiat de dicho usuario. Además se crea una transacción del hecho donde los datos que se guardan son:fecha, tipo(ingreso de dinero), monto, usuario.\r\n\r\n➢ Comprar determinada criptomoneda: dado un monto de fiat se compra una cantidad de determinada criptomoneda,\r\n    tenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual de la criptomoneda para acreditar la correspondiente proporción en el balance de la cripto y desacreditar en el balance de fiat. Luego de ello se registra la transacción con los siguientes datos: fecha, usuario, criptomoneda, tipo: compra de cripto, monto de cripto y cotización.\r\n\r\n➢ Vender determinada criptomoneda: dado un monto de cripto se vende por fiat,\r\n    tenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual\r\n    de la criptomoneda para acreditar la correspondiente proporción en el balance de fiat\r\n    y desacreditar en el balance de la criptomoneda.\r\n        Luego de ello se registra la transacción con los siguientes datos:\r\n            fecha, usuario, criptomoneda, tipo: venta de cripto, monto de cripto y cotización.\r\n\r\n➢ Retirar criptomoneda a blockchain: dado un monto de una cripto y una blockchain\r\n    se le descuenta del balance de dicha cripto al usuario el monto,\r\n    la blockchain devuelve un hash que representa una transacción en ella\r\n    (esto hágalo retornando el nombre de la blockchain + un número random).\r\n    Luego se genera una transacción con los siguientes datos:\r\n        fecha, usuario, tipo: retiro cripto, blockchain, hash, cripto, monto, cotización.\r\n\r\n➢ Recibir criptomoneda de blockchain: dado un monto de una cripto y una blockchain se le acredita\r\n    al balancede dicha cripto al usuario el monto. Luego se genera una transacción con los siguientes datos:\r\n        fecha, usuario, tipo: recepción cripto, blockchain, cripto, monto, cotización.\r\n\r\n➢ Retirar fiat por determinado medio: dado un monto de fiat se le descuenta dicho monto del balance\r\n    al usuario y se genera una transacción con la siguiente información:\r\n        fecha, usuario, tipo: retiro fiat, monto y medio (puede ser MercadoPago o Transferencia Bancaria)\r\nN\r\n    ota:: Tanto para comprar. vender, retirar el usuario debe estar validado.\r\n        Se debe validar siempre que haya balance suficiente para realizar la operación\r\n        en los casos de compra, venta, retiro.\r\n\r\n\r\n    Además la empresa desea saber lo siguiente en base a sus operaciones:\r\n\r\n➢ Saber cual es la criptomoneda que más cantidad de ventas tiene\r\n➢ Saber cual es la criptomoneda que más cantidad de compras tiene\r\n➢ Saber cual es la criptomoneda que más volumen de ventas tiene\r\n➢ Saber cual es la criptomoneda que más volumen de compras tiene\r\n\r\n */\r\n\r\n//    De los usuarios se conoce:\r\n//         nombre, apellido, email, dni, y si está validada su identidad o no.\r\n//     Cada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\n\r\nuse std::collections::HashMap;\r\nuse std::hash::{Hash, Hasher};\r\nuse std::ops::{AddAssign, SubAssign};\r\n\r\n#[derive(Debug, PartialEq, PartialOrd, Clone, Copy)]\r\npub struct Balance(pub f64);\r\n\r\nimpl Balance {\r\n    pub fn new(balance: f64) -\u003e Self {\r\n        Balance(balance)\r\n    }\r\n    pub fn add_assign_f64(\u0026mut self, val: f64) {\r\n        self.0+= val;\r\n    }\r\n    pub fn sub_assign_f64(\u0026mut self, val: f64) {\r\n        self.0-= val;\r\n    }\r\n    pub fn f64(\u0026self) -\u003e f64 { self.0 }\r\n}\r\nimpl Hash for Balance {\r\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\r\n        self.0.to_bits().hash(state);\r\n    }\r\n}\r\nimpl AddAssign for Balance {\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        self.0 += rhs.0;\r\n    }\r\n}\r\nimpl SubAssign for Balance {\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        self.0 -= rhs.0;\r\n    }\r\n}\r\nimpl From\u003cf64\u003e for Balance {\r\n    fn from(value: f64) -\u003e Self {\r\n        Balance(value)\r\n    }\r\n}\r\n\r\ntrait AsBalance {\r\n    fn as_balance(\u0026self) -\u003e Balance;\r\n}\r\nimpl AsBalance for f64 {\r\n    fn as_balance(\u0026self) -\u003e Balance {\r\n        Balance(self.clone())\r\n    }\r\n}\r\n\r\n// user\r\n\r\n#[derive(Debug)]\r\npub struct User\u003c'a\u003e {\r\n    pub first_name: \u0026'a str,\r\n    pub last_name: \u0026'a str,\r\n    pub email: \u0026'a str,\r\n    pub dni: u32, // primary key\r\n    pub identity_validation: bool,\r\n    pub fiat_balance: Balance,\r\n    pub crypto_balance: HashMap\u003c\u0026'a str, Balance\u003e\r\n}\r\n\r\nimpl\u003c'a\u003e Hash for User\u003c'a\u003e {\r\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\r\n        self.first_name.hash(state);\r\n        self.last_name.hash(state);\r\n        self.email.hash(state);\r\n        self.dni.hash(state);\r\n        self.identity_validation.hash(state);\r\n        self.fiat_balance.hash(state);\r\n    }\r\n}\r\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","ej5","structs","xyz.rs"],"content":"/*\r\n5- La empresa XYZ es una plataforma de intercambio de criptoactivos\r\nque permite a los usuarios comprar y vender distintas criptomonedas.\r\n\r\nLa plataforma permite el registro de usuarios y la gestión de sus balances\r\nen distintas criptomonedas y en dinero fíat.\r\nDe los usuarios se conoce:\r\nnombre, apellido, email, dni, y si está validada su identidad o no.\r\n\r\nCada usuario tiene un balance de las criptomonedas que se ofrecen en la plataforma.\r\nDe las criptomonedas se conoce:\r\nnombre, prefijo y un listado de blockchains donde se pueden enviar o recibir.\r\nDe cada blockchain se conoce el nombre, prefijo.\r\n\r\nImplemente las estructuras, funciones asociadas y traits necesarios\r\npara resolver las siguientes acciones relacionadas al usuario:\r\n\r\n➢ Ingresar dinero: se recibe un monto en fiat de un usuario\r\ny se acredita al balance de fiat de dicho usuario. Además se crea una transacción del hecho donde los datos que se guardan son:fecha, tipo(ingreso de dinero), monto, usuario.\r\n\r\n➢ Comprar determinada criptomoneda: dado un monto de fiat se compra una cantidad de determinada criptomoneda,\r\ntenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual de la criptomoneda para acreditar la correspondiente proporción en el balance de la cripto y desacreditar en el balance de fiat. Luego de ello se registra la transacción con los siguientes datos: fecha, usuario, criptomoneda, tipo: compra de cripto, monto de cripto y cotización.\r\n\r\n➢ Vender determinada criptomoneda: dado un monto de cripto se vende por fiat,\r\ntenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual\r\nde la criptomoneda para acreditar la correspondiente proporción en el balance de fiat\r\ny desacreditar en el balance de la criptomoneda.\r\nLuego de ello se registra la transacción con los siguientes datos:\r\nfecha, usuario, criptomoneda, tipo: venta de cripto, monto de cripto y cotización.\r\n\r\n➢ Retirar criptomoneda a blockchain: dado un monto de una cripto y una blockchain\r\nse le descuenta del balance de dicha cripto al usuario el monto,\r\nla blockchain devuelve un hash que representa una transacción en ella\r\n(esto hágalo retornando el nombre de la blockchain + un número random).\r\nLuego se genera una transacción con los siguientes datos:\r\nfecha, usuario, tipo: retiro cripto, blockchain, hash, cripto, monto, cotización.\r\n\r\n➢ Recibir criptomoneda de blockchain: dado un monto de una cripto y una blockchain se le acredita\r\nal balancede dicha cripto al usuario el monto. Luego se genera una transacción con los siguientes datos:\r\nfecha, usuario, tipo: recepción cripto, blockchain, cripto, monto, cotización.\r\n\r\n➢ Retirar fiat por determinado medio: dado un monto de fiat se le descuenta dicho monto del balance\r\nal usuario y se genera una transacción con la siguiente información:\r\nfecha, usuario, tipo: retiro fiat, monto y medio (puede ser MercadoPago o Transferencia Bancaria)\r\n\r\nNota:: Tanto para comprar. vender, retirar el usuario debe estar validado.\r\nSe debe validar siempre que haya balance suficiente para realizar la operación\r\nen los casos de compra, venta, retiro.\r\n\r\n\r\nAdemás la empresa desea saber lo siguiente en base a sus operaciones:\r\n\r\n➢ Saber cual es la criptomoneda que más cantidad de ventas tiene\r\n➢ Saber cual es la criptomoneda que más cantidad de compras tiene\r\n➢ Saber cual es la criptomoneda que más volumen de ventas tiene\r\n➢ Saber cual es la criptomoneda que más volumen de compras tiene\r\n\r\n*/\r\nuse error_proc_macro::Error;\r\nuse std::collections::{BTreeMap, HashMap};\r\nuse crate::structs::user::{Balance, User};\r\nuse crate::structs::monetary_structs::{Blockchain, BlockchainTransaction, CommonTransactionData, CryptoTransaction, ErrorNewTransaction, FiatTransaction, Quote, TransactionType, WithdrawalMean};\r\n\r\npub struct XYZ\u003c'a\u003e {\r\n    pub users: BTreeMap\u003cu32, User\u003c'a\u003e\u003e,\r\n    pub blockchains: BTreeMap\u003c\u0026'a str, Blockchain\u003c'a\u003e\u003e,\r\n    pub quotes: HashMap\u003c\u0026'a str, Quote\u003e // (buy, sell) prices\r\n}\r\n\r\n//\r\n// errors\r\n//\r\n\r\n#[derive(Error)]\r\npub enum ErrorFiatDeposit\u003c'a\u003e {\r\n    FiatTransactionError(ErrorNewTransaction\u003c'a\u003e),\r\n    UserNotFound{ user_dni: u32 }\r\n}\r\n\r\n#[derive(Error)]\r\npub enum ErrorFiatWithdraw\u003c'a\u003e {\r\n    FiatTransactionError(ErrorNewTransaction\u003c'a\u003e),\r\n    UserNotFound{ user_dni: u32 },\r\n    NotEnoughBalance{ balance: f64, balance_needed: f64 },\r\n}\r\n\r\n#[derive(Error)]\r\npub enum ErrorBlockchainDeposit\u003c'a\u003e {\r\n    BlockchainTransactionError(ErrorNewTransaction\u003c'a\u003e),\r\n    BlockchainNotFound{ blockchain: \u0026'a str },\r\n    CryptoNotQuoted{ crypto: \u0026'a str },\r\n    UserNotFound{ user_dni: u32 },\r\n}\r\n\r\n#[derive(Error)]\r\npub enum ErrorBlockchainWithdraw\u003c'a\u003e {\r\n    BlockchainTransactionError(ErrorNewTransaction\u003c'a\u003e),\r\n    BlockchainNotFound{ blockchain: \u0026'a str },\r\n    CryptoNotQuoted{ crypto: \u0026'a str },\r\n    UserNotFound{ user_dni: u32 },\r\n    NotEnoughBalance{ balance: f64, balance_needed: f64 }\r\n}\r\n\r\n#[derive(Error)]\r\npub enum ErrorBuySell\u003c'a\u003e {\r\n    CryptoTransactionError(ErrorNewTransaction\u003c'a\u003e),\r\n    CryptocurrencyNotQuoted { crypto_prefix: \u0026'a str },\r\n    UserNotFound { user_dni: u32 },\r\n    NotEnoughBalance { balance: f64, balance_needed: f64 },\r\n    NegativeAmount,\r\n    Unknown(String)\r\n}\r\n\r\nimpl\u003c'a\u003e XYZ\u003c'a\u003e {\r\n    fn new(users: BTreeMap\u003cu32, User\u003c'a\u003e\u003e, blockchains: BTreeMap\u003c\u0026'a str, Blockchain\u003c'a\u003e\u003e, quotes: HashMap\u003c\u0026'a str, Quote\u003e) -\u003e Self {\r\n        Self { users, blockchains, quotes }\r\n    }\r\n\r\n    // ➢ Ingresar dinero: se recibe un monto en fiat de un usuario\r\n    //  y se acredita al balance de fiat de dicho usuario. Además se crea una transacción del hecho.\r\n    fn fiat_deposit(\u0026mut self, data: CommonTransactionData) -\u003e Result\u003cFiatTransaction, ErrorFiatDeposit\u003e {\r\n        // date errors are handled by FiatTransaction::new()\r\n        match FiatTransaction::new(\r\n            data,\r\n            TransactionType::FiatDeposit\r\n        ) {\r\n            Ok(transaction) =\u003e {\r\n                // deposit\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    user.fiat_balance += Balance::from(data.amount);\r\n                } else {\r\n                    return Err(ErrorFiatDeposit::UserNotFound{ user_dni: data.user });\r\n                }\r\n\r\n                Ok(transaction)\r\n            },\r\n            Err(transaction_error) =\u003e Err(ErrorFiatDeposit::FiatTransactionError(transaction_error))\r\n        }\r\n    }\r\n\r\n    // ➢ Retirar fiat por determinado medio: dado un monto de fiat se le descuenta dicho monto del balance\r\n    // al usuario y se genera una transacción con la siguiente información:\r\n    // fecha, usuario, tipo: retiro fiat, monto y medio (puede ser MercadoPago o Transferencia Bancaria)\r\n    fn fiat_withdraw(\u0026mut self, data: CommonTransactionData, mean: WithdrawalMean) -\u003e Result\u003cFiatTransaction, ErrorFiatWithdraw\u003e {\r\n\r\n        match FiatTransaction::new(\r\n            data,\r\n            TransactionType::FiatWithdrawal{ mean }\r\n        ) {\r\n            Ok(transaction) =\u003e {\r\n                // does user exist/have enough balance?\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    // not enough! abort.\r\n                    if user.fiat_balance \u003c Balance(data.amount) { return Err( ErrorFiatWithdraw::NotEnoughBalance {\r\n                        balance_needed: data.amount, balance: user.fiat_balance.f64()\r\n                    }) }\r\n\r\n                    // enough! substract balance\r\n                    user.fiat_balance-= Balance(data.amount);\r\n                } else {\r\n                    return Err(ErrorFiatWithdraw::UserNotFound { user_dni: data.user })\r\n                };\r\n\r\n                Ok(transaction)\r\n            }\r\n            Err(error) =\u003e { Err(ErrorFiatWithdraw::FiatTransactionError( error )) }\r\n        }\r\n    }\r\n\r\n    // ➢ Comprar determinada criptomoneda: dado un monto de fiat se compra una cantidad de determinada criptomoneda,\r\n    //  tenga en cuenta que al momento de realizar la operación se obtiene del sistema\r\n    //  la cotización actual de la criptomoneda para acreditar la correspondiente proporción en el balance\r\n    //  de la cripto y desacreditar en el balance de fiat.\r\n    // Luego de ello se registra la transacción con los siguientes datos:\r\n    //      fecha, usuario, criptomoneda, tipo: compra de cripto, monto de cripto y cotización.\r\n    fn buy_crypto(\u0026mut self, data: CommonTransactionData, crypto_prefix: \u0026'a str)\r\n                  -\u003e Result\u003cCryptoTransaction\u003c'a\u003e, ErrorBuySell\u003e {\r\n        // date errors are handled by CryptoTransaction::new()\r\n\r\n        // check 1: invalid fiat amount\r\n        if data.amount \u003c 0.0 {\r\n            return Err(ErrorBuySell::NegativeAmount)\r\n        }\r\n\r\n        match CryptoTransaction::new(\r\n            data,\r\n            TransactionType::CryptoBuy,\r\n            crypto_prefix\r\n        ) {\r\n\r\n            Ok(transaction) =\u003e {\r\n                // process buy\r\n\r\n                // check 2: currency must be quoted AND quoted higher than 0.0\r\n                let currency_unitary_value = if let Some(quoting) = self.quotes.get(crypto_prefix) {\r\n                    if quoting.buy \u003c= 0.0 { return Err(ErrorBuySell::Unknown(format!(\"${crypto_prefix} is valued at {} FIAT (which is \u003c= 0)\", quoting.buy))) }\r\n                    quoting.buy\r\n                } else {\r\n                    return Err(ErrorBuySell::CryptocurrencyNotQuoted{ crypto_prefix });\r\n                };\r\n\r\n                let transaction_crypto_amount = data.amount / currency_unitary_value; // .0 -\u003e buy, .1 -\u003e sell\r\n\r\n                // check 3: user must exist\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    // check 4: user must have enough fiat balance\r\n                    if user.fiat_balance \u003c Balance::from(data.amount) {\r\n                        return Err(ErrorBuySell::NotEnoughBalance{ balance: user.fiat_balance.f64(), balance_needed: data.amount })\r\n                    }\r\n\r\n                    // no error. execute operation\r\n                    user.fiat_balance-= Balance::from(data.amount);\r\n                    *user.crypto_balance.entry(crypto_prefix).or_insert(Balance::from(0.0))+= Balance::from(transaction_crypto_amount);\r\n                } else {\r\n                    return Err(ErrorBuySell::UserNotFound{ user_dni: data.user });\r\n                };\r\n\r\n                Ok(transaction)\r\n            },\r\n            Err(error) =\u003e Err(ErrorBuySell::CryptoTransactionError(error))\r\n        }\r\n    }\r\n\r\n    // ➢ Vender determinada criptomoneda: dado un monto de cripto se vende por fiat,\r\n    //  tenga en cuenta que al momento de realizar la operación se obtiene del sistema la cotización actual\r\n    //  de la criptomoneda para acreditar la correspondiente proporción en el balance de fiat\r\n    //  y desacreditar en el balance de la criptomoneda.\r\n    //  Luego de ello se registra la transacción con los siguientes datos:\r\n    //  fecha, usuario, criptomoneda, tipo: venta de cripto, monto de cripto y cotización.\r\n    fn sell_crypto(\u0026mut self, data: CommonTransactionData, crypto_prefix: \u0026'a str) -\u003e\r\n        Result\u003cCryptoTransaction, ErrorBuySell\u003e {\r\n        // date errors are handled by CryptoTransaction::new()\r\n\r\n        // check 1: amounts should be higher than 0\r\n        if data.amount \u003c= 0.0 {\r\n            return Err(ErrorBuySell::NegativeAmount)\r\n        }\r\n\r\n        match CryptoTransaction::new(\r\n            data,\r\n            TransactionType::CryptoSell,\r\n            crypto_prefix,\r\n        ) {\r\n            Ok(transaction) =\u003e {\r\n                // process sell\r\n\r\n                // check 2: currency must be quoted AND quoted higher than 0.0\r\n                let currency_value = if let Some(quoting) = self.quotes.get(crypto_prefix) {\r\n                    if quoting.sell \u003c= 0.0 { return Err(ErrorBuySell::Unknown(format!(\"${crypto_prefix} is valued at {} FIAT (which is \u003c= 0)\", quoting.sell))) }\r\n                    quoting\r\n                } else {\r\n                    return Err(ErrorBuySell::CryptocurrencyNotQuoted{ crypto_prefix });\r\n                };\r\n\r\n                let transaction_fiat_value = currency_value.sell * data.amount;\r\n\r\n                // check 3: user must exist\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    // check 4: user must have enough $crypto_prefix balance\r\n                    if let Some(user_crypto_balance) = user.crypto_balance.get_mut(crypto_prefix) {\r\n                        if *user_crypto_balance \u003c Balance::from(data.amount) {\r\n                            return Err(ErrorBuySell::NotEnoughBalance { balance: user_crypto_balance.f64(), balance_needed: data.amount })\r\n                        }\r\n                        \r\n                        // no error. execute operation\r\n                        *user_crypto_balance-= Balance::from(data.amount);\r\n                        user.fiat_balance+= Balance::from(transaction_fiat_value);\r\n                    } else {\r\n                        return Err(ErrorBuySell::NotEnoughBalance{ balance: 0.0, balance_needed: data.amount })\r\n                    }\r\n                } else {\r\n                    return Err(ErrorBuySell::UserNotFound{ user_dni: data.user });\r\n                };\r\n\r\n                Ok(transaction)\r\n            },\r\n            Err(error) =\u003e Err(ErrorBuySell::CryptoTransactionError(error))\r\n        }\r\n    }\r\n\r\n    // ➢ Retirar criptomoneda a blockchain: dado un monto de una cripto y una blockchain\r\n    // se le descuenta del balance de dicha cripto al usuario el monto,\r\n    // la blockchain devuelve un hash que representa una transacción en ella\r\n    // (esto hágalo retornando el nombre de la blockchain + un número random).\r\n    // Luego se genera una transacción con los siguientes datos:\r\n    // fecha, usuario, tipo: retiro cripto, blockchain, hash, cripto, monto, cotización.\r\n    fn withdraw_to_blockchain(\u0026mut self, data: CommonTransactionData, blockchain: \u0026'a str, crypto: \u0026'a str) -\u003e Result\u003cBlockchainTransaction, ErrorBlockchainWithdraw\u003e {\r\n        // does blockchain exist?\r\n        if !self.blockchains.contains_key(blockchain) {\r\n            return Err(ErrorBlockchainWithdraw::BlockchainNotFound { blockchain })\r\n        };\r\n\r\n        // does crypto have a quote?\r\n        let quote = if let Some(quote) = self.quotes.get(crypto) {\r\n            quote\r\n        } else {\r\n            return Err(ErrorBlockchainWithdraw::CryptoNotQuoted { crypto })\r\n        };\r\n\r\n        match BlockchainTransaction::new(\r\n            data,\r\n            TransactionType::BlockchainWithdrawal,\r\n            blockchain,\r\n            None,\r\n            crypto,\r\n            quote.clone() // quote should be cloned, as it changes over time. can't be copied due to containing f64\r\n        ) {\r\n            Ok(transaction) =\u003e {\r\n                // remove balance\r\n                // does user exist/have enough balance?\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    if let Some(balance) = user.crypto_balance.get_mut(crypto) {\r\n                        *balance-= Balance::from(data.amount);\r\n                    } else {\r\n                        return Err(ErrorBlockchainWithdraw::NotEnoughBalance { balance: 0.0, balance_needed: data.amount } )\r\n                    };\r\n                } else {\r\n                    return Err(ErrorBlockchainWithdraw::UserNotFound { user_dni: data.user })\r\n                };\r\n                Ok(transaction)\r\n            }\r\n            Err(error) =\u003e { Err(ErrorBlockchainWithdraw::BlockchainTransactionError( error )) }\r\n        }\r\n    }\r\n\r\n    // ➢ Recibir criptomoneda de blockchain: dado un monto de una cripto y una blockchain se le acredita\r\n    // al balancede dicha cripto al usuario el monto. Luego se genera una transacción con los siguientes datos:\r\n    // fecha, usuario, tipo: recepción cripto, blockchain, cripto, monto, cotización.\r\n    fn deposit_from_blockchain(\u0026mut self, data: CommonTransactionData, blockchain: \u0026'a str, crypto: \u0026'a str) -\u003e Result\u003cBlockchainTransaction, ErrorBlockchainDeposit\u003e {\r\n        // does blockchain exist?\r\n        if !self.blockchains.contains_key(blockchain) {\r\n            return Err(ErrorBlockchainDeposit::BlockchainNotFound { blockchain })\r\n        };\r\n\r\n        // does crypto have a quote?\r\n        let quote = if let Some(q) = self.quotes.get(crypto) {\r\n            q\r\n        } else {\r\n            return Err(ErrorBlockchainDeposit::CryptoNotQuoted { crypto })\r\n        };\r\n\r\n        match BlockchainTransaction::new(\r\n            data,\r\n            TransactionType::BlockchainDeposit,\r\n            blockchain,\r\n            None,\r\n            crypto,\r\n            quote.clone() // quote should be cloned, as it changes over time. can't be copied due to containing f64\r\n        ) {\r\n            Ok(transaction) =\u003e {\r\n                // add to balance\r\n                // does user exist/have enough balance?\r\n                if let Some(user) = self.users.get_mut(\u0026data.user) {\r\n                    // enough! ready to withdraw\r\n                    user.fiat_balance+= Balance::from(data.amount);\r\n                } else {\r\n                    return Err(ErrorBlockchainDeposit::UserNotFound { user_dni: data.user })\r\n                };\r\n\r\n                Ok(transaction)\r\n            }\r\n            Err(error) =\u003e { Err(ErrorBlockchainDeposit::BlockchainTransactionError( error )) }\r\n        }\r\n    }\r\n\r\n    // Nota:: Tanto para comprar. vender, retirar el usuario debe estar validado.\r\n    // Se debe validar siempre que haya balance suficiente para realizar la operación\r\n    // en los casos de compra, venta, retiro.\r\n}","traces":[{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":102},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac4","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e1","src","main.rs"],"content":"pub mod structs;\n\n/*\na- Al agregar un auto si supera el límite de la concesionaria debe arrojar un error propio con un mensaje de contexto.\n\nb- Haga todos los tests correspondientes para probar en profundidad los métodos que agregan un auto y eliminan un auto de la concesionaria,\n    obteniendo el mayor porcentaje de coverage sobre el código que realiza las operaciones.\n\nc- Una vez hecho el punto anterior debe hacer que los autos de la concesionaria se almacenen en un archivo en formato JSON.\n    Agregue y modifique lo que considere necesario para que:\n        - Al agregar un nuevo auto se abre el archivo de autos guardados y lo agregue a dicho archivo.\n        - Eliminar un auto: al eliminar un auto se debe eliminar este del archivo.\n\nNo debe modificar los tests hechos en el punto b. Si puede agregar más en caso de que haga nueva funcionalidad..\n */\n\nfn main() {\n    println!(\"Hello, world!\");\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e1","src","structs","auto.rs"],"content":"use error_proc_macro::Error;\r\nuse serde::{Serialize, Serializer};\r\n\r\n#[derive(Serialize, PartialEq, Clone)]\r\npub enum Color {\r\n    Rojo, Verde, Azul, Amarillo, Blanco, Negro\r\n}\r\n\r\n#[derive(Serialize, PartialEq, Clone)]\r\npub struct Auto\u003c'a\u003e {\r\n    pub marca: \u0026'a str,\r\n    pub modelo: \u0026'a str,\r\n    pub ano: u16,\r\n    pub precio: f64,\r\n    pub color: Color\r\n}\r\n\r\n#[derive(Error)]\r\npub enum ErrorNewAuto {\r\n    InvalidYear{ year: u16 },\r\n    InvalidPrice{ price: f64 },\r\n}\r\n\r\nimpl\u003c'a\u003e Auto\u003c'a\u003e {\r\n    // ➢ new: que pasando los parámetros correspondientes, crea un Auto y lo retorna.\r\n    pub fn new(marca: \u0026'a str, modelo: \u0026'a str, ano: u16, precio: f64, color: Color) -\u003e Result\u003cSelf, ErrorNewAuto\u003e {\r\n        if ano \u003c 1886 { return Err(ErrorNewAuto::InvalidYear{ year: ano }) }\r\n        if precio \u003c 0.0 || precio.is_nan() || !precio.is_finite() { return Err(ErrorNewAuto::InvalidPrice{ price: precio }) }\r\n        \r\n        Ok(Self { marca, modelo, ano, precio, color })\r\n    }\r\n\r\n    // ➢ calcular_precio: retorna el precio del auto aplicando los siguientes criterios:\r\n    pub fn calcular_precio(\u0026self) -\u003e f64 {\r\n        // ■ si es de color primario le aplica un recargo del 25%, sino le aplica un descuento del 10%.\r\n        let recargo_color = match self.color {\r\n            Color::Rojo | Color::Azul | Color::Amarillo =\u003e self.precio * 0.25,\r\n            _ =\u003e self.precio * -0.1\r\n        };\r\n\r\n        // ■ si la marca es BMW le aplica un recargo del 15%\r\n        let recargo_bmw = if self.marca == \"BMW\" { self.precio * 0.15 } else { 0.0 };\r\n\r\n        // ■ si el año es menor a 2000 le aplica un descuento del 5%.\r\n        let descuento_ano = if self.ano \u003c 2000 { self.precio * 0.05 } else { 0.0 };\r\n\r\n        self.precio + recargo_color + recargo_bmw - descuento_ano\r\n    }\r\n}","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e1","src","structs","concesionario.rs"],"content":"use std::fs;\r\nuse error_proc_macro::Error;\r\nuse crate::structs::auto::Auto;\r\n\r\npub struct Concesionario\u003c'a\u003e {\r\n    pub nombre: \u0026'a str,\r\n    pub direccion: \u0026'a str,\r\n    pub autos: Vec\u003cAuto\u003c'a\u003e\u003e\r\n}\r\n\r\n#[derive(Error, PartialEq)]\r\npub enum ErrorAgregarAuto {\r\n    ConcesionarioLleno { capacidad: usize },\r\n    ArchivoNoGuardado\r\n}\r\n\r\n#[derive(Error, PartialEq)]\r\npub enum ErrorEliminarAuto {\r\n    ConcesionarioVacio,\r\n    AutoInexistente,\r\n    ArchivoNoGuardado\r\n}\r\n\r\nimpl\u003c'a\u003e Concesionario\u003c'a\u003e {\r\n    // ➢ new: que pasando los parámetros correspondientes, crea un ConcesionarioAuto y lo retorna.\r\n    pub fn new(nombre: \u0026'a str, direccion: \u0026'a str, capacidad: usize) -\u003e Self {\r\n        Self { nombre, direccion, autos: Vec::with_capacity(capacidad) }\r\n    }\r\n\r\n    // c- Una vez hecho el punto anterior debe hacer que los autos de la concesionaria se\r\n    // almacenen en un archivo en formato JSON. Agregue y modifique lo que considere necesario para que:\r\n    //  - Al agregar un nuevo auto se abre el archivo de autos guardados y lo agregue a dicho archivo.\r\n    //  - Eliminar un auto: al eliminar un auto se debe eliminar este del archivo.\r\n\r\n    // ➢ agregar_auto(auto): agrega un auto a la lista de autos que tiene\r\n    //     sin superar la máxima cantidad para albergarlos\r\n    //     y retorna true, en caso de que lo supere no lo agrega y retorna false.\r\n    // returns usize -\u003e Espacio disponible\r\n    pub fn agregar_auto(\u0026mut self, auto: Auto\u003c'a\u003e) -\u003e Result\u003cusize, ErrorAgregarAuto\u003e {\r\n        // a- Al agregar un auto si supera el límite de la concesionaria debe arrojar un error propio con un mensaje de contexto.\r\n        if  self.autos.len() == self.autos.capacity() {\r\n            return Err(ErrorAgregarAuto::ConcesionarioLleno { capacidad: self.autos.capacity() })\r\n        }\r\n\r\n        self.autos.push(auto);\r\n\r\n        if !self.reescribir_json_autos() { return Err(ErrorAgregarAuto::ArchivoNoGuardado) }\r\n\r\n        Ok(\r\n            self.autos.capacity() - self.autos.len()\r\n        )\r\n    }\r\n\r\n    // ➢ eliminar_auto(auto): elimina un auto de la lista de autos.\r\n    pub fn eliminar_auto(\u0026mut self, marca: \u0026'a str, modelo: \u0026'a str, ano: u16) -\u003e Result\u003cAuto, ErrorEliminarAuto\u003e {\r\n        if self.autos.is_empty() { return Err(ErrorEliminarAuto::ConcesionarioVacio) }\r\n\r\n        let mut found_index = 0;\r\n        let mut found = false;\r\n        for (index, auto) in self.autos.iter().enumerate() {\r\n            if auto.marca == marca \u0026\u0026 auto.modelo == modelo \u0026\u0026 auto.ano == ano {\r\n                found_index = index; found = true; break;\r\n            }\r\n        }\r\n\r\n        if !found {\r\n            return Err(ErrorEliminarAuto::AutoInexistente)\r\n        }\r\n\r\n        let auto = self.autos.remove(found_index);\r\n\r\n        if !self.reescribir_json_autos() { Err(ErrorEliminarAuto::ArchivoNoGuardado) }\r\n        else { Ok(auto) }\r\n    }\r\n\r\n    fn reescribir_json_autos(\u0026self) -\u003e bool {\r\n        // c. reescribir el archivo con la información del vector de autos\r\n        match serde_json::to_string_pretty(\u0026self.autos) {\r\n            Ok(res) =\u003e {\r\n                if fs::write(\"autos.json\", res).is_err() {\r\n                    return false\r\n                }\r\n                true\r\n            }\r\n            Err(_) =\u003e { false }\r\n        }\r\n    }\r\n\r\n    // ➢ buscar_auto(auto): busca un auto y si lo encuentra lo retorna.\r\n    pub fn buscar_auto(\u0026self, marca: \u0026'a str, modelo: \u0026'a str, ano: u16) -\u003e Option\u003c\u0026Auto\u003e {\r\n        for auto in \u0026self.autos {\r\n            if auto.marca == marca \u0026\u0026 auto.modelo == modelo \u0026\u0026 auto.ano == ano {\r\n                return Some(auto)\r\n            }\r\n        }\r\n\r\n        None\r\n    }\r\n}\r\n\r\n/*\r\n    b- Haga todos los tests correspondientes para probar en profundidad los métodos que agregan un auto y eliminan un auto de la concesionaria,\r\n        obteniendo el mayor porcentaje de coverage sobre el código que realiza las operaciones.\r\n */\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::structs::auto::Color;\r\n    use super::*;\r\n\r\n    fn concesionario\u003c'a\u003e(capacity: usize) -\u003e Concesionario\u003c'a\u003e {\r\n        Concesionario{\r\n            nombre: \"asd\",\r\n            direccion: \"dire\",\r\n            autos: Vec::with_capacity(capacity)\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_agregar() {\r\n        let mut c = concesionario(1);\r\n\r\n        let auto1 = Auto { marca: \"Nissan\", modelo: \"March 1.6\", ano: 2012, precio: 10.0, color: Color::Negro };\r\n        let auto2 = Auto { marca: \"Nissan2\", modelo: \"March 1.62\", ano: 20122, precio: 10.2, color: Color::Azul };\r\n\r\n        let res_agregar_1 = c.agregar_auto(auto1);\r\n        let res_agregar_2 = c.agregar_auto(auto2);\r\n\r\n        assert!(res_agregar_1.is_ok(), \"No debe causar error: concesionario tiene un auto de capacidad.\");\r\n        assert!(res_agregar_2.is_err(), \"Debe causar error: concesionario tiene sólo un auto de capacidad.\");\r\n\r\n        let res_agregar_1 = res_agregar_1.unwrap();\r\n        let res_agregar_2 = res_agregar_2.unwrap_err();\r\n\r\n        assert_eq!(res_agregar_1, 0, \"No debe quedar espacio para más autos.\");\r\n        assert_eq!(res_agregar_2, ErrorAgregarAuto::ConcesionarioLleno { capacidad: 1 });\r\n    }\r\n\r\n    #[test]\r\n    fn test_eliminar() {\r\n        let mut c = concesionario(1);\r\n\r\n        let auto1 = Auto { marca: \"Nissan\", modelo: \"March 1.6\", ano: 2012, precio: 10.0, color: Color::Negro };\r\n\r\n        let res_agregar_1 = c.agregar_auto(auto1.clone());\r\n\r\n        let res_eliminar_1 = c.eliminar_auto(\"asd\", \"asdasdanoexiste\", 9999);\r\n\r\n        match res_eliminar_1 {\r\n            Ok(_) =\u003e { panic!(\"Debería fallar\") }\r\n            Err(err) =\u003e { assert_eq!(err, ErrorEliminarAuto::AutoInexistente, \"el auto a eliminar no existe\") }\r\n        }\r\n\r\n        let res_eliminar_2 = c.eliminar_auto(auto1.marca, auto1.modelo, auto1.ano);\r\n\r\n        assert!(res_eliminar_2.is_ok(), \"No debería fallar, el auto existe\");\r\n\r\n        let res_eliminar_3 = c.eliminar_auto(auto1.marca, auto1.modelo, auto1.ano);\r\n\r\n        match res_eliminar_3 {\r\n            Ok(_) =\u003e {}\r\n            Err(err) =\u003e { assert_eq!(err, ErrorEliminarAuto::ConcesionarioVacio, \"el concesionario está vacío\") }\r\n        }\r\n    }\r\n\r\n}","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e1","src","structs","mod.rs"],"content":"pub mod concesionario;\r\npub mod auto;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e2","src","main.rs"],"content":"// 2- En base al ejercicio 8 del tp#3 implemente lo siguiente:\n//      a- Realice todos los tests de la funcionalidad implementada obteniendo un coverage de por lo menos 90%\n//      b- Una vez obtenido dicho coverage, las canciones de la playlist deben ser guardadas en un archivo en formato JSON,\n//          por lo tanto las operaciones que agreguen, quiten o modifiquen la playlist deben estar respaldadas sobre dicho archivo.\n//      \n//      No debe modificar los tests hechos en el punto a.\n//      Si puede agregar más en caso de que haga métodos nuevos.\n//      Recuerde también que se debe seguir manteniendo un coverage de al menos 90%,\n\nmod structs;\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e2","src","structs","cancion.rs"],"content":"use serde::Serialize;\r\n\r\n#[derive(Serialize, PartialEq, Clone, Copy, Debug)]\r\npub enum Genero {\r\n    Rock, Pop, Rap, Jazz, Otros\r\n}\r\n\r\n#[derive(Serialize, PartialEq, Clone, Debug)]\r\npub struct Cancion\u003c'a\u003e {\r\n    pub titulo: \u0026'a str,\r\n    pub artista: \u0026'a str,\r\n    pub genero: Genero,\r\n}\r\n\r\nimpl\u003c'a\u003e Cancion\u003c'a\u003e {\r\n    pub fn new(titulo: \u0026'a str, artista: \u0026'a str, genero: Genero) -\u003e Self {\r\n        Self { titulo, artista, genero }\r\n    }\r\n}","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e2","src","structs","mod.rs"],"content":"pub mod cancion;\r\npub mod playlist;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e2","src","structs","playlist.rs"],"content":"use std::fs::File;\r\nuse std::io::Write;\r\nuse error_proc_macro::Error;\r\nuse serde::Serialize;\r\nuse crate::structs::cancion::{Cancion, Genero};\r\n\r\n#[derive(Serialize)]\r\npub struct Playlist\u003c'a\u003e {\r\n    pub nombre: \u0026'a str,\r\n    pub canciones: Vec\u003cCancion\u003c'a\u003e\u003e\r\n}\r\n\r\npub enum ResultAgregarCancion {\r\n    Exito(ResultSobreescribirArchivo),\r\n    PlaylistLlena{ capacity: usize },\r\n}\r\n\r\npub enum ResultMoverCancion {\r\n    Exito(ResultSobreescribirArchivo),\r\n    PosicionFueraDeLimites { limite: usize },\r\n    CancionNoEncontrada\r\n}\r\n\r\npub enum ResultEliminarCancion\u003c'a\u003e {\r\n    Exito{ cancion: Cancion\u003c'a\u003e, resultado_sobreescribir_archivo: ResultSobreescribirArchivo },\r\n    CancionNoExiste,\r\n}\r\n\r\n#[derive(Error)]\r\nenum ResultSobreescribirArchivo {\r\n    Exito,\r\n    CrearArchivo,\r\n    SerializarPlaylist,\r\n    EscribirArchivo\r\n}\r\n\r\nimpl\u003c'a\u003e Playlist\u003c'a\u003e {\r\n    pub fn new(nombre: \u0026'a str) -\u003e Self {\r\n        Self { nombre, canciones: Vec::new() }\r\n    }\r\n\r\n    // ➔ agregar canción.\r\n    pub fn agregar_cancion(\u0026mut self, cancion: Cancion\u003c'a\u003e) -\u003e ResultAgregarCancion {\r\n        if self.canciones.len() == self.canciones.capacity() { return ResultAgregarCancion::PlaylistLlena { capacity: self.canciones.len() } }\r\n        self.canciones.push(cancion);\r\n        ResultAgregarCancion::Exito(self.sobreescribir_archivo())\r\n    }\r\n\r\n    // ➔ eliminar canción.\r\n    pub fn eliminar_cancion(\u0026mut self, titulo: \u0026'a str, artista: \u0026'a str) -\u003e ResultEliminarCancion {\r\n        if let Some(index) = self.canciones.iter().position(|c| c.titulo == titulo \u0026\u0026 c.artista == artista) {\r\n            let cancion = self.canciones.remove(index);\r\n            ResultEliminarCancion::Exito { cancion, resultado_sobreescribir_archivo: self.sobreescribir_archivo() } // no usar swap_remove para mantener orden relativo\r\n        } else {\r\n            ResultEliminarCancion::CancionNoExiste\r\n        }\r\n    }\r\n\r\n    // ➔ mover canción: mueve la canción a una determinada posición de la playlist.\r\n    pub fn mover_cancion(\u0026mut self, titulo: \u0026'a str, artista: \u0026'a str, posicion: usize) -\u003e ResultMoverCancion {\r\n        if posicion \u003e= self.canciones.len() { return ResultMoverCancion::PosicionFueraDeLimites{ limite: self.canciones.len() - 1 } }\r\n\r\n        let index_cancion = if let Some(index) = self.canciones.iter().position(|c| c.titulo == titulo \u0026\u0026 c.artista == artista) {\r\n            index\r\n        } else { return ResultMoverCancion::CancionNoEncontrada };\r\n\r\n        // mover\r\n        let cancion = self.canciones.remove(index_cancion);\r\n        self.canciones.insert(posicion, cancion);\r\n\r\n        ResultMoverCancion::Exito(self.sobreescribir_archivo())\r\n    }\r\n\r\n    // ➔ buscar canción por nombre. (no puede ser solo una :/)\r\n    pub fn buscar_cancion(\u0026self, nombre_cancion: \u0026'a str) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n        let mut canciones_encontradas = Vec::with_capacity(self.canciones.capacity());\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.titulo == nombre_cancion {\r\n                canciones_encontradas.push(cancion);\r\n            }\r\n        }\r\n        canciones_encontradas\r\n    }\r\n\r\n    // ➔ obtener las canciones de un determinado género.\r\n    pub fn listar_canciones_genero(\u0026self, genero: \u0026Genero) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n        let mut vec: Vec\u003c\u0026Cancion\u003e = Vec::new();\r\n\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.genero == *genero {\r\n                vec.push(cancion);\r\n            }\r\n        }\r\n\r\n        vec\r\n    }\r\n\r\n    // ➔ obtener las canciones de un determinado artista.\r\n    pub fn listar_canciones_artista(\u0026self, artista: \u0026str) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n        let mut vec: Vec\u003c\u0026Cancion\u003e = Vec::new();\r\n\r\n        for cancion in \u0026self.canciones {\r\n            if cancion.artista == artista {\r\n                vec.push(cancion);\r\n            }\r\n        }\r\n\r\n        vec\r\n    }\r\n\r\n    // ➔ modificar título de la playlist.\r\n    pub fn modificar_titulo(\u0026mut self, titulo: \u0026'a str) -\u003e ResultSobreescribirArchivo {\r\n        self.nombre = titulo;\r\n        self.sobreescribir_archivo()\r\n    }\r\n\r\n    // ➔ eliminar todas las canciones.\r\n    pub fn clear(\u0026mut self) -\u003e ResultSobreescribirArchivo {\r\n        self.canciones.clear();\r\n        self.sobreescribir_archivo()\r\n    }\r\n\r\n    //      b- Una vez obtenido dicho coverage, las canciones de la playlist deben ser guardadas en un archivo en formato JSON,\r\n    //          por lo tanto las operaciones que agreguen, quiten o modifiquen la playlist deben estar respaldadas sobre dicho archivo.\r\n\r\n    fn sobreescribir_archivo(\u0026self) -\u003e ResultSobreescribirArchivo {\r\n        let mut file = match File::create(format!(\"{}.json\", self.nombre)) {\r\n            Ok(res) =\u003e { res }\r\n            Err(_) =\u003e { return ResultSobreescribirArchivo::CrearArchivo }\r\n        };\r\n\r\n        let json_data = match serde_json::to_string_pretty(self) {\r\n            Ok(res) =\u003e { res }\r\n            Err(_) =\u003e { return ResultSobreescribirArchivo::SerializarPlaylist }\r\n        };\r\n\r\n        match file.write(json_data.as_bytes()) {\r\n            Ok(res) =\u003e { ResultSobreescribirArchivo::Exito },\r\n            Err(_) =\u003e { ResultSobreescribirArchivo::EscribirArchivo }\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::cmp::PartialEq;\r\n    use crate::structs::cancion::{Cancion, Genero};\r\n    use crate::structs::playlist::Playlist;\r\n\r\n    impl\u003c'a\u003e PartialEq\u003cCancion\u003c'a\u003e\u003e for \u0026Cancion\u003c'a\u003e {\r\n        fn eq(\u0026self, cancion: \u0026Cancion) -\u003e bool {\r\n            cancion.titulo == self.titulo\r\n                \u0026\u0026 cancion.artista == self.artista\r\n                \u0026\u0026 cancion.genero == self.genero\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test() {\r\n        let mut mi_playlist = Playlist::new(\"platuka\");\r\n\r\n        let mi_cancion_1 = Cancion::new(\"Un siglo sin tí\", \"Chayanne\", Genero::Pop);\r\n        let mi_cancion_2 = Cancion::new(\"Mi abuela\", \"Molotov\", Genero::Rap);\r\n        let mi_cancion_3 = Cancion::new(\"Te odio y te quiero\", \"Julio Jaramillo\", Genero::Otros);\r\n        let mi_cancion_4 = Cancion::new(\"Fatalidad\", \"Julio Jaramillo\", Genero::Otros);\r\n\r\n        mi_playlist.agregar_cancion(mi_cancion_1.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_2.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_3.clone());\r\n        mi_playlist.agregar_cancion(mi_cancion_4.clone());\r\n\r\n        // test agregado\r\n        assert_eq!(mi_playlist.listar_canciones_genero(\u0026Genero::Otros).len(), 2, \"Deberían haber 2 canciones de género \\\"otros\\\"\");\r\n\r\n        // test mover\r\n        mi_playlist.mover_cancion(mi_cancion_1.titulo, mi_cancion_1.artista, 4);\r\n        assert_eq!(mi_playlist.canciones.get(3).unwrap(), mi_cancion_1, \"La canción no parece haberse movido...\");\r\n\r\n        // test buscar genero\r\n        assert_eq!(mi_playlist.listar_canciones_genero(\u0026Genero::Otros).len(), 2, \"Deberían haber 2 canciones en género Otros\");\r\n\r\n        // test clear\r\n        mi_playlist.clear();\r\n        assert_eq!(mi_playlist.canciones.len(), 0, \"La playlist debería estar vacía\");\r\n    }\r\n\r\n}","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":52},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e3","src","main.rs"],"content":"// 3- En base al ejercicio 9 del tp#3 implemente lo siguiente:\n//  a- Realice todos los tests de la funcionalidad implementada obteniendo un coverage de por lo menos 90%\n//  b- Ahora el registro de atenciones debe persistir en un archivo en formato JSON,\n//      es decir todas la operaciones que lectura, agregar y modificación de atenciones se realizan sobre un archivo.\n//\n//      No debe modificar los tests hechos en el punto a.\n//      Si puede agregar más en caso de que haga métodos nuevos para cumplir con este punto.\n//      Recuerde también que se debe seguir manteniendo un coverage de al menos 90%.\n\nmod structs;\n\nfn main() {\n    println!(\"Hello, world!\");\n    \n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e3","src","structs","atencion.rs"],"content":"use std::fmt;\r\nuse std::fmt::{format, write, Formatter};\r\nuse serde::{Deserialize, Deserializer, Serialize};\r\npub(crate) use crate::structs::fecha::Fecha;\r\n\r\n// Luego de la atención se desea tener un registro de las atenciones realizadas guardando:\r\n// - datos de la mascota\r\n// - el diagnóstico final\r\n// - tratamiento\r\n// - fecha de la próxima visita si es que se requiere.\r\n\r\n#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, Default)]\r\npub struct Atencion {\r\n    pub mascota: Mascota,\r\n    pub diagnostico: String,\r\n    pub tratamiento: String,\r\n    pub proxima_visita: Fecha,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, Default)]\r\npub enum Animal {\r\n    Perro, Gato, Caballo,\r\n    #[default] Otros\r\n}\r\n\r\n// De la mascota se conoce\r\n// - nombre\r\n// - edad\r\n// - tipo de animal (perro, gato, caballo, otros)\r\n// - su dueño.\r\n#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, Default)]\r\npub struct Mascota {\r\n    pub nombre: String,\r\n    pub edad: u16,\r\n    pub animal: Animal,\r\n    pub dueno: Dueno,\r\n}\r\n\r\nimpl fmt::Display for Mascota {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        write!(f, \"({}) {}\", self.edad, self.nombre)\r\n    }\r\n}\r\n\r\n// Del dueño se conoce\r\n// - nombre\r\n// - direccion\r\n// - teléfono de contacto.\r\n#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, Default)]\r\npub struct Dueno {\r\n    pub nombre: String,\r\n    pub direccion: String,\r\n    pub telefono: u64,\r\n}\r\n\r\nimpl Atencion {\r\n    // ➔ modificar el diagnóstico de una determinada atención.\r\n    pub fn modificar_diagnostico_atencion(\u0026mut self, nuevo_diagnostico: String) {\r\n        self.diagnostico = nuevo_diagnostico;\r\n    }\r\n\r\n    // ➔ modificar la fecha de la próxima visita de una determinada atención.\r\n    pub fn modificar_fecha_atencion(\u0026mut self, nueva_fecha: Fecha) {\r\n        self.proxima_visita = nueva_fecha;\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e3","src","structs","fecha.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Serialize, Deserialize, Clone, PartialEq, Debug)]\r\npub struct Fecha {\r\n    pub(crate) dia: u8,\r\n    pub(crate) mes: u8,\r\n    pub(crate) ano: i64\r\n}\r\n\r\nimpl Default for Fecha {\r\n    fn default() -\u003e Self {\r\n        Fecha { dia: 1, mes: 1, ano: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Fecha {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.dia == other.dia\r\n            \u0026\u0026 self.mes == other.mes\r\n            \u0026\u0026 self.ano == other.ano\r\n        { return Some(Equal) }\r\n\r\n        if self.ano \u003e other.ano { return Some(Greater) }\r\n        if self.mes \u003e other.mes { return Some(Greater) }\r\n        if self.dia \u003e other.dia { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cFecha\u003e {\r\n        let fecha = Fecha { dia, mes, ano };\r\n        if fecha.es_fecha_valida() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia == 0\r\n            || self.dia \u003e self.dias_mes_actual()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n\r\n    pub fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n\r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e3","src","structs","mod.rs"],"content":"pub mod veterinaria;\r\npub mod atencion;\r\npub mod fecha;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e3","src","structs","veterinaria.rs"],"content":"use std::collections::VecDeque;\r\nuse std::{fmt, fs, io};\r\nuse std::fmt::Formatter;\r\nuse std::fs::File;\r\nuse std::io::Read;\r\nuse crate::structs::atencion::{Atencion, Mascota};\r\nuse crate::structs::fecha::Fecha;\r\n\r\nconst BASE_FOLDER: \u0026str = \"R:/appcrap/RustRover/SdL-Rust/prac5/_p5e3/res/\";\r\n\r\n// De la veterinaria se conoce\r\n// - nombre\r\n// - la dirección\r\n// - un id.\r\n#[derive(Debug, PartialEq, Clone, Default)]\r\npub struct Veterinaria\u003c'a\u003e {\r\n    pub nombre: \u0026'a str,\r\n    pub direccion: \u0026'a str,\r\n    pub id: u64,\r\n    pub cola: VecDeque\u003cMascota\u003e,\r\n    pub atenciones: Vec\u003cAtencion\u003e\r\n}\r\n\r\n//\r\n// results ArchivoAtenciones\r\n//\r\n\r\n#[derive(Debug)]\r\npub enum ResultArchivoAtenciones {\r\n    Read{ atenciones: Vec\u003cAtencion\u003e },\r\n    Written{ json: String },\r\n    IOError(io::Error),\r\n    SerializeError(serde_json::error::Error),\r\n    DeserializeError(serde_json::error::Error)\r\n}\r\n\r\nimpl\u003c'a\u003e fmt::Display for ResultArchivoAtenciones {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        match self {\r\n            ResultArchivoAtenciones::Read { atenciones } =\u003e {\r\n                write!(f, \"Archivo leído con éxito. Contiene {} atenciones.\", atenciones.len())\r\n            }\r\n            ResultArchivoAtenciones::Written { json } =\u003e {\r\n                write!(f, \"Archivo escrito con éxito. Contenido JSON: {}\", json)\r\n            }\r\n            ResultArchivoAtenciones::IOError(error) =\u003e {\r\n                write!(f, \"Error de E/S: {}\", error)\r\n            }\r\n            ResultArchivoAtenciones::SerializeError(error) =\u003e {\r\n                write!(f, \"Error al serializar: {}\", error)\r\n            }\r\n            ResultArchivoAtenciones::DeserializeError(error) =\u003e {\r\n                write!(f, \"Error al deserializar: {}\", error)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//\r\n// errores veterinaria\r\n//\r\n\r\n#[derive(Debug)]\r\npub enum ErrorNewVeterinaria {\r\n    VecColaCapacidad0,\r\n    VecAtencionesCapacidad0,\r\n    ArchivoAtenciones(ResultArchivoAtenciones)\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ResultAgregarMascota {\r\n    Exito,\r\n    ColaLlena{ capacity: usize },\r\n    ArchivoAtenciones(ResultArchivoAtenciones)\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ResultRemoverMascota\u003c'a\u003e {\r\n    Exito (Mascota),\r\n    ColaVacia { capacity: usize },\r\n    MascotaInexistente { nombre_mascota: \u0026'a str, nombre_dueno: \u0026'a str },\r\n    ArchivoAtenciones(ResultArchivoAtenciones),\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ResultAgregarAtencion {\r\n    Exito,\r\n    VectorLleno { capacity: usize},\r\n    ArchivoAtenciones(ResultArchivoAtenciones)\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum ResultRemoverAtencion\u003c'a\u003e {\r\n    Exito(Atencion),\r\n    VectorVacio { capacity: usize },\r\n    AtencionInexistente { nombre_mascota: \u0026'a str, nombre_dueno: \u0026'a str, diagnostico: \u0026'a str },\r\n    ArchivoAtenciones(ResultArchivoAtenciones)\r\n}\r\n\r\n\r\n//\r\n// impl Veterinaria\r\n//\r\n\r\nimpl\u003c'a\u003e Veterinaria\u003c'a\u003e {\r\n\r\n    // ➔ crear una veterinaria.\r\n    pub fn new(\r\n        nombre: \u0026'a str,\r\n        direccion: \u0026'a str,\r\n        id: u64,\r\n        cola: Option\u003cVecDeque\u003cMascota\u003e\u003e,\r\n        atenciones: Option\u003cVec\u003cAtencion\u003e\u003e\r\n    ) -\u003e Result\u003cSelf, ErrorNewVeterinaria\u003e {\r\n        let cola = if let Some(cola) = cola {\r\n            if cola.capacity() == 0 { return Err(ErrorNewVeterinaria::VecColaCapacidad0) }\r\n            cola\r\n        } else { VecDeque::new() };\r\n\r\n        // si atenciones some(val) -\u003e crear un archivo que contenga val\r\n        // si atenciones none -\u003e intentar abrir el archivo y colocar su información en self.atenciones\r\n\r\n         let atenciones = if let Some(atenciones) = atenciones {\r\n             if atenciones.capacity() == 0 { return Err(ErrorNewVeterinaria::VecAtencionesCapacidad0)  }\r\n             sobreescribir_archivo_atenciones(nombre, \u0026atenciones);\r\n             atenciones\r\n         } else {\r\n             // leer o crear\r\n             match leer_archivo_atenciones(nombre) {\r\n                 ResultArchivoAtenciones::Read { atenciones } =\u003e { atenciones },\r\n                 error =\u003e return Err(ErrorNewVeterinaria::ArchivoAtenciones(error))\r\n             }\r\n         };\r\n\r\n        Ok(\r\n            Self { nombre, direccion, id, cola, atenciones }\r\n        )\r\n    }\r\n\r\n    // ➔ agregar una nueva mascota a la cola de atención de la veterinaria.\r\n    pub fn agregar_mascota(\u0026mut self, mascota: Mascota) -\u003e ResultAgregarMascota {\r\n        if self.cola.len() == self.cola.capacity() { return ResultAgregarMascota::ColaLlena { capacity: self.cola.capacity() } }\r\n        self.cola.push_back(mascota);\r\n        ResultAgregarMascota::Exito\r\n    }\r\n\r\n    // ➔ agregar una nueva mascota a la cola de atención pero que sea la siguiente en atender porque tiene la máxima prioridad.\r\n    pub fn agregar_mascota_prioridad(\u0026mut self, mascota: Mascota) -\u003e ResultAgregarMascota {\r\n        if self.cola.len() == self.cola.capacity() { return ResultAgregarMascota::ColaLlena { capacity: self.cola.capacity() } }\r\n        self.cola.push_front(mascota);\r\n        match sobreescribir_archivo_atenciones(self.nombre, \u0026self.atenciones) {\r\n            ResultArchivoAtenciones::Written { json: _ } =\u003e ResultAgregarMascota::Exito,\r\n            x =\u003e ResultAgregarMascota::ArchivoAtenciones(x)\r\n        }\r\n    }\r\n\r\n    // ➔ atender la próxima mascota de la cola.\r\n    pub fn atender_proxima_mascota(\u0026mut self) -\u003e ResultRemoverMascota {\r\n        if let Some(mascota) = self.cola.pop_front() { ResultRemoverMascota::Exito(mascota) }\r\n        else { ResultRemoverMascota::ColaVacia { capacity: self.cola.capacity() } }\r\n    }\r\n\r\n    // ➔ eliminar una mascota específica de la cola de atención dado que se retira.\r\n    pub fn eliminar_mascota(\u0026mut self, nombre_mascota: \u0026'a str, nombre_dueno: \u0026'a str) -\u003e ResultRemoverMascota {\r\n        let index = if let Some(index) = self.cola.iter().position(|m| m.nombre == nombre_mascota \u0026\u0026 m.dueno.nombre == nombre_dueno ) { index }\r\n        else { return ResultRemoverMascota::MascotaInexistente { nombre_mascota, nombre_dueno } };\r\n\r\n        if let Some(mascota) = self.cola.remove(index) {\r\n            ResultRemoverMascota::Exito(mascota)\r\n        } else {\r\n            ResultRemoverMascota::MascotaInexistente { nombre_mascota, nombre_dueno }\r\n        }\r\n    }\r\n\r\n    // ➔ registrar una atención.\r\n    pub fn registrar_atencion(\u0026mut self, atencion: Atencion) -\u003e ResultAgregarAtencion {\r\n        if self.atenciones.len() == self.atenciones.capacity() { return ResultAgregarAtencion::VectorLleno{ capacity: self.atenciones.capacity() } }\r\n        self.atenciones.push(atencion);\r\n\r\n        match sobreescribir_archivo_atenciones(\u0026self.nombre, \u0026self.atenciones) {\r\n            ResultArchivoAtenciones::Written { .. } =\u003e { ResultAgregarAtencion::Exito },\r\n            x =\u003e ResultAgregarAtencion::ArchivoAtenciones(x)\r\n        }\r\n    }\r\n\r\n    /// Searches for an Atencion by Mascota's name and Dueno's details.\r\n    ///\r\n    /// # Arguments\r\n    /// * `mascota_nombre` - The name of the Mascota.\r\n    /// * `dueno_nombre` - The name of the Dueno.\r\n    /// * `telefono` - The Dueno's phone number.\r\n    ///\r\n    /// # Returns\r\n    /// * `Some(\u0026Atencion)` - If an Atencion is found.\r\n    /// * `None` - If no match is found.\r\n    pub fn buscar_atencion(\u0026self, mascota_nombre: String, dueno_nombre: String, telefono: u64, ) -\u003e Option\u003c\u0026Atencion\u003e {\r\n        self.atenciones.iter().find(|atencion| {\r\n            atencion.mascota.nombre == mascota_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.nombre == dueno_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.telefono == telefono\r\n        })\r\n    }\r\n\r\n    // pub fn buscar_atencion_mut(\u0026mut self, mascota_nombre: String, dueno_nombre: String, telefono: u64, ) -\u003e Option\u003c\u0026mut Atencion\u003e {\r\n    //     self.atenciones.iter_mut().find(|atencion| {\r\n    //         atencion.mascota.nombre == mascota_nombre\r\n    //             \u0026\u0026 atencion.mascota.dueno.nombre == dueno_nombre\r\n    //             \u0026\u0026 atencion.mascota.dueno.telefono == telefono\r\n    //     }) // cómo hago para editar el archivo cuando se haya actualizado un \u0026mut Atencion?\r\n    //         // cómo hago para saber cuándo se edita con un préstamo mutable de un elemento?\r\n    //          // cómo hago para saber cuándo finaliza el préstamo mutable?\r\n    // }\r\n\r\n    pub fn buscar_atencion_mut(\u0026mut self, mascota_nombre: String, dueno_nombre: String, telefono: u64) -\u003e Option\u003c\u0026 mut Atencion\u003e {\r\n        self.atenciones.iter_mut().find(|atencion|\r\n            atencion.mascota.nombre == mascota_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.nombre == dueno_nombre\r\n                \u0026\u0026 atencion.mascota.dueno.telefono == telefono)\r\n    }\r\n\r\n    /// Deletes an Atencion record from the Veterinaria records\r\n    ///\r\n    /// # Arguments\r\n    /// * `atencion` - A reference to the Atencion to delete\r\n    ///\r\n    /// # Returns\r\n    /// `Some(Atencion)` - The deleted Atencion\r\n    /// `None` - If no match is found\r\n    ///\r\n    /// # Notes\r\n    /// Requires `PartialEq` on Atencion for comparison\r\n    pub fn eliminar_atencion (\u0026mut self, nombre_mascota: \u0026'a str, nombre_dueno: \u0026'a str, diagnostico: \u0026'a str) -\u003e ResultRemoverAtencion {\r\n        if self.atenciones.len() == 0 {\r\n            return ResultRemoverAtencion::VectorVacio { capacity: self.atenciones.capacity() }\r\n        }\r\n\r\n        if let Some(index) = self.atenciones.iter().position( |a|\r\n                a.mascota.nombre == nombre_mascota\r\n             \u0026\u0026 a.mascota.dueno.nombre == nombre_dueno\r\n             \u0026\u0026 a.diagnostico == diagnostico) {\r\n\r\n            ResultRemoverAtencion::Exito(self.atenciones.remove(index))\r\n        } else {\r\n            ResultRemoverAtencion::AtencionInexistente { nombre_mascota, nombre_dueno, diagnostico }\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n//  atenciones file\r\n//\r\n\r\nfn archivo_atenciones_filepath(nombre_vet: \u0026str) -\u003e String {\r\n    format!(\"{}veterinaria_{}_atenciones.json\", BASE_FOLDER, nombre_vet)\r\n}\r\n\r\n//\r\n\r\nfn sobreescribir_archivo_atenciones(nombre_vet: \u0026str, atenciones: \u0026Vec\u003cAtencion\u003e) -\u003e ResultArchivoAtenciones {\r\n    // crear y/o escribir\r\n    // presupongo que la imposibilidad de persistir como archivo es un error semi-catastrófico\r\n    // semi-catastrófico == no runtime panic, pero se aborta la creación de la veterinaria\r\n    let json_data = match serde_json::to_string_pretty(atenciones) {\r\n        Ok(data) =\u003e { data }\r\n        Err(error) =\u003e { return ResultArchivoAtenciones::SerializeError(error) }\r\n    };\r\n\r\n    // escribir\r\n    match fs::write(archivo_atenciones_filepath(nombre_vet), json_data.clone()) {\r\n        Ok(_) =\u003e {  },\r\n        Err(error) =\u003e {\r\n            return ResultArchivoAtenciones::IOError(error)\r\n        }\r\n    };\r\n\r\n    // éxito\r\n    ResultArchivoAtenciones::Written { json: json_data }\r\n}\r\n\r\n//\r\n\r\nfn leer_archivo_atenciones(nombre_vet: \u0026str) -\u003e ResultArchivoAtenciones {\r\n    // leer\r\n    let mut file = match File::open(archivo_atenciones_filepath(nombre_vet)) {\r\n        Ok(file) =\u003e { file }\r\n        Err(error) =\u003e { return ResultArchivoAtenciones::IOError(error) }\r\n    };\r\n\r\n    let mut contents = String::new();\r\n    match file.read_to_string(\u0026mut contents) {\r\n        Ok(_) =\u003e {},\r\n        Err(error) =\u003e return ResultArchivoAtenciones::IOError(error)\r\n    };\r\n\r\n    let json_value: serde_json::Value = match serde_json::from_str(\u0026contents) {\r\n        Ok(value) =\u003e value,\r\n        Err(error) =\u003e return ResultArchivoAtenciones::DeserializeError(error),\r\n    };\r\n\r\n    let atenciones: Vec\u003cAtencion\u003e = match serde_json::from_value(json_value) {\r\n        Ok(atenciones) =\u003e atenciones,\r\n        Err(error) =\u003e return ResultArchivoAtenciones::DeserializeError(error),\r\n    };\r\n\r\n    ResultArchivoAtenciones::Read { atenciones }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::collections::VecDeque;\r\n    use crate::structs::atencion::{Animal, Dueno, Fecha};\r\n    use super::*;\r\n\r\n    fn veterinaria_de_pepe\u003c'a\u003e(capacidad: usize) -\u003e Veterinaria\u003c'a\u003e {\r\n        // Crear dueños\r\n        let dueno1 = Dueno {\r\n            nombre: \"Juan Pérez\".to_string(),\r\n            direccion: \"Calle 123\".to_string(),\r\n            telefono: 1234567890,\r\n        };\r\n        let dueno2 = Dueno {\r\n            nombre: \"María Gómez\".to_string(),\r\n            direccion: \"Avenida 456\".to_string(),\r\n            telefono: 9876543210,\r\n        };\r\n        let dueno3 = Dueno {\r\n            nombre: \"Carlos López\".to_string(),\r\n            direccion: \"Carrera 789\".to_string(),\r\n            telefono: 5555555555,\r\n        };\r\n\r\n        // Crear mascotas para la cola\r\n        let mascota1 = Mascota {\r\n            nombre: \"Max\".to_string(),\r\n            edad: 3,\r\n            animal: Animal::Perro,\r\n            dueno: dueno1,\r\n        };\r\n        let mascota2 = Mascota {\r\n            nombre: \"Luna\".to_string(),\r\n            edad: 2,\r\n            animal: Animal::Gato,\r\n            dueno: dueno2,\r\n        };\r\n        let mascota3 = Mascota {\r\n            nombre: \"Tormenta\".to_string(),\r\n            edad: 5,\r\n            animal: Animal::Caballo,\r\n            dueno: dueno3,\r\n        };\r\n\r\n        // Crear fechas para atenciones\r\n        let fecha1 = Fecha { dia: 15, mes: 10, ano: 2023 };\r\n        let fecha2 = Fecha { dia: 20, mes: 10, ano: 2023 };\r\n        let fecha3 = Fecha { dia: 25, mes: 10, ano: 2023 };\r\n\r\n        // Crear atenciones\r\n        let atencion1 = Atencion {\r\n            mascota: mascota1.clone(),\r\n            diagnostico: \"Resfriado leve\".to_string(),\r\n            tratamiento: \"Antibióticos\".to_string(),\r\n            proxima_visita: fecha1,\r\n        };\r\n        let atencion2 = Atencion {\r\n            mascota: mascota2.clone(),\r\n            diagnostico: \"Infección ocular\".to_string(),\r\n            tratamiento: \"Gotas\".to_string(),\r\n            proxima_visita: fecha2,\r\n        };\r\n        let atencion3 = Atencion {\r\n            mascota: mascota3.clone(),\r\n            diagnostico: \"Cojeo\".to_string(),\r\n            tratamiento: \"Reposo\".to_string(),\r\n            proxima_visita: fecha3,\r\n        };\r\n\r\n        let mut vec_cola: VecDeque\u003cMascota\u003e = VecDeque::with_capacity(capacidad);\r\n        vec_cola.push_back(mascota1);\r\n        vec_cola.push_back(mascota2);\r\n        vec_cola.push_back(mascota3);\r\n\r\n        // Crear la veterinaria con cola y atenciones\r\n        match Veterinaria::new (\r\n            \"Pepe's Pet Shop\",\r\n            \"Calle Principal 100\",\r\n             1,\r\n            Some(vec_cola),\r\n            Some(vec![atencion1, atencion2, atencion3]),\r\n        ) {\r\n            Ok(vet) =\u003e { vet }\r\n            Err(err) =\u003e { panic!(\"error: {:?}\", err) }\r\n        }\r\n    }\r\n\r\n    /*\r\n        let dueno1 = Dueno {\r\n            nombre: String::from(\"Juan Pérez\"),\r\n            direccion: String::from(\"Calle 123\"),\r\n            telefono: 1234567890,\r\n        };\r\n\r\n        let mascota1 = Mascota {\r\n            nombre: String::from(\"Max\"),\r\n            edad: 3,\r\n            animal: Animal::Perro,\r\n            dueno: dueno1,\r\n        };\r\n\r\n        let fecha1 = Fecha { dia: 15, mes: 10, ano: 2023 };\r\n\r\n        let atencion1 = Atencion {\r\n            mascota: mascota1.clone(),\r\n            diagnostico: String::from(\"Resfriado leve\"),\r\n            tratamiento: String::from(\"Antibióticos\"),\r\n            proxima_visita: fecha1,\r\n        };\r\n\r\n        Veterinaria {\r\n            nombre: String::from(\"Pepe's Pet Shop\"),\r\n            direccion: String::from(\"Calle Principal 100\"),\r\n            id: 1,\r\n            cola: VecDeque::from([mascota1, mascota2, mascota3]),\r\n            atenciones: vec![atencion1, atencion2, atencion3],\r\n        }\r\n     */\r\n\r\n    #[test]\r\n    fn test_atencion() {\r\n        let mut veterinaria = veterinaria_de_pepe(10);\r\n\r\n        // Verificar visualmente el contenido\r\n        println!(\"Veterinaria: {}\", veterinaria.nombre);\r\n        println!(\"Cola: {:?}\", veterinaria.cola);\r\n        println!(\"Atenciones: {:?}\", veterinaria.atenciones);\r\n\r\n        // Buscar\r\n\r\n        let atencion = veterinaria.buscar_atencion_mut(\"Max\".to_string(), \"Juan Pérez\".to_string(), 1234567890);\r\n        assert!(atencion.is_some(), \"La atención no puede no existir\");\r\n        let atencion = atencion.unwrap();\r\n\r\n        atencion.modificar_diagnostico_atencion(\"jijodebu en los jijolines jijox\".to_string());\r\n\r\n        println!(\"Atenciones: {:?}\", veterinaria.atenciones);\r\n    }\r\n\r\n    #[test]\r\n    fn test_agregar_eliminar() {\r\n        let mut veterinaria = veterinaria_de_pepe(10);\r\n\r\n        let dueno1 = Dueno {\r\n            nombre: \"Enrique Ibañez\".to_string(),\r\n            direccion: \"Calle 437\".to_string(),\r\n            telefono: 1234567890,\r\n        };\r\n\r\n        let mascota1 = Mascota {\r\n            nombre: \"Rodolfoasdasda\".to_string(),\r\n            edad: 72,\r\n            animal: Animal::Caballo,\r\n            dueno: dueno1,\r\n        };\r\n\r\n        match veterinaria.agregar_mascota(mascota1.clone()) {\r\n            ResultAgregarMascota::Exito =\u003e {},\r\n            ResultAgregarMascota::ColaLlena { capacity } =\u003e { panic!(\"No deberia estar llena. Capacidad: {}\", capacity) },\r\n            ResultAgregarMascota::ArchivoAtenciones(aa) =\u003e { panic!(\"e? {:?}\", aa) }\r\n        }\r\n\r\n        println!(\"{:?}\", veterinaria.cola);\r\n        assert_eq!(veterinaria.cola.len(), 4, \"Deberían haber 4 mascotas en total.\");\r\n\r\n        veterinaria.agregar_mascota_prioridad(mascota1.clone());\r\n        let prox_mascota = veterinaria.atender_proxima_mascota();\r\n\r\n        let mascota = match prox_mascota {\r\n            ResultRemoverMascota::Exito(mascota) =\u003e { mascota },\r\n            _ =\u003e panic!(\"deberia existir\")\r\n        };\r\n\r\n        assert_eq!(mascota, mascota1, \"La primer mascota en la fila debería ser la misma mascota que se agregó con prioridad\");\r\n\r\n        println!(\"{:?}\", veterinaria.eliminar_mascota(mascota1.nombre.as_str(), mascota1.dueno.nombre.as_str()));\r\n\r\n        assert_eq!(veterinaria.cola.len(), 3, \"La lista de mascotas debería haber vuelto a su estado original (3 items).\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_json() {\r\n        veterinaria_de_pepe(10); // creará el .json\r\n\r\n        match Veterinaria::new( // cargará el .json\r\n            \"Pepe's Pet Shop\",\r\n            \"asd\",\r\n            1,\r\n            None,\r\n            None\r\n        ) {\r\n            Ok(vet) =\u003e {\r\n                assert_eq!(vet.atenciones.len(), 3, \"deberían ser 3 según el archivo\");\r\n\r\n                for atencion in vet.atenciones {\r\n                    println!(\"{} ({}): {}\", atencion.mascota.nombre, atencion.mascota.edad, atencion.diagnostico)\r\n                }\r\n            }\r\n            Err(err) =\u003e { panic!(\"error new veterinaria: {:?}\", err) }\r\n        }\r\n    }\r\n}","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":66},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","main.rs"],"content":"// 4- En base al ejercicio 10 del tp#3 implemente lo siguiente:\n//  a- Realice todos los tests de la funcionalidad implementada obteniendo un coverage de por lo menos 90%\n//  b- Tanto los libros con sus copias como la administración de préstamos se realizan sobre archivos en formato JSON.\n//\n//      Realice las modificaciones pertinentes para poder hacerlo así.\n//      No debe modificar los tests hechos en el punto a.\n//      Si puede agregar más en caso de que haga métodos nuevos para cumplir con este punto.\n//      Recuerde también que se debe seguir manteniendo un coverage de al menos 90%.\n\nmod structs;\n\nfn main() {\n    \n\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","biblioteca.rs"],"content":"use std::collections::BTreeMap;\r\nuse crate::structs::cliente::Cliente;\r\nuse crate::structs::fecha::Fecha;\r\nuse crate::structs::prestamo::{EstadoPrestamo, Prestamo};\r\nuse super::libro::Libro;\r\n\r\n/// # Biblioteca\r\n///\r\n/// `nombre: String` - Nombre de la biblioteca\u003cbr\u003e\r\n/// `direccion: String` - Dirección física de la biblioteca\u003cbr\u003e\r\n/// `libros: BTreeMap\u003cu64, Libro\u003e` - Libros de la biblioteca\u003cbr\u003e\r\n/// `prestamos: BTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e` - \u003cb\u003e BTreeMap\u003cID del cliente, (Cliente, Vec\u003cPrestamo\u003e)\u003e\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Biblioteca {\r\n    pub nombre: String,\r\n    pub direccion: String,\r\n    pub libros: BTreeMap\u003cu64, Libro\u003e,\r\n    pub prestamos: BTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e // \u003cID cliente, (Cliente, Vec\u003cPréstamo\u003e)\u003e\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorDecrementarStock {\r\n    StockEsCero, LibroNoExiste\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorIncrementarStock {\r\n    LibroNoExiste, Overflow\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorRealizarPrestamo {\r\n    PrestamosMaximosAlcanzados, StockInsuficiente, LibroNoExiste\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorBuscarPrestamo {\r\n    PrestamoInexistente, ClienteInexistente\r\n}\r\n\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\nenum ErrorDevolverLibro {\r\n    PrestamoInexistente, ClienteInexistente, LibroYaDevuelto\r\n}\r\n\r\nimpl Biblioteca {\r\n\r\n    /// ### fn new() -\u003e Biblioteca\r\n    /// Crea una nueva instancia de biblioteca\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `nombre` - Nombre de la biblioteca\u003cbr\u003e\r\n    /// `direccion` - Dirección de la biblioteca\u003cbr\u003e\r\n    /// `libros` - Opcional: Lista de libros de la biblioteca\u003cbr\u003e\r\n    /// `prestamos` - Opcional: Lista de préstamos de la biblioteca\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\r\n    /// `Biblioteca` - Nueva instancia de Biblioteca\r\n    fn new(nombre: String, direccion: String, libros: Option\u003cBTreeMap\u003cu64, Libro\u003e\u003e, prestamos: Option\u003cBTreeMap\u003cu32, (Cliente, Vec\u003cPrestamo\u003e)\u003e\u003e) -\u003e Biblioteca {\r\n        Biblioteca {\r\n            nombre,\r\n            direccion,\r\n            libros: libros.unwrap_or_default(),\r\n            prestamos: prestamos.unwrap_or_default()\r\n        }\r\n    }\r\n\r\n    /// ### fn cantidad_de_copias_en_stock(isbn) -\u003e Option\u003cu32\u003e\r\n    /// Devuelve la cantidad de copias disponibles de un libro\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(u32)` - Cantidad (u32) de libros en stock\u003cbr\u003e\r\n    /// `None` - No existe el libro consultado\r\n    fn cantidad_de_copias_en_stock(\u0026self, isbn: u64) -\u003e Option\u003cu32\u003e {\r\n        self.libros.get(\u0026isbn).map(|libro| libro.stock)\r\n    }\r\n\r\n    /// ### fn decrementar_stock_libro(isbn) -\u003e Result\u003cu32, ErrorDecrementarStock\u003e\r\n    /// Devuelve la cantidad de libros en stock después de decrementarla en 1\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `u32` - Cantidad de libros después de decrementar\u003cbr\u003e\r\n    /// `ErrorDecrementarStock` - El stock es cero o el libro no existe\r\n    fn decrementar_stock_libro(\u0026mut self, isbn: u64) -\u003e Result\u003cu32, ErrorDecrementarStock\u003e {\r\n        match self.libros.get_mut(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == 0 {\r\n                    Err(ErrorDecrementarStock::StockEsCero)\r\n                } else {\r\n                    libro.stock-= 1;\r\n                    Ok(libro.stock)\r\n                }\r\n            },\r\n            None =\u003e Err(ErrorDecrementarStock::LibroNoExiste)\r\n        }\r\n    }\r\n\r\n\r\n    /// ### fn incrementar_stock_libro(isbn) -\u003e Result\u003cu32, ErrorIncrementarStock\u003e\r\n    /// Devuelve la cantidad de libros en stock después de incrementarla en 1\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `u32` - Cantidad de libros después de decrementar\u003cbr\u003e\r\n    /// `ErrorIncrementarStock` - El stock es `u32::MAX` o el libro no existe\r\n    fn incrementar_stock_libro(\u0026mut self, isbn: u64) -\u003e Result\u003cu32, ErrorIncrementarStock\u003e {\r\n        match self.libros.get_mut(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == u32::MAX {\r\n                    Err(ErrorIncrementarStock::Overflow)\r\n                } else {\r\n                    libro.stock+= 1;\r\n                    Ok(libro.stock)\r\n                }\r\n            },\r\n            None =\u003e Err(ErrorIncrementarStock::LibroNoExiste)\r\n        }\r\n    }\r\n\r\n    /// ### fn cantidad_prestamos_cliente(cliente) -\u003e Option\u003cusize\u003e\r\n    /// Devuelve la cantidad de préstamos efectuados a un cliente\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `cliente` - ID del cliente a consultar\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(usize)` - Cantidad de préstamos efectuados al cliente\u003cbr\u003e\r\n    /// `None` - El cliente no existe\r\n    fn cantidad_prestamos_cliente(\u0026self, cliente: u32) -\u003e Option\u003cusize\u003e {\r\n        // match self.prestamos.get(cliente) {\r\n        //     Some(cliente) =\u003e {\r\n        //         Some(cliente.len())\r\n        //     },\r\n        //     None =\u003e None\r\n        // }\r\n\r\n        self.prestamos.get(\u0026cliente).map(|cliente| cliente.1.len()) // compiler suggestion\r\n    }\r\n\r\n    /// ### fn cantidad_stock_libro(isbn) -\u003e Option\u003cu32\u003e\r\n    /// Devuelve la cantidad de libros en stock del libro consultado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a consultar\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Some(u32)` - Cantidad de libros en stock\u003cbr\u003e\r\n    /// `None` - El libro no existe\r\n    fn cantidad_stock_libro(\u0026self, isbn: u64) -\u003e Option\u003cu32\u003e {\r\n        self.libros.get(\u0026isbn).map(|libro| libro.stock) // compiler suggestion\r\n    }\r\n\r\n    /// ### fn realizar_prestamo(cliente, isbn, vencimiento) -\u003e Result(usize, ErrorRealizarPrestamo)\r\n    /// Realiza un préstamo del libro en nombre del cliente con el vencimiento especificado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `cliente` - Cliente a efectuar el préstamo\u003cbr\u003e\r\n    /// `isbn` - ID del libro a prestar\u003cbr\u003e\r\n    /// `vencimiento` - Fecha de vencimiento del préstamo\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `usize` - Cantidad de préstamos del cliente, incluyendo el recién realizado\r\n    fn realizar_prestamo(\u0026mut self, cliente: Cliente, isbn: u64, vencimiento: Fecha) -\u003e Result\u003cusize, ErrorRealizarPrestamo\u003e /* \u003cCant. préstamos del cliente, Error\u003e */ {\r\n        match self.libros.get(\u0026isbn) {\r\n            Some(libro) =\u003e {\r\n                if libro.stock == 0 {\r\n                    return Err(ErrorRealizarPrestamo::StockInsuficiente)\r\n                }\r\n            },\r\n            None =\u003e return Err(ErrorRealizarPrestamo::LibroNoExiste)\r\n        }\r\n\r\n        let prestamo = Prestamo::new(isbn, cliente.id, vencimiento, None, EstadoPrestamo::Prestando);\r\n\r\n        match self.prestamos.get_mut(\u0026cliente.id) {\r\n            Some(dato) =\u003e {\r\n                let cant_libros_no_devueltos = dato.1.iter().filter(|p| p.devolucion.is_none() \u0026\u0026 p.estado == EstadoPrestamo::Prestando).count();\r\n                if cant_libros_no_devueltos \u003e= 5 {\r\n                    return Err(ErrorRealizarPrestamo::PrestamosMaximosAlcanzados);\r\n                }\r\n\r\n                // si el préstamo alguna vez se realizó, eliminar el antiguo préstamo\r\n                dato.1.retain(|p| p.isbn != isbn);\r\n\r\n                // quitar stock al libro a prestar\r\n                // no puedo usar self.decrementar_stock_libro() porque tendría 2 borrows mutables en simultáneo\r\n                if let Some(libro) = self.libros.get_mut(\u0026isbn) { libro.stock-= 1 } // compiler suggestion\r\n\r\n                dato.1.push(prestamo);\r\n                Ok(cant_libros_no_devueltos)\r\n            },\r\n            None =\u003e {\r\n                // insertar cliente\r\n                self.prestamos.insert(cliente.id, (cliente, vec![prestamo]));\r\n                self.decrementar_stock_libro(isbn);\r\n                Ok(1)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// ### fn prestamos_a_vencer(feca_hoy, dias) -\u003e Vec\u003c\u0026Prestamo\u003e\r\n    /// Devuelve un Vec\u003c\u0026Prestamo\u003e con los préstamos a vencer en los próximos `dias` días\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `fecha_hoy` - Fecha del día de hoy\u003cbr\u003e\r\n    /// `dias` - Días en los que vencerán los préstamos devueltos\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Vec\u003c\u0026Prestamo\u003e` - Los préstamos que vencerán en los próximos `dias` días\r\n    fn prestamos_por_vencer(\u0026self, fecha_hoy: Fecha, dias: u32) -\u003e Vec\u003c\u0026Prestamo\u003e {\r\n        let mut prestamos_por_vencer: Vec\u003c\u0026Prestamo\u003e = Vec::new();\r\n\r\n        let mut fecha_limte = fecha_hoy;\r\n        fecha_limte.sumar_dias(dias);\r\n        let fecha_limite = fecha_limte; // quitar mutabilidad\r\n\r\n        for prestamos_cliente in self.prestamos.values() {\r\n            for prestamo in \u0026prestamos_cliente.1 {\r\n\r\n                match \u0026prestamo.devolucion {\r\n                    Some(_) =\u003e continue, // ya fue devuelto, no contabilizar\r\n                    None =\u003e {\r\n                        if prestamo.devolucion.is_none() \u0026\u0026 prestamo.estado == EstadoPrestamo::Prestando \u0026\u0026 prestamo.vencimiento \u003c= fecha_limite {\r\n                            prestamos_por_vencer.push(prestamo);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        prestamos_por_vencer\r\n    }\r\n\r\n    /// ### fn prestamos_vencidos(fecha_hoy) -\u003e Vec\u003c\u0026Prestamo\u003e\r\n    /// Devuelve los prestamos que hayan vencido\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `fecha_hoy` - La fecha de hoy\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `Vec\u003c\u0026Prestamo\u003e` - Los préstamos que han vencido\r\n    fn prestamos_vencidos(\u0026self, fecha_hoy: Fecha) -\u003e Vec\u003c\u0026Prestamo\u003e {\r\n        let mut prestamos_vencidos: Vec\u003c\u0026Prestamo\u003e = Vec::new();\r\n\r\n        for prestamos_cliente in self.prestamos.values() {\r\n            for prestamo in \u0026prestamos_cliente.1 {\r\n                if prestamo.estado == EstadoPrestamo::Prestando \u0026\u0026 prestamo.vencimiento \u003c fecha_hoy {\r\n                    prestamos_vencidos.push(prestamo);\r\n                }\r\n            }\r\n        }\r\n\r\n        prestamos_vencidos\r\n    }\r\n\r\n    /// ### fn buscar_prestamo(isbn, id_cliente) -\u003e Result\u003c\u0026Prestamo, ErrorBuscarPrestamo\u003e\r\n    /// Devuelve un préstamo en específico\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro prestado\u003cbr\u003e\r\n    /// `id_cliente` - ID del cliente del préstamo\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `\u0026Prestamo` - El préstamo buscado\u003cbr\u003e\r\n    /// `ErrorBuscarPrestamo` - El préstamo o el cliente no existen\r\n    fn buscar_prestamo(\u0026self, isbn: u64, id_cliente: u32) -\u003e Result\u003c\u0026Prestamo, ErrorBuscarPrestamo\u003e {\r\n        match self.prestamos.get(\u0026id_cliente) {\r\n            Some(dato) =\u003e {\r\n                for prestamo in \u0026dato.1 {\r\n                    if prestamo.isbn == isbn { return Ok(prestamo) }\r\n                }\r\n                    Err(ErrorBuscarPrestamo::PrestamoInexistente)\r\n            },\r\n            None =\u003e Err(ErrorBuscarPrestamo::ClienteInexistente)\r\n        }\r\n    }\r\n\r\n    /// ### fn devolver_libro(isbn, id_cliente, fecha_hoy) -\u003e Result\u003c\u0026Prestamo, ErrorDevolverLibro\u003e\r\n    /// Realiza la devolución del libro especificado\r\n    ///\r\n    /// #### Recibe:\u003cbr\u003e\r\n    /// `isbn` - ID del libro a devolver\u003cbr\u003e\r\n    /// `id_cliente` - ID del cliente que devuelve\u003cbr\u003e\r\n    /// `fecha_hoy` - La fecha de hoy\u003cbr\u003e\r\n    ///\r\n    /// #### Devuelve:\u003cbr\u003e\r\n    /// `\u0026Prestamo` - El préstamo del libro que se ha devuelto\u003cbr\u003e\r\n    /// `ErrorDevolverLibro` - El cliente o el préstamo no existen o ya fue devuelto\r\n    fn devolver_libro(\u0026mut self, isbn: u64, id_cliente: u32, fecha_hoy: Fecha) -\u003e Result\u003c\u0026Prestamo, ErrorDevolverLibro\u003e {\r\n        match self.prestamos.get_mut(\u0026id_cliente) {\r\n            Some(dato) =\u003e {\r\n                for prestamo in dato.1.iter_mut() {\r\n                    if prestamo.isbn == isbn {\r\n                        if prestamo.estado == EstadoPrestamo::Devuelto {\r\n                            return Err(ErrorDevolverLibro::LibroYaDevuelto)\r\n                        }\r\n\r\n                        prestamo.devolucion = Some(fecha_hoy);\r\n                        prestamo.estado = EstadoPrestamo::Devuelto;\r\n\r\n                        // no puedo usar self.incrementar_stock_libro() porque tendría 2 borrows mutables en simultáneo\r\n                        if let Some(libro) = self.libros.get_mut(\u0026isbn) { libro.stock-= 1 }\r\n\r\n                        return Ok(prestamo)\r\n                    }\r\n                }\r\n                Err(ErrorDevolverLibro::PrestamoInexistente)\r\n            },\r\n            None =\u003e Err(ErrorDevolverLibro::ClienteInexistente)\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::collections::BTreeMap;\r\n    use crate::structs::biblioteca::{Biblioteca, ErrorDecrementarStock, ErrorIncrementarStock, ErrorRealizarPrestamo};\r\n    use crate::structs::cliente::Cliente;\r\n    use crate::structs::fecha::Fecha;\r\n    use crate::structs::libro::{Genero, Libro};\r\n    use crate::structs::prestamo::EstadoPrestamo;\r\n\r\n    fn biblioteca_de_pepe() -\u003e Biblioteca {\r\n        Biblioteca::new(\r\n            \"biblio de pepe\".to_string(),\r\n            \"donde queda\".to_string(),\r\n            Some(BTreeMap::from(\r\n                [(1, libro_economia_1()),\r\n                    (2, libro_xd_2()),\r\n                    (3, libro_harrypotter_3()),\r\n                    (4, libro_asd_4()),\r\n                    (5, libro_estadistica_5()),\r\n                    (u32::MAX as u64, libro_algo_u32max())])),\r\n            None)\r\n    }\r\n    fn cliente_pepe() -\u003e Cliente {\r\n        Cliente::new(\r\n            1,\r\n            \"pepe\".to_string(),\r\n            \"123\".to_string(),\r\n            \"pepe@gmail.com\".to_string()\r\n        )\r\n    }\r\n    fn cliente_manuel() -\u003e Cliente {\r\n        Cliente::new(\r\n            3,\r\n            \"manuel\".to_string(),\r\n            \"123\".to_string(),\r\n            \"manuel@gmail.com\".to_string()\r\n        )\r\n    }\r\n    fn libro_economia_1() -\u003e Libro {\r\n        Libro::new(\r\n            1,\r\n            \"Economía en una lección\".to_string(),\r\n            \"xd\".to_string(),\r\n            1,\r\n            Genero::Tecnico,\r\n            1\r\n        )\r\n    }\r\n    fn libro_xd_2() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 2;\r\n        libro.titulo = \"xd\".to_string();\r\n        libro.stock = 2;\r\n        libro\r\n    }\r\n    fn libro_harrypotter_3() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 3;\r\n        libro.titulo = \"Harry Potter y qsy q mas\".to_string();\r\n        libro.stock = 3;\r\n        libro\r\n    }\r\n    fn libro_asd_4() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 4;\r\n        libro.titulo = \"asd\".to_string();\r\n        libro.stock = 4;\r\n        libro\r\n    }\r\n    fn libro_estadistica_5() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = 5;\r\n        libro.titulo = \"Estadística\".to_string();\r\n        libro.stock = 5;\r\n        libro\r\n    }\r\n    fn libro_algo_u32max() -\u003e Libro {\r\n        let mut libro = Libro::default();\r\n        libro.isbn = u32::MAX as u64;\r\n        libro.titulo = \"algo\".to_string();\r\n        libro.stock = u32::MAX;\r\n        libro\r\n    }\r\n\r\n    #[test]\r\n    fn test_cant_copias() {\r\n        let mut biblioteca = biblioteca_de_pepe();\r\n\r\n        // test dec\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 5, \"ISBN 5 tiene 5 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 3, \"ISBN 3 tiene 3 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 1, \"ISBN 1 tiene 1 copias\");\r\n\r\n        biblioteca.decrementar_stock_libro(5);\r\n        biblioteca.decrementar_stock_libro(3);\r\n        biblioteca.decrementar_stock_libro(1);\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 4, \"ISBN 5 tiene 4 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 2, \"ISBN 3 tiene 2 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 0, \"ISBN 1 tiene 0 copias\");\r\n\r\n        // test inc\r\n\r\n        biblioteca.incrementar_stock_libro(5);\r\n        biblioteca.incrementar_stock_libro(3);\r\n        biblioteca.incrementar_stock_libro(1);\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 5, \"ISBN 5 tiene 5 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 3, \"ISBN 3 tiene 3 copias\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(1).unwrap(), 1, \"ISBN 1 tiene 1 copias\");\r\n\r\n        // test 0\r\n\r\n        biblioteca.decrementar_stock_libro(1);\r\n\r\n        biblioteca.decrementar_stock_libro(5);\r\n        biblioteca.decrementar_stock_libro(3);\r\n        let dec = biblioteca.decrementar_stock_libro(1);\r\n\r\n        assert_eq!(dec.unwrap_err(), ErrorDecrementarStock::StockEsCero, \"stock debería ser cero\");\r\n\r\n        // test overflow\r\n\r\n        let inc = biblioteca.incrementar_stock_libro(u32::MAX as u64);\r\n        assert_eq!(inc.unwrap_err(), ErrorIncrementarStock::Overflow, \"stock debería ser u32::MAX\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_prestamos() {\r\n        let mut biblioteca = biblioteca_de_pepe();\r\n\r\n        // init realizar prestamos\r\n\r\n        let fecha5 = Fecha{ dia: 1, mes: 1, ano: 1 };\r\n        let fecha3 = Fecha{ dia: 2, mes: 1, ano: 1 };\r\n\r\n        let p5 = biblioteca.realizar_prestamo(cliente_pepe(), 5, fecha5.clone());\r\n        let p3 = biblioteca.realizar_prestamo(cliente_manuel(), 3, fecha3.clone());\r\n\r\n        // check\r\n\r\n        if p5.is_err() { panic!(\"Error inesperado realizando préstamo: {:?}\", p5.unwrap_err()) }\r\n        if p3.is_err() { panic!(\"Error inesperado realizando préstamo: {:?}\", p3.unwrap_err()) }\r\n\r\n        assert_eq!(p5.unwrap(), 1, \"Debería tener 1 préstamo\");\r\n        assert_eq!(p3.unwrap(), 1, \"Debería tener 1 préstamo\");\r\n\r\n        // init cant copias\r\n\r\n        let stock5 = biblioteca.cantidad_de_copias_en_stock(5);\r\n        let stock3 = biblioteca.cantidad_de_copias_en_stock(3);\r\n\r\n        // check\r\n\r\n        if stock5.is_none() { panic!(\"cantidad_de_copias_en_strock(): None\") }\r\n        if stock3.is_none() { panic!(\"cantidad_de_copias_en_strock(): None\") }\r\n\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(5).unwrap(), 4, \"Deberían haber 4 copias en stock\");\r\n        assert_eq!(biblioteca.cantidad_de_copias_en_stock(3).unwrap(), 2, \"Deberían haber 2 copias en stock\");\r\n\r\n        // init prestamos por vencer\r\n\r\n        let prestamos_a_vencer0 = biblioteca.prestamos_por_vencer(Fecha { dia: 1, mes: 1, ano: -1 }, 0);\r\n        let prestamos_a_vencer1 = biblioteca.prestamos_por_vencer(fecha5.clone(), 0);\r\n        let prestamos_a_vencer2 = biblioteca.prestamos_por_vencer(fecha5.clone(), 1);\r\n        let prestamos_a_vencer2_2 = biblioteca.prestamos_por_vencer(Fecha { dia: 22, mes: 08, ano: 2002 }, 0);\r\n\r\n        // check\r\n\r\n        assert_eq!(prestamos_a_vencer0.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer1.len(), 1, \"Debería haber 1 préstamo a vencer\");\r\n        assert_eq!(prestamos_a_vencer2.len(), 2, \"Deberían haber 2 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2_2.len(), 2, \"Deberían haber 0 préstamos a vencer\");\r\n\r\n        // init buscar prestamos\r\n\r\n        let buscar_prestamo5 = biblioteca.buscar_prestamo(5, cliente_pepe().id);\r\n        let buscar_prestamo3 = biblioteca.buscar_prestamo(3, cliente_manuel().id);\r\n\r\n        // check\r\n\r\n        if buscar_prestamo5.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo5.unwrap_err()) }\r\n        if buscar_prestamo3.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo3.unwrap_err()) }\r\n\r\n        assert_eq!(buscar_prestamo5.unwrap().isbn, 5, \"El préstamo encontrado debería ser sobre el libro #5\");\r\n        assert_eq!(buscar_prestamo3.unwrap().isbn, 3, \"El préstamo encontrado debería ser sobre el libro #3\");\r\n\r\n        // init-check devolver prestamos\r\n\r\n        let devolucion_prestamo5 = biblioteca.devolver_libro(5, cliente_pepe().id, fecha5.clone());\r\n        if devolucion_prestamo5.is_err() { panic!(\"\") }\r\n\r\n        let devolucion_prestamo3 = biblioteca.devolver_libro(3, cliente_manuel().id, fecha3.clone());\r\n        if devolucion_prestamo3.is_err() { panic!(\"\") }\r\n\r\n        // init prestamos por vencer post-devolver\r\n\r\n        let prestamos_a_vencer0 = biblioteca.prestamos_por_vencer(Fecha { dia: 1, mes: 1, ano: -1 }, 0);\r\n        let prestamos_a_vencer1 = biblioteca.prestamos_por_vencer(fecha5.clone(), 0);\r\n        let prestamos_a_vencer2 = biblioteca.prestamos_por_vencer(fecha5.clone(), 1);\r\n        let prestamos_a_vencer2_2 = biblioteca.prestamos_por_vencer(Fecha { dia: 22, mes: 08, ano: 2002 }, 0);\r\n\r\n        // check\r\n\r\n        assert_eq!(prestamos_a_vencer0.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer1.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n        assert_eq!(prestamos_a_vencer2_2.len(), 0, \"Deberíam haber 0 préstamos a vencer\");\r\n\r\n        // init buscar prestamos post-devolver\r\n\r\n        let buscar_prestamo5 = biblioteca.buscar_prestamo(5, cliente_pepe().id);\r\n        let buscar_prestamo3 = biblioteca.buscar_prestamo(3, cliente_manuel().id);\r\n\r\n        // check\r\n\r\n        if buscar_prestamo5.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo5.unwrap_err()) }\r\n        if buscar_prestamo3.is_err() { panic!(\"Error buscar_prestamo(): {:?}\", buscar_prestamo3.unwrap_err()) }\r\n\r\n        assert_eq!(buscar_prestamo5.clone().unwrap().isbn, 5, \"El préstamo encontrado debería ser sobre el libro #5\");\r\n        assert_eq!(buscar_prestamo3.clone().unwrap().isbn, 3, \"El préstamo encontrado debería ser sobre el libro #3\");\r\n\r\n        assert_eq!(buscar_prestamo5.clone().unwrap().estado, EstadoPrestamo::Devuelto, \"El préstamo encontrado debería haber sido devuelto\");\r\n        assert_eq!(buscar_prestamo3.clone().unwrap().estado, EstadoPrestamo::Devuelto, \"El préstamo encontrado debería haber sido devuelto\");\r\n\r\n        assert!(buscar_prestamo5.unwrap().devolucion.is_some(), \"El préstamo encontrado debería haber sido devuelto\");\r\n        assert!(buscar_prestamo3.unwrap().devolucion.is_some(), \"El préstamo encontrado debería haber sido devuelto\");\r\n\r\n        // init max prestamos (5)\r\n\r\n        let p1 = biblioteca.realizar_prestamo(cliente_pepe(), 1, fecha5.clone());\r\n        let p2 = biblioteca.realizar_prestamo(cliente_pepe(), 2, fecha5.clone());\r\n        let p3 = biblioteca.realizar_prestamo(cliente_pepe(), 3, fecha5.clone());\r\n        let p4 = biblioteca.realizar_prestamo(cliente_pepe(), 4, fecha5.clone());\r\n        let p5 = biblioteca.realizar_prestamo(cliente_pepe(), 5, fecha5.clone());\r\n\r\n        let p6 = biblioteca.realizar_prestamo(cliente_pepe(), u32::MAX as u64, fecha3.clone());\r\n\r\n        // check\r\n\r\n        assert!(p1.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p2.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p3.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p4.is_ok(), \"El préstamo debería ser exitoso\");\r\n        assert!(p5.is_ok(), \"El préstamo debería ser exitoso\");\r\n\r\n        assert!(p6.is_err(), \"El préstamo no debería ser exitoso\");\r\n        assert_eq!(p6.unwrap_err(), ErrorRealizarPrestamo::PrestamosMaximosAlcanzados, \"Debería haberse alcanzado el límite máximo de préstamos\");\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","cliente.rs"],"content":"/// Del cliente se conoce:\r\n///     el nombre,\r\n///     teléfono\r\n///     y dirección de correo electrónico.\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Cliente {\r\n    pub id: u32,\r\n    pub nombre: String,\r\n    pub telefono: String,\r\n    pub email: String,\r\n}\r\n\r\nimpl Cliente {\r\n    pub fn new(id: u32, nombre: String, telefono: String, email: String) -\u003e Cliente {\r\n        Cliente { id, nombre, telefono, email }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","fecha.rs"],"content":"use std::cmp::Ordering;\r\nuse std::cmp::Ordering::{Equal, Greater, Less};\r\nuse std::fmt;\r\n\r\nconst NOMBRE_MESES: [\u0026str; 12] = [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\",\r\n    \"Mayo\", \"Junio\", \"Julio\", \"Agosto\",\r\n    \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"];\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct Fecha {\r\n    pub(crate) dia: u8,\r\n    pub(crate) mes: u8,\r\n    pub(crate) ano: i64\r\n}\r\n\r\nimpl Default for Fecha {\r\n    fn default() -\u003e Self {\r\n        Fecha { dia: 1, mes: 1, ano: 0 }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Fecha {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        if self.dia == other.dia\r\n            \u0026\u0026 self.mes == other.mes\r\n            \u0026\u0026 self.ano == other.ano\r\n        { return Some(Equal) }\r\n\r\n        if self.ano \u003e other.ano { return Some(Greater) }\r\n        if self.mes \u003e other.mes { return Some(Greater) }\r\n        if self.dia \u003e other.dia { return Some(Greater) }\r\n\r\n        Some(Less)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Fecha {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        if self.es_fecha_valida() {\r\n            write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        } else {\r\n            write!(f, \"{}/{}/{}\", self.dia, self.mes, self.ano)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Fecha {\r\n\r\n    // El año podría ser negativo, indicando días antes de Cristo.\r\n    pub fn new(dia: u8, mes: u8, ano: i64) -\u003e Option\u003cFecha\u003e {\r\n        let fecha = Fecha { dia, mes, ano };\r\n        if fecha.es_fecha_valida() {\r\n            return Some(fecha);\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n        // check que el mes sea válido\r\n        if !(1..=12).contains(\u0026self.mes) { return false }\r\n\r\n        // check días del mes\r\n        if self.dia == 0\r\n            || self.dia \u003e self.dias_mes_actual()\r\n        { return false }\r\n\r\n        // el año no puede ser incorrecto...\r\n        // a no ser que se contabilice la edad del universo\r\n        // que dudo mucho que pueda importar para este caso\r\n        true\r\n    }\r\n\r\n    pub fn es_bisiesto(\u0026self) -\u003e bool {\r\n        self.ano % 4 == 0\r\n    }\r\n\r\n    pub fn sumar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            let dias_mes_actual = self.dias_mes_actual();\r\n            let dias_para_proximo_mes = (dias_mes_actual - self.dia + 1) as u32;\r\n\r\n            if dias_restantes \u003e= dias_para_proximo_mes {\r\n                // ir al siguiente mes\r\n\r\n                dias_restantes-= dias_para_proximo_mes;\r\n                self.dia = 1;\r\n                self.mes += 1;\r\n\r\n                if self.mes \u003e 12 {\r\n                    self.mes = 1;\r\n                    self.ano+= 1;\r\n                }\r\n            } else {\r\n                self.dia+= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn restar_dias(\u0026mut self, dias: u32) {\r\n        let mut dias_restantes = dias;\r\n\r\n        while dias_restantes \u003e 0 {\r\n            if dias_restantes \u003e= self.dia as u32 {\r\n                // ir al anterior mes\r\n                dias_restantes-= self.dia as u32;\r\n                self.mes-= 1;\r\n\r\n                if self.mes \u003c 1 {\r\n                    self.mes = 12;\r\n                    self.ano-= 1;\r\n                }\r\n\r\n                // corregir self.dia == 0\r\n                self.dia = self.dias_mes_actual();\r\n            } else {\r\n                self.dia-= dias_restantes as u8;\r\n                dias_restantes = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn dias_mes_actual(\u0026self) -\u003e u8 {\r\n        match self.mes {\r\n            4 | 6 | 9 | 11 =\u003e 30,\r\n            2 =\u003e if self.es_bisiesto() { 29 } else { 28 },\r\n            _ =\u003e 31,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use std::fmt::{format, Display};\r\n    use crate::structs::fecha::{Fecha, NOMBRE_MESES};\r\n\r\n    #[test]\r\n    fn test_default() {\r\n        // default: 01/01/0000\r\n        let default_fecha = Fecha::default();\r\n        assert_eq!(default_fecha.dia, 1);\r\n        assert_eq!(default_fecha.mes, 1);\r\n        assert_eq!(default_fecha.ano, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_display() {\r\n        let valid_fecha = Fecha::default();\r\n        let invalid_fecha = Fecha { dia: 0, mes: 1, ano: 0 };\r\n        \r\n        // write!(f, \"{} de {} del {}\", self.dia, NOMBRE_MESES[self.mes as usize - 1], self.ano)\r\n        \r\n        assert_ne!(format!(\"{}\", valid_fecha), format!(\"{}\", invalid_fecha));\r\n        assert_eq!(format!(\"{}\", valid_fecha), format!(\"{} de {} del {}\", valid_fecha.dia, NOMBRE_MESES[valid_fecha.mes as usize - 1], valid_fecha.ano));\r\n        assert_eq!(format!(\"{}\", invalid_fecha), format!(\"{}/{}/{}\", invalid_fecha.dia, invalid_fecha.mes, invalid_fecha.ano))\r\n    }\r\n    \r\n    #[test]\r\n    fn test_new() {\r\n        // invalida\r\n        let fecha = Fecha::new(0, 0, 0);\r\n        assert!(fecha.is_none());\r\n        \r\n        // valida\r\n        let fecha = Fecha::new(22, 08, 2002);\r\n        assert!(fecha.is_some());\r\n    }\r\n    \r\n    #[test]\r\n    fn test_bisiesto() {\r\n        let fecha = Fecha::new(1, 1, 0).unwrap();\r\n        assert!(fecha.es_bisiesto());\r\n\r\n        let fecha = Fecha::new(1, 1, 2000).unwrap();\r\n        assert!(fecha.es_bisiesto());\r\n\r\n        let fecha = Fecha::new(1, 1, -4).unwrap();\r\n        assert!(fecha.es_bisiesto());\r\n\r\n        let fecha = Fecha::new(1, 1, 1).unwrap();\r\n        assert!(!fecha.es_bisiesto());\r\n    }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","libro.rs"],"content":"/// De cada libro se conoce:\r\n///     el título,\r\n///     autor,\r\n///     número de páginas,\r\n///     género (novela, infantil, técnico, otros).\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub(crate) struct Libro {\r\n    pub isbn: u64,\r\n    pub titulo: String,\r\n    pub autor: String,\r\n    pub paginas: u16,\r\n    pub genero: Genero,\r\n    pub stock: u32\r\n}\r\n\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub enum Genero {\r\n    Novela, Infantil, Tecnico, #[default] Otros\r\n}\r\n\r\nimpl Libro {\r\n    pub fn new(isbn: u64, titulo: String, autor: String, paginas: u16, genero: Genero, stock: u32) -\u003e Self {\r\n        Self { isbn, titulo, autor, paginas, genero, stock }\r\n    }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","mod.rs"],"content":"pub mod prestamo;\r\npub mod biblioteca;\r\npub mod cliente;\r\npub mod libro;\r\npub mod fecha;","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","src","structs","prestamo.rs"],"content":"use crate::structs::fecha::Fecha;\r\n\r\n/// Para registrar un préstamo se requiere:\r\n///     el libro,\r\n///     el cliente,\r\n///     la fecha de vencimiento del préstamo,\r\n///     la fecha de devolución\r\n///     y el estado (devuelto o en préstamo)\r\n#[derive(Clone, PartialEq, PartialOrd, Debug)]\r\npub struct Prestamo {\r\n    pub isbn: u64, // isbn\r\n    pub cliente: u32, // id\r\n    pub vencimiento: Fecha,\r\n    pub devolucion: Option\u003cFecha\u003e,\r\n    pub estado: EstadoPrestamo\r\n}\r\n\r\n#[derive(Default, Clone, PartialEq, PartialOrd, Debug)]\r\npub enum EstadoPrestamo {\r\n    Devuelto, #[default] Prestando\r\n}\r\n\r\nimpl Prestamo {\r\n    \r\n    pub fn new(isbn: u64, cliente: u32, vencimiento: Fecha, devolucion: Option\u003cFecha\u003e, estado: EstadoPrestamo) -\u003e Prestamo {\r\n        Prestamo { isbn, cliente, vencimiento, devolucion, estado }\r\n    }\r\n    \r\n}","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","target","debug","build","mime_guess-2521a3dfd26120e6","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","prac5","_p5e4","target","debug","build","mime_guess-354e957788aeeb2d","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["R:","\\","appcrap","RustRover","SdL-Rust","src","main.rs"],"content":"fn main() {}","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>